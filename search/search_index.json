{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BayesCalc2","text":"<p>A powerful Bayesian network calculator with interactive REPL</p> <p>BayesCalc2 is a command-line tool for defining, analyzing, and querying Bayesian networks. It provides an intuitive syntax for specifying probabilistic relationships and a rich set of commands for probability inference.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udd22 Bayesian Network Definition: Simple, human-readable <code>.net</code> file format</li> <li>\ud83e\uddee Probability Queries: Natural syntax like <code>P(Rain|GrassWet)</code> </li> <li>\ud83d\udcca Network Visualization: Generate PDF diagrams of your networks</li> <li>\ud83d\udd0d Advanced Inference: Variable elimination algorithm for efficient computation</li> <li>\ud83d\udcbb Interactive REPL: Tab completion, command history, and helpful feedback</li> <li>\ud83d\udcdd Batch Processing: Run multiple commands from script files</li> <li>\ud83d\udd17 Boolean Shorthand: Concise syntax for binary variables (<code>Rain</code> vs <code>Rain=True</code>)</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install bayescalc2\n</code></pre> <p>Or install from source:</p> <pre><code>git clone https://github.com/ljp/bayescalc2.git\ncd bayescalc2\npip install -e .\n</code></pre>"},{"location":"#your-first-network","title":"Your First Network","text":"<p>Create a simple network file <code>rain.net</code>:</p> <pre><code>variable Rain {True, False}\nvariable Sprinkler {On, Off}\nvariable GrassWet {Yes, No}\n\nRain { P(True) = 0.2 }\nSprinkler { P(On) = 0.1 }\n\nGrassWet | Rain, Sprinkler {\n    P(Yes | True, On) = 0.99\n    P(Yes | True, Off) = 0.90\n    P(Yes | False, On) = 0.85\n    P(Yes | False, Off) = 0.05\n}\n</code></pre>"},{"location":"#run-interactive-mode","title":"Run Interactive Mode","text":"<pre><code>bayescalc rain.net\n</code></pre> <p>Then query probabilities:</p> <pre><code>BayesCalc&gt; P(Rain|GrassWet=Yes)\nP(Rain=True | GrassWet=Yes) = 0.6203\n</code></pre>"},{"location":"#batch-mode","title":"Batch Mode","text":"<p>Create a command file <code>queries.txt</code>:</p> <pre><code>P(Rain)\nP(GrassWet=Yes|Rain=True)\nvisualize output.pdf\n</code></pre> <p>Run it:</p> <pre><code>bayescalc rain.net -b queries.txt\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>User Guide: Complete guide to using BayesCalc2</li> <li>Developer Guide: Architecture and development workflows</li> <li>Examples: Sample networks and use cases</li> <li>API Reference: Detailed API documentation</li> </ul>"},{"location":"#example-networks","title":"Example Networks","text":"<p>BayesCalc2 includes several example networks:</p> <ul> <li>Medical Diagnosis: Disease testing with false positives/negatives</li> <li>Weather Prediction: Rain, sprinkler, and grass wetness</li> <li>Student Performance: Exam results based on intelligence and difficulty</li> <li>Asia Chest Clinic: Medical diagnosis network from literature</li> <li>Monty Hall Problem: Classic probability puzzle</li> </ul> <p>See the Examples page for detailed explanations.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>BayesCalc2 uses a pipeline architecture:</p> <pre><code>.net files \u2192 Lexer \u2192 Parser \u2192 BayesianNetwork \u2192 Inference Engine\n                                        \u2193\n                            QueryParser \u2190 User Queries\n</code></pre> <p>Key components:</p> <ul> <li>Lexer: Tokenizes <code>.net</code> files</li> <li>Parser: Builds abstract syntax tree and network model</li> <li>BayesianNetwork: Data model for variables, domains, and CPTs</li> <li>Inference: Variable elimination algorithm for probability computation</li> <li>REPL: Interactive shell with tab completion</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please see the Developer Guide for:</p> <ul> <li>Setting up the development environment</li> <li>Running tests</li> <li>Code style guidelines</li> <li>Architecture overview</li> </ul>"},{"location":"#license","title":"License","text":"<p>BayesCalc2 is released under the MIT License. See LICENSE for details.</p>"},{"location":"BayesCalcReq/","title":"BayesCalcReq","text":"<p>As a math student and I want to create a Python program to investigate Bayesian networks. This should be a Bayesian network calculator useful for learning and teaching that I can query with standard mathematical notations.</p> <p>Implement a Python program in a structured way. Priority readability before speed. Use standard libraries such as numpy when possible. For lexical analysis and building if AST use standard libraries as far as possible.</p>"},{"location":"BayesCalcReq/#core-components-of-the-bayesian-network-calculator","title":"Core Components of the Bayesian Network Calculator","text":"<p>Should be structured into several modules under the <code>src/</code> directory. A suggested file structure could be:</p> <ol> <li>lexer.py: Tokenizes the input string.</li> <li>parser.py: Parses the tokens into an Abstract Syntax Tree (AST) representing the network.</li> <li>network_model.py: Defines data structures for variables, CPTs, and the overall Bayesian Network. Contains logic for CPT  auto-completion and validation.</li> <li>inference.py: Implements exact inference algorithms (e.g., Variable Elimination).</li> <li>queries.py: Handles parsing and executing probability queries.</li> <li>commands.py: Implements other utility commands (independence tests, tables, info-theory, graph).</li> <li>repl.py: Manages the interactive REPL mode.</li> <li>batch.py: Handles batch mode execution.</li> <li>main.py: Entry point for the application.</li> </ol>"},{"location":"BayesCalcReq/#detailed-specification","title":"Detailed specification","text":""},{"location":"BayesCalcReq/#a-input-format-and-grammar","title":"A) Input Format and Grammar","text":"<p>The input format should be designed to be human-readable, robust, and formally parsable. Inspired by INI/JSON-like formats, but simpler for high readability and parsing.</p> <p>The input format should support either Bayesian networks using \".net\" files or Joint Probability tables using the \".jpt\" format.</p>"},{"location":"BayesCalcReq/#example-bayesian-network-format-multi-value-variables","title":"Example Bayesian Network Format (Multi value variables)","text":"<pre><code># Example network definition\nvariable Rain {True, False}\nvariable Sprinkler {On, Off}\nvariable GrassWet {Yes, No}\n\n# CPT definitions\nRain {\n    P(True) = 0.2\n    # P(False) will be auto-filled\n}\n\nSprinkler | Rain {\n    P(On | True) = 0.01\n    P(On | False) = 0.4\n    # P(Off | parent) auto-filled\n}\n\nGrassWet | Rain, Sprinkler {\n    P(Yes | True, On) = 0.99\n    P(Yes | True, Off) = 0.8\n    P(Yes | False, On) = 0.9\n    # Remaining CPTs auto-completed\n}\n</code></pre> <p>If only boolean variables are used the specification can be simplified as</p> <pre><code># Example network definition. Simpleified Boolean variables\nvariable Rain \nvariable Sprinkler \nvariable GrassWet \n\n# CPT definitions\nRain {\n    P(T) = 0.2 # Could also be specified as P(1) = 0.2\n    # P(False) will be auto-filled\n}\n\nSprinkler | Rain {\n    P(T | T) = 0.01\n    P(T | T) = 0.4\n    # P(F | parent) auto-filled\n}\n\nGrassWet | Rain, Sprinkler {\n    P(T | T, T) = 0.99\n    P(T | T, F) = 0.8\n    P(T | F, T) = 0.9\n    # Remaining CPTs auto-completed\n}\n</code></pre>"},{"location":"BayesCalcReq/#bayesian-network-formal-grammar-ebnf-style","title":"Bayesian Network Formal Grammar (EBNF style)","text":"<p>For use with <code>*.net</code> input files.</p> <pre><code>&lt;network&gt;       ::= { &lt;variable_decl&gt; | &lt;cpt_block&gt; }\n\n&lt;variable_decl&gt; ::= \"variable\" &lt;identifier&gt; \"{\" &lt;value_list&gt; \"}\"\n&lt;value_list&gt;    ::= &lt;identifier&gt; { \",\" &lt;identifier&gt; }\n\n&lt;cpt_block&gt;     ::= &lt;identifier&gt; [ \"|\" &lt;parent_list&gt; ] \"{\" { &lt;cpt_entry&gt; } \"}\"\n&lt;parent_list&gt;   ::= &lt;identifier&gt; { \",\" &lt;identifier&gt; }\n\n&lt;cpt_entry&gt;     ::= \"P(\" &lt;value&gt; [ \"|\" &lt;condition_list&gt; ] \")\" \"=\" &lt;probability&gt;\n&lt;condition_list&gt;::= &lt;value&gt; { \",\" &lt;value&gt; }\n\n&lt;probability&gt;   ::= &lt;float&gt;\n&lt;float&gt;         ::= DIGIT+ \".\" DIGIT+\n&lt;identifier&gt;    ::= LETTER { LETTER | DIGIT | \"_\" }\n&lt;value&gt;         ::= &lt;identifier&gt;\n</code></pre> <p>This grammar is compact, easy to parse, supports Boolean and multi-valued variables, and allows partial specification of CPTs.</p>"},{"location":"BayesCalcReq/#example-joint-probability-table-format-for-boolean-variables","title":"Example Joint Probability Table Format for Boolean variables","text":"<pre><code>variable Sickness    # If yoiu are sick or not\nvariable Test        # The medicla test\n\nSickness, Test {\n    FF = 0.12\n    FT = 0.32\n    TF = 0.18\n    TT = 0.38\n}\n</code></pre>"},{"location":"BayesCalcReq/#joint-probability-table-format-formal-grammar-ebnf-style","title":"Joint Probability Table Format Formal Grammar (EBNF style)","text":"<p>For use with <code>*.jpt</code> input files.</p> <pre><code>&lt;network&gt;       ::= { &lt;variable_decl&gt; | &lt;jpt_block&gt; }\n\n&lt;variable_decl&gt; ::= \"variable\" &lt;identifier&gt; \n\n&lt;jpt_block&gt;     ::= &lt;identifier&gt; [ \",\" &lt;parent_list&gt; ] \"{\" { &lt;jpt_entry&gt; } \"}\"\n\n&lt;jpt_entry&gt;     ::= jpt_list \"=\" &lt;probability&gt;\n&lt;jpt_list&gt;      ::= &lt;jpt_value&gt; { &lt;jpt_value&gt; }\n\n&lt;probability&gt;   ::= &lt;float&gt;\n&lt;float&gt;         ::= DIGIT+ \".\" DIGIT+\n&lt;identifier&gt;    ::= LETTER { LETTER | DIGIT | \"_\" }\n&lt;jpt_value&gt;     ::= &lt;T|F&gt;\n</code></pre>"},{"location":"BayesCalcReq/#b-commands-set","title":"B) Commands Set","text":""},{"location":"BayesCalcReq/#probability-queries","title":"Probability Queries","text":"<ul> <li><code>P(A)</code> \u2013 marginal probability.</li> <li><code>P(A|B)</code> \u2013 conditional.</li> <li><code>P(A,B)</code> \u2013 joint.</li> <li><code>P(A|B,C)</code> \u2013 multi-conditionals.</li> <li>Arithmetic with probabilities (e.g., <code>P(A|B)*P(B)</code>).</li> </ul>"},{"location":"BayesCalcReq/#independence-tests","title":"Independence Tests","text":"<ul> <li><code>isindependent(A,B)</code></li> <li><code>iscondindependent(A,B|C)</code></li> </ul>"},{"location":"BayesCalcReq/#tables","title":"Tables","text":"<ul> <li><code>printCPT(X)</code> \u2013 CPT of node X.</li> <li><code>printJPT()</code> \u2013 full joint probability table.</li> <li><code>printContingency(A,B[,C,D])</code> \u2013 contingency table.</li> </ul>"},{"location":"BayesCalcReq/#information-theoretic","title":"Information-Theoretic","text":"<ul> <li><code>entropy(X)</code></li> <li><code>conditional_entropy(X|Y)</code></li> <li><code>mutual_information(X,Y)</code></li> <li><code>kl_divergence(P||Q)</code> if comparing models.</li> </ul>"},{"location":"BayesCalcReq/#graph-structure","title":"Graph \\&amp; Structure","text":"<ul> <li><code>showGraph()</code> \u2013 ASCII graph of network.</li> <li><code>parents(X)</code></li> <li><code>children(X)</code></li> </ul>"},{"location":"BayesCalcReq/#c-detailed-requirements","title":"C) Detailed Requirements","text":""},{"location":"BayesCalcReq/#input-network-model","title":"Input / Network Model","text":"<ol> <li>The system must parse the network specification defined by the custom grammar and give good error messages to helk the user</li> <li>The parser must produce detailed and specific error messages on incorrect syntax or if probability values adds up incorrectly.</li> <li>The input format must allow both Boolean and multi-valued nodes.</li> <li>Each variable must have explicitly defined states.</li> <li>CPT entries must only require minimal specification, with missing rows auto-completed.</li> <li>Probabilities must be validated for correctness (range , rows sum to 1).</li> <li>It must be possible to give long variable names.</li> <li>Variables with no parents must support prior probability declarations.</li> <li>Dependencies between variables must be clearly represented.</li> </ol>"},{"location":"BayesCalcReq/#probability-computation","title":"Probability Computation","text":"<ol> <li>Must compute marginal probabilities of any variable.</li> <li>Must compute conditional probabilities.</li> <li>Must compute joint probabilities.</li> <li>Must support basic probability arithmetic operations with symbolic commands.</li> <li>Efficient inference must work up to ~15 Boolean or ~8 multi-valued variables.</li> </ol>"},{"location":"BayesCalcReq/#queries","title":"Queries","text":"<ol> <li>Support expressions like <code>P(A|B)</code> where A,B can be events or conjunctions.</li> <li>Allow arithmetic expressions such as <code>P(A|B)*P(B)/P(A,B)</code>.</li> <li>Implement independence checks (<code>isindependent</code>).</li> <li>Implement conditional independence checks (<code>iscondindependent</code>).</li> <li>Tab-style completiopn should be possible for both variable names, value names, and commands</li> </ol>"},{"location":"BayesCalcReq/#commands-outputs","title":"Commands / Outputs","text":"<ol> <li><code>printCPT(X)</code> must output a CPT in readable tabular format.</li> <li><code>printJPT()</code> must print the full joint table.</li> <li><code>printContingency(A,B,C,D)</code> must handle up to 4 variables nicely formatted.</li> <li>Graph visualization must support ASCII rendering.</li> <li>Queries must show numeric results with 4\u20136 decimal precision.</li> </ol>"},{"location":"BayesCalcReq/#information-theoretic_1","title":"Information-Theoretic","text":"<ol> <li>Must compute entropy of a variable.</li> <li>Must compute conditional entropy given another variable.</li> <li>Must compute mutual information.</li> <li>Must compute KL divergence between models or distributions.</li> </ol>"},{"location":"BayesCalcReq/#execution-modes","title":"Execution Modes","text":"<ol> <li>Interactive REPL mode must allow iterative queries by user.</li> <li>Batch mode must read a model and list of commands and output results directly.</li> <li>Errors in batch mode must be clear and not interrupt entire processing.</li> <li>REPL mode must support history of commands.</li> <li>Both modes must be consistent on command execution.</li> </ol>"},{"location":"BayesCalcReq/#testing-quality","title":"Testing / Quality","text":"<ol> <li>All functionality must be unit-testable.</li> <li>Integration tests must validate full workflow from network definition \u2192 query \u2192 output.</li> <li>Timing performance must be reasonable for networks within scope (8 multi-value, 15 Boolean).</li> <li>Parser should be tested for robustness against malformed input.</li> <li>The output of probability values must be consistent with exact values within floating-point tolerance.</li> </ol>"},{"location":"BayesCalcReq/#usability","title":"Usability","text":"<ol> <li>Must support comments (<code>#</code>).</li> <li>Must not be sensitive to whitespace variations.</li> <li>Must provide help command listing all supported operations in REPL.</li> </ol>"},{"location":"BayesCalcReq/#d-possible-extensions","title":"D) Possible Extensions","text":"<p>Keep these future extensions in mind while developing the code</p> <ul> <li>Sampling methods: Add approximate inference via Gibbs sampling when exact computation is infeasible.</li> <li>Learning from data: Extend input format to allow datasets and perform parameter learning (estimate CPTs from frequency counts).</li> <li>Sensitivity analysis: Show how output probability changes if input CPTs vary slightly.</li> <li>Export formats: Ability to export/import from standard Bayesian network formats like <code>.xdsl</code> or <code>.bif</code>.</li> <li>Visualization: Graphical (non-ASCII) output using libraries like <code>networkx</code> or <code>graphviz</code>.</li> <li>Explanations: Explain step-by-step how a probability was computed (useful for teaching).</li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#v103-rc5-2025-10-12","title":"[v1.0.3-rc5] - 2025-10-12","text":"<p>Release Type: patch</p>"},{"location":"CHANGELOG/#internal","title":"\ud83d\udee0 Internal","text":"<ul> <li>Fix GitHub Release Creation Script o handle naming of pre-releases</li> </ul>"},{"location":"CHANGELOG/#v103-rc4-2025-10-12","title":"[v1.0.3-rc4] - 2025-10-12","text":"<p>Release Type: patch</p>"},{"location":"CHANGELOG/#internal_1","title":"\ud83d\udee0 Internal","text":"<ul> <li>Harmonize all build and release scripts to have the same structure</li> </ul>"},{"location":"CHANGELOG/#v103-rc3-2025-10-12","title":"[v1.0.3-rc3] - 2025-10-12","text":"<p>Release Type: patch</p>"},{"location":"CHANGELOG/#internal_2","title":"\ud83d\udee0 Internal","text":"<ul> <li>Improve build &amp; release scripts</li> </ul>"},{"location":"CHANGELOG/#v103-rc2-2025-10-12","title":"[v1.0.3-rc2] - 2025-10-12","text":"<p>Release Type: patch</p>"},{"location":"CHANGELOG/#internal_3","title":"\ud83d\udee0 Internal","text":"<ul> <li>Improve build &amp; release scripts</li> </ul>"},{"location":"CHANGELOG/#v103-rc1-2025-10-12","title":"[v1.0.3-rc1] - 2025-10-12","text":"<p>Release Type: patch</p>"},{"location":"CHANGELOG/#internal_4","title":"\ud83d\udee0 Internal","text":"<ul> <li>Improve build &amp; release scripts with additional error checking</li> </ul>"},{"location":"CHANGELOG/#v102-2025-10-11","title":"[v1.0.2] - 2025-10-11","text":"<p>Release Type: patch</p>"},{"location":"CHANGELOG/#improvements","title":"\ud83d\ude80 Improvements","text":"<ul> <li>Updated documentation across the tree</li> </ul>"},{"location":"CHANGELOG/#internal_5","title":"\ud83d\udee0 Internal","text":"<ul> <li>Optimize build and release scripts</li> <li>Added GitHub release script to automate creation of GitHub releases.</li> </ul>"},{"location":"CHANGELOG/#v101-2025-10-11","title":"[v1.0.1] - 2025-10-11","text":"<p>Release Focus: patch</p>"},{"location":"CHANGELOG/#improvements_1","title":"\ud83d\ude80 Improvements","text":"<ul> <li>Updated documentation across the tree</li> </ul>"},{"location":"CHANGELOG/#internal_6","title":"\ud83d\udee0 Internal","text":"<ul> <li>Added GitHub release script to automate creation of GitHub releases.</li> </ul>"},{"location":"CHANGELOG/#v100-2025-10-10","title":"[v1.0.0] - 2025-10-10","text":"<p>Release Focus: major</p>"},{"location":"CHANGELOG/#summary","title":"\ud83d\udccb Summary","text":"<p>This is the first release of the second generations of Bayescalc which uses a new  inference algorithm (based on variable elimination) to better handle larger networks. It also has a better CLI interface with pop-up auto-completion and command history. The network specification grammar has also been improved to better handle boolean variables and the specification of the JPT for the nodes to use a more compact methematical syntax. Finally the documentation have been improved with both a user guide and a developer guide.</p>"},{"location":"CHANGELOG/#additions","title":"\u2728 Additions","text":"<ul> <li>Added <code>load()</code> command to load a network while in interactive mode</li> <li>Added graphic visualization of network graph (PNG, PDF, SVG) format</li> <li>Command line history</li> <li>Updated network syntax with <code>boolean</code> keyword for boolean variables</li> <li>Developer guide documentation improvements</li> <li>User guide documentation improvements</li> </ul>"},{"location":"CHANGELOG/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>All lint and type checking warnings </li> </ul>"},{"location":"CHANGELOG/#internal_7","title":"\ud83d\udee0 Internal","text":"<ul> <li>Added unit tests to pass &gt;= 80% code coverage</li> <li>Updated and build and release scripts</li> <li>Updated CI/CD Github actions and pipelines</li> <li>Added PyPi upload</li> <li>Added build script for automatic code coverage badge updated</li> </ul>"},{"location":"CHANGELOG/#010-2025-09-30","title":"[0.1.0] - 2025-09-30","text":"<p>Relase type: alpha</p>"},{"location":"CHANGELOG/#additions_1","title":"\u2728 Additions","text":"<ul> <li>Complete rewrite of Bayescalc with new inference engine based on a variable elimination algorithm</li> <li>Use prompt_toolkit which gives both Tab-completion (with pop-up window) and command history</li> </ul>"},{"location":"developer_guide/","title":"BayesCalc2 Developer Guide","text":"<p>Purpose: A guide for developers contributing to the BayesCalc2 Bayesian Network Calculator project.</p>"},{"location":"developer_guide/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Setup for Development</li> <li>Codebase Overview</li> <li>Architecture and Design</li> <li>Testing Framework</li> <li>Writing Unit Tests</li> <li>REPL Testing Helpers</li> <li>Code Quality Guidelines</li> <li>Development Workflow</li> <li>Pull Request Guidelines</li> <li>Debugging and Performance</li> <li>Release Process</li> <li>Appendix A: Variable Elimination Algorithm</li> <li>Appendix B: GitHub Release Script Documentation</li> </ol>"},{"location":"developer_guide/#tldr-quick-setup-for-development","title":"TLDR; Quick Setup for Development","text":"<p>Steps to clone the repo and setup a working virtusl environment.</p>"},{"location":"developer_guide/#installing-pre-reqs","title":"Installing Pre-reqs","text":""},{"location":"developer_guide/#graphviz","title":"<code>graphviz</code>:","text":"<p>The bayescalc2 is using graphviz via its Python bindings to create graph visualizations.</p> <ul> <li>MacOS: <code>brew install graphviz</code></li> <li>Linux Fedore: <code>sudo dnf install grphviz</code></li> <li>Ubuntu: <code>sudo apt-get install graphviz</code></li> </ul>"},{"location":"developer_guide/#setting-up-python-virtual-environment-venv","title":"Setting up Python virtual environment (.venv)","text":"<ol> <li> <p>Clone and create venv:    <pre><code>git clone https://github.com/johan162/bayescalc2.git &amp;&amp; cd bayescalc2\npython3 -m venv .venv\nsource .venv/bin/activate\n</code></pre></p> </li> <li> <p>Install package in editable mode:    <pre><code>pip install -e .\n</code></pre></p> </li> <li> <p>Install dev dependencies from <code>pyproject.toml</code>:    <pre><code>pip install -e \".[dev]\"\n</code></pre></p> </li> <li> <p>Verify installation:    <pre><code>bayescalc --help\npython -c \"import bayescalc; print(bayescalc.__file__)\"\n</code></pre></p> </li> </ol>"},{"location":"developer_guide/#quick-build-guide","title":"Quick build guide","text":"<p>Once the local environment is setup and a code change has been made the primary build script <code>scripts/mkbld.sh</code> should be run. This script does the following checks</p> <ol> <li>That code coverage is &gt; 80%</li> <li>That all tests passes</li> <li>Run \"flake8\" static analysis with no errors  or warnings</li> <li>Checks code formatting with \"black\"</li> <li>Creates a PyPi distribution and validates with \"twine\"</li> </ol> <p>The build script must have a successfull result before a commit can be made.  The CI pipeline setup at GitHub will run the script as a pre-commit script that must pass.</p>"},{"location":"developer_guide/#codebase-overview","title":"Codebase Overview","text":""},{"location":"developer_guide/#project-structure","title":"Project Structure","text":"<pre><code>bayescalc2/\n\u251c\u2500\u2500 src/bayescalc/         # Main package source code\n\u251c\u2500\u2500 scripts/               # Build scrippts  \n\u251c\u2500\u2500 tests/                 # Comprehensive test suite\n\u251c\u2500\u2500 examples/              # Sample network files\n\u251c\u2500\u2500 docs/                  # Documentation\n\u251c\u2500\u2500 pyproject.toml         # Project configuration\n\u2514\u2500\u2500 README.md              # Basic usage guide\n</code></pre>"},{"location":"developer_guide/#core-modules","title":"Core Modules","text":""},{"location":"developer_guide/#srcbayescalc","title":"<code>src/bayescalc/</code>","text":"<p><code>network_model.py</code> - Core Data Structures - Purpose: Fundamental data structures for Bayesian networks - Key Classes:   - <code>Variable</code>: Represents random variables with discrete domains   - <code>Factor</code>: Represents probability distributions (CPTs, joint tables)   - <code>BayesianNetwork</code>: Main container for the entire network - Functionality: Variable management, factor operations, network validation - Dependencies: None (core module)</p> <p><code>lexer.py</code> - Tokenization - Purpose: Converts raw network file text into tokens - Key Classes:   - <code>Token</code>: Individual lexical unit (identifier, number, symbol)   - <code>TokenType</code>: Enumeration of token categories   - <code>Lexer</code>: Main tokenization engine - Functionality: String parsing, token classification, error reporting - Dependencies: None</p> <p><code>parser.py</code> - Syntax Analysis - Purpose: Converts tokens into network data structures - Key Classes:   - <code>Parser</code>: Recursive descent parser for network syntax - Functionality: Variable declaration parsing, CPT block parsing, syntax validation - Dependencies: <code>lexer.py</code>, <code>network_model.py</code></p> <p><code>inference.py</code> - Probabilistic Reasoning - Purpose: Exact inference algorithms for probability queries - Key Classes:   - <code>VariableElimination</code>: Main inference engine - Functionality: Variable elimination, marginalization, conditioning - Dependencies: <code>network_model.py</code>, <code>numpy</code> - Algorithms: Variable elimination with optimal ordering</p> <p><code>queries.py</code> - Query Processing - Purpose: Parse and execute probability queries - Key Classes:   - <code>QueryParser</code>: Parses P(A|B) syntax into structured queries - Functionality: Query parsing, evidence handling, result formatting - Dependencies: <code>lexer.py</code>, <code>parser.py</code>, <code>inference.py</code></p> <p><code>expression_parser.py</code> - Arithmetic Expressions - Purpose: Handle arithmetic operations with probabilities - Key Classes:   - <code>ExpressionParser</code>: Recursive descent parser for arithmetic - Functionality: Mathematical expressions, operator precedence, probability arithmetic - Dependencies: <code>queries.py</code></p> <p><code>commands.py</code> - Command Handler - Purpose: Interactive command processing and execution - Key Classes:   - <code>CommandHandler</code>: Central command dispatcher - Functionality: Command routing, parameter parsing, output formatting - Key Commands: <code>printCPT()</code>, <code>showGraph()</code>, <code>entropy()</code>, <code>isindependent()</code> - Dependencies: All other modules</p> <p><code>completer.py</code> - Tab Completion - Purpose: Interactive tab completion for the REPL - Key Classes:   - <code>PromptToolkitCompleter</code>: Integrates with prompt_toolkit - Functionality: Variable name completion, command completion, context-aware suggestions - Dependencies: <code>network_model.py</code>, <code>prompt_toolkit</code></p> <p><code>repl.py</code> - Interactive Interface - Purpose: Real-time interactive calculator interface - Key Classes:   - <code>REPL</code>: Main interactive loop and session management - Functionality: User interaction, command routing, session state - Dependencies: All modules, <code>prompt_toolkit</code></p> <p><code>batch.py</code> - Batch Processing - Purpose: Execute commands from files or command line - Key Classes:   - <code>BatchProcessor</code>: File-based command execution - Functionality: Script execution, output collection, error handling - Dependencies: <code>commands.py</code></p> <p><code>main.py</code> - Entry Point - Purpose: Application entry point and CLI argument processing - Key Functions:   - <code>main()</code>: Primary entry point - Functionality: Argument parsing, mode selection, application bootstrap - Dependencies: All modules</p>"},{"location":"developer_guide/#test-structure","title":"Test Structure","text":""},{"location":"developer_guide/#tests","title":"<code>tests/</code>","text":"<p>The test suite is organized by functionality and includes comprehensive coverage:</p> <p>Core Component Tests: - <code>test_network_model.py</code> - Data structure tests - <code>test_parser.py</code> - Syntax parsing tests - <code>test_lexer.py</code> - Tokenization tests (implicit) - <code>test_inference.py</code> - Inference algorithm tests - <code>test_queries.py</code> - Query processing tests</p> <p>Feature Tests: - <code>test_commands_queries.py</code> - Command execution tests - <code>test_completer.py</code> - Tab completion tests - <code>test_repl_e2e.py</code> - End-to-end REPL tests - <code>test_main.py</code> - CLI interface tests</p> <p>Edge Case Tests: - <code>test_error_handling.py</code> - Error condition tests - <code>test_numerical_edge_cases.py</code> - Numerical precision tests - <code>test_parser_edge_cases.py</code> - Parsing edge cases - <code>test_inference_edge_cases.py</code> - Inference edge cases</p> <p>Integration Tests: - <code>test_example_networks.py</code> - Full network validation - <code>test_large_networks.py</code> - Performance and scalability - <code>test_boolean_shorthand_*.py</code> - Boolean syntax variations</p> <p>Specialized Tests: - <code>test_command_argument_completion.py</code> - Tab completion regression tests - <code>test_advanced_numerical_cases.py</code> - Complex probability calculations</p>"},{"location":"developer_guide/#architecture-and-design","title":"Architecture and Design","text":""},{"location":"developer_guide/#design-principles","title":"Design Principles","text":""},{"location":"developer_guide/#separation-of-concerns","title":"Separation of Concerns","text":"<ul> <li>Parsing Layer: <code>lexer.py</code> \u2192 <code>parser.py</code> (syntax)</li> <li>Model Layer: <code>network_model.py</code> (data structures)</li> <li>Logic Layer: <code>inference.py</code> \u2192 <code>queries.py</code> (algorithms)</li> <li>Interface Layer: <code>repl.py</code> \u2192 <code>commands.py</code> (user interaction)</li> </ul>"},{"location":"developer_guide/#immutable-data-structures","title":"Immutable Data Structures","text":"<ul> <li><code>Variable</code> and <code>Factor</code> are immutable (frozen dataclasses)</li> <li>Network modifications create new objects rather than mutating existing ones</li> <li>Enables safe concurrent access and easier debugging</li> </ul>"},{"location":"developer_guide/#layered-architecture","title":"Layered Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Interface Layer \u2502  repl.py, main.py, batch.py\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Command Layer   \u2502  commands.py, completer.py\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Query Layer     \u2502  queries.py, expression_parser.py\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Inference Layer \u2502  inference.py\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Model Layer     \u2502  network_model.py\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Parsing Layer   \u2502  parser.py, lexer.py\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"developer_guide/#data-flow","title":"Data Flow","text":""},{"location":"developer_guide/#network-loading","title":"Network Loading","text":"<ol> <li>File Input \u2192 <code>lexer.py</code> (tokenization)</li> <li>Tokens \u2192 <code>parser.py</code> (AST construction)</li> <li>AST \u2192 <code>network_model.py</code> (network instantiation)</li> </ol>"},{"location":"developer_guide/#query-processing","title":"Query Processing","text":"<ol> <li>User Input \u2192 <code>queries.py</code> (query parsing)</li> <li>Query Object \u2192 <code>inference.py</code> (probability computation)</li> <li>Results \u2192 <code>commands.py</code> (formatting and display)</li> </ol>"},{"location":"developer_guide/#interactive-session","title":"Interactive Session","text":"<ol> <li>User Input \u2192 <code>repl.py</code> (session management)</li> <li>Commands \u2192 <code>commands.py</code> (command dispatch)</li> <li>Results \u2192 <code>repl.py</code> (output display)</li> </ol>"},{"location":"developer_guide/#key-design-patterns","title":"Key Design Patterns","text":""},{"location":"developer_guide/#factory-pattern","title":"Factory Pattern","text":"<ul> <li><code>BayesianNetwork.add_variable()</code> - creates <code>Variable</code> instances</li> <li><code>Parser._parse_*()</code> methods - create network components</li> </ul>"},{"location":"developer_guide/#strategy-pattern","title":"Strategy Pattern","text":"<ul> <li><code>CommandHandler.execute()</code> - selects appropriate command handler</li> <li><code>VariableElimination</code> - implements inference strategy</li> </ul>"},{"location":"developer_guide/#observer-pattern","title":"Observer Pattern","text":"<ul> <li>Test fixtures observe network state changes</li> <li>REPL observes command execution results</li> </ul>"},{"location":"developer_guide/#testing-framework","title":"Testing Framework","text":""},{"location":"developer_guide/#testing-philosophy","title":"Testing Philosophy","text":"<p>BayesCalc2 follows comprehensive testing principles:</p> <ol> <li>Unit Tests: Test individual components in isolation</li> <li>Integration Tests: Test component interactions</li> <li>End-to-End Tests: Test complete user workflows</li> <li>Edge Case Tests: Test boundary conditions and error scenarios</li> <li>Regression Tests: Prevent known bugs from reoccurring</li> </ol>"},{"location":"developer_guide/#test-organization","title":"Test Organization","text":""},{"location":"developer_guide/#test-categories","title":"Test Categories","text":"<p>API Tests: Test public interfaces and expected behavior <pre><code>def test_probability_query(self):\n    # Test P(A=True) returns correct probability\n    result = self.query_parser.parse_and_execute(\"P(Rain=True)\")\n    self.assertAlmostEqual(result, 0.2, places=3)\n</code></pre></p> <p>REPL Tests: Test interactive command execution <pre><code>def test_interactive_command(self):\n    # Test command execution in REPL context\n    result = self.command_handler.execute(\"printCPT(Rain)\")\n    self.assertIn(\"Probability\", result)\n</code></pre></p> <p>Error Tests: Validate error handling <pre><code>def test_invalid_variable_error(self):\n    with self.assertRaises(ValueError) as cm:\n        self.network.get_variable(\"NonExistent\")\n    self.assertIn(\"Variable 'NonExistent' not found\", str(cm.exception))\n</code></pre></p>"},{"location":"developer_guide/#test-utilities","title":"Test Utilities","text":"<p><code>tests/test_utils.py</code> provides helper functions: - <code>parse_string()</code> - Create networks from string definitions - Custom assertion methods for probability comparisons - Network validation helpers</p>"},{"location":"developer_guide/#running-tests","title":"Running Tests","text":""},{"location":"developer_guide/#full-test-suite","title":"Full Test Suite","text":"<pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=bayescalc --cov-report=html\n\n# Run specific test file\npytest tests/test_network_model.py\n\n# Run tests matching pattern\npytest -k \"test_probability\"\n</code></pre>"},{"location":"developer_guide/#test-selection","title":"Test Selection","text":"<pre><code># Run only unit tests\npytest tests/test_network_model.py tests/test_parser.py\n\n# Run integration tests\npytest tests/test_commands_queries.py tests/test_example_networks.py\n\n# Run edge case tests\npytest tests/test_*edge_cases.py tests/test_error_handling.py\n</code></pre>"},{"location":"developer_guide/#writing-unit-tests","title":"Writing Unit Tests","text":""},{"location":"developer_guide/#test-structure-template","title":"Test Structure Template","text":"<pre><code>\"\"\"\nTest module for [component name].\n\"\"\"\nimport unittest\nfrom typing import Dict, List, Any\n\n# Import the module being tested\nfrom bayescalc.network_model import BayesianNetwork, Variable, Factor\n\nclass Test[ComponentName](unittest.TestCase):\n    \"\"\"Test cases for [ComponentName] class.\"\"\" \n\n    def setUp(self):\n        \"\"\"Set up test fixtures before each test method.\"\"\"\n        self.network = BayesianNetwork()\n        self.network.add_variable(\"TestVar\", (\"True\", \"False\"))\n\n    def tearDown(self):\n        \"\"\"Clean up after each test method.\"\"\"\n        # Usually not needed due to test isolation\n        pass\n\n    def test_[specific_functionality](self):\n        \"\"\"Test [specific functionality] works correctly.\"\"\"\n        # Arrange - Set up test data\n        expected_result = \"expected_value\"\n\n        # Act - Execute the functionality\n        actual_result = self.network.some_method(\"TestVar\")\n\n        # Assert - Verify the results\n        self.assertEqual(actual_result, expected_result)\n\n    def test_[error_condition](self):\n        \"\"\"Test that [error condition] raises appropriate exception.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            self.network.invalid_operation()\n\n        self.assertIn(\"expected error message\", str(context.exception))\n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre>"},{"location":"developer_guide/#testing-best-practices","title":"Testing Best Practices","text":""},{"location":"developer_guide/#1-test-network-setup","title":"1. Test Network Setup","text":"<p>Use Test Utilities: <pre><code>from tests.test_utils import parse_string\n\ndef setUp(self):\n    network_def = \"\"\"\n    variable Rain {True, False}\n    variable Sprinkler {True, False}\n\n    Rain {\n        P(True) = 0.2\n    }\n\n    Sprinkler | Rain {\n        P(True | True) = 0.01\n        P(True | False) = 0.4\n    }\n    \"\"\"\n    self.network = parse_string(network_def)\n</code></pre></p> <p>Create Minimal Networks: <pre><code>def setUp(self):\n    # Minimal network for focused testing\n    self.network = BayesianNetwork()\n    self.network.add_variable(\"A\", (\"True\", \"False\"))\n    self.network.add_factor(\"A\", [], {(\"True\",): 0.3, (\"False\",): 0.7})\n</code></pre></p>"},{"location":"developer_guide/#2-probability-testing","title":"2. Probability Testing","text":"<p>Use Appropriate Precision: <pre><code>def test_probability_calculation(self):\n    result = self.network.query(\"P(Rain=True)\")\n    # Use places for decimal precision\n    self.assertAlmostEqual(result, 0.2, places=3)\n\n    # Or use delta for absolute tolerance\n    self.assertAlmostEqual(result, 0.2, delta=0.001)\n</code></pre></p> <p>Test Probability Properties: <pre><code>def test_probability_normalization(self):\n    \"\"\"Test that probabilities sum to 1.0.\"\"\"\n    prob_true = self.network.query(\"P(Rain=True)\")\n    prob_false = self.network.query(\"P(Rain=False)\")\n    total = prob_true + prob_false\n    self.assertAlmostEqual(total, 1.0, places=6)\n</code></pre></p>"},{"location":"developer_guide/#3-command-testing","title":"3. Command Testing","text":"<p>Test Command Execution: <pre><code>def test_print_cpt_command(self):\n    \"\"\"Test printCPT command produces expected output.\"\"\"\n    result = self.command_handler.execute(\"printCPT(Rain)\")\n\n    # Check for expected elements in output\n    self.assertIn(\"Child\", result)\n    self.assertIn(\"Parents\", result)\n    self.assertIn(\"Probability\", result)\n    self.assertIn(\"Rain\", result)\n</code></pre></p> <p>Test Error Commands: <pre><code>def test_invalid_command_error(self):\n    \"\"\"Test that invalid commands produce helpful errors.\"\"\"\n    with self.assertRaises(ValueError) as context:\n        self.command_handler.execute(\"invalidCommand()\")\n\n    error_msg = str(context.exception)\n    self.assertIn(\"Unknown command\", error_msg)\n</code></pre></p>"},{"location":"developer_guide/#4-parser-testing","title":"4. Parser Testing","text":"<p>Test Valid Syntax: <pre><code>def test_variable_declaration_parsing(self):\n    \"\"\"Test parsing of variable declarations.\"\"\"\n    tokens = self.lexer.tokenize(\"variable Test {A, B, C}\")\n    parser = Parser(tokens)\n    network = parser.parse()\n\n    self.assertIn(\"Test\", network.variables)\n    self.assertEqual(network.get_variable(\"Test\").domain, (\"A\", \"B\", \"C\"))\n</code></pre></p> <p>Test Invalid Syntax: <pre><code>def test_syntax_error_handling(self):\n    \"\"\"Test that syntax errors are properly reported.\"\"\"\n    with self.assertRaises(SyntaxError) as context:\n        tokens = self.lexer.tokenize(\"variable { }\")  # Missing name\n        Parser(tokens).parse()\n\n    error_msg = str(context.exception)\n    self.assertIn(\"Expected\", error_msg)\n    self.assertIn(\"line\", error_msg)  # Should include line number\n</code></pre></p>"},{"location":"developer_guide/#example-complete-test-class","title":"Example: Complete Test Class","text":"<pre><code>\"\"\"\nTests for the Variable class in network_model.py\n\"\"\"\nimport unittest\nfrom bayescalc.network_model import Variable\n\nclass TestVariable(unittest.TestCase):\n    \"\"\"Test cases for Variable class.\"\"\"\n\n    def test_variable_creation(self):\n        \"\"\"Test basic variable creation.\"\"\"\n        var = Variable(\"TestVar\", (\"A\", \"B\"))\n        self.assertEqual(var.name, \"TestVar\")\n        self.assertEqual(var.domain, (\"A\", \"B\"))\n\n    def test_boolean_variable_detection(self):\n        \"\"\"Test detection of boolean variables.\"\"\"\n        bool_var = Variable(\"BoolVar\", (\"True\", \"False\"))\n        multi_var = Variable(\"MultiVar\", (\"A\", \"B\", \"C\"))\n\n        self.assertTrue(bool_var.is_boolean)\n        self.assertFalse(multi_var.is_boolean)\n\n    def test_variable_type_property(self):\n        \"\"\"Test var_type property returns correct values.\"\"\"\n        bool_var = Variable(\"BoolVar\", (\"True\", \"False\"))\n        multi_var = Variable(\"MultiVar\", (\"A\", \"B\", \"C\"))\n\n        self.assertEqual(bool_var.var_type, \"Boolean\")\n        self.assertEqual(multi_var.var_type, \"Multival\")\n\n    def test_variable_immutability(self):\n        \"\"\"Test that variables are immutable.\"\"\"\n        var = Variable(\"Test\", (\"A\", \"B\"))\n\n        # Should not be able to modify\n        with self.assertRaises(AttributeError):\n            var.name = \"NewName\"\n\n        with self.assertRaises(AttributeError):\n            var.domain = (\"C\", \"D\")\n\n    def test_variable_repr(self):\n        \"\"\"Test string representation of variables.\"\"\"\n        var = Variable(\"Test\", (\"A\", \"B\"))\n        repr_str = repr(var)\n\n        self.assertIn(\"Variable\", repr_str)\n        self.assertIn(\"Test\", repr_str)\n        self.assertIn(\"A\", repr_str)\n        self.assertIn(\"B\", repr_str)\n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre>"},{"location":"developer_guide/#repl-testing-helpers","title":"REPL Testing Helpers","text":""},{"location":"developer_guide/#interactive-testing-philosophy","title":"Interactive Testing Philosophy","text":"<p>REPL (Read-Eval-Print Loop) testing ensures that interactive commands work correctly in realistic usage scenarios. BayesCalc2 provides specialized helpers for testing interactive functionality without requiring actual terminal interaction.</p>"},{"location":"developer_guide/#mock-based-repl-testing","title":"Mock-Based REPL Testing","text":""},{"location":"developer_guide/#test-infrastructure","title":"Test Infrastructure","text":"<p><code>tests/test_repl_e2e.py</code> provides the foundation:</p> <pre><code>\"\"\"\nExample of REPL testing using mock objects.\n\"\"\"\nimport unittest\nfrom unittest.mock import MagicMock\nfrom bayescalc.completer import PromptToolkitCompleter\nfrom bayescalc.network_model import BayesianNetwork\n\nclass TestReplInteraction(unittest.TestCase):\n\n    def setUp(self):\n        # Create test network\n        self.network = BayesianNetwork()\n        self.network.add_variable(\"Rain\", (\"True\", \"False\"))\n        self.network.add_variable(\"Sprinkler\", (\"True\", \"False\"))\n\n        # Set up REPL components\n        from bayescalc.commands import CommandHandler\n        self.command_handler = CommandHandler(self.network)\n        self.completer = PromptToolkitCompleter(self.network)\n\n    def test_command_execution_sequence(self):\n        \"\"\"Test a sequence of interactive commands.\"\"\"\n        # Simulate user typing commands\n        commands = [\n            \"ls\",\n            \"P(Rain=True)\",\n            \"printCPT(Rain)\",\n            \"showGraph()\"\n        ]\n\n        results = []\n        for cmd in commands:\n            try:\n                result = self.command_handler.execute(cmd)\n                results.append(result)\n            except Exception as e:\n                self.fail(f\"Command '{cmd}' failed: {e}\")\n\n        # Verify results\n        self.assertIn(\"Variable\", results[0])  # ls output\n        self.assertIsInstance(results[1], float)  # probability value\n        self.assertIn(\"Probability\", results[2])  # CPT output\n        self.assertIn(\"Rain\", results[3])  # graph output\n</code></pre>"},{"location":"developer_guide/#tab-completion-testing","title":"Tab Completion Testing","text":""},{"location":"developer_guide/#mock-document-objects","title":"Mock Document Objects","text":"<pre><code>class MockDocument:\n    \"\"\"Mock prompt_toolkit document for testing completion.\"\"\"\n\n    def __init__(self, text_before_cursor: str):\n        self.text_before_cursor = text_before_cursor\n        self.text_after_cursor = \"\"\n        self.text = text_before_cursor\n        self.cursor_position = len(text_before_cursor)\n\n    def get_word_before_cursor(self, WORD=False):\n        \"\"\"Extract word before cursor for completion.\"\"\"\n        if not self.text_before_cursor:\n            return \"\"\n\n        # Simple word extraction (can be enhanced)\n        parts = self.text_before_cursor.split()\n        return parts[-1] if parts else \"\"\n\nclass MockCompletion:\n    \"\"\"Mock completion object.\"\"\"\n\n    def __init__(self, text: str):\n        self.text = text\n        self.start_position = 0\n\ndef test_variable_name_completion(self):\n    \"\"\"Test completion of variable names.\"\"\"\n    doc = MockDocument(\"P(R\")\n    completions = list(self.completer.get_completions(doc, None))\n\n    # Should suggest \"Rain\"\n    completion_texts = [c.text for c in completions]\n    self.assertIn(\"ain\", completion_texts)  # Completing \"R\" \u2192 \"Rain\"\n</code></pre>"},{"location":"developer_guide/#command-testing-helpers","title":"Command Testing Helpers","text":""},{"location":"developer_guide/#command-execution-testing","title":"Command Execution Testing","text":"<pre><code>def execute_command_safely(self, command: str):\n    \"\"\"Execute command and return result or error.\"\"\"\n    try:\n        return self.command_handler.execute(command), None\n    except Exception as e:\n        return None, str(e)\n\ndef test_command_error_handling(self):\n    \"\"\"Test that commands handle errors gracefully.\"\"\"\n    # Test invalid variable\n    result, error = self.execute_command_safely(\"P(InvalidVar=True)\")\n    self.assertIsNone(result)\n    self.assertIn(\"Variable 'InvalidVar' not found\", error)\n\n    # Test invalid syntax\n    result, error = self.execute_command_safely(\"P(Rain=)\")\n    self.assertIsNone(result)\n    self.assertIn(\"syntax\", error.lower())\n</code></pre>"},{"location":"developer_guide/#interactive-session-simulation","title":"Interactive Session Simulation","text":"<pre><code>class MockReplSession:\n    \"\"\"Simulate a complete REPL session.\"\"\"\n\n    def __init__(self, network: BayesianNetwork):\n        self.network = network\n        self.command_handler = CommandHandler(network)\n        self.session_history = []\n\n    def execute(self, command: str):\n        \"\"\"Execute command and store in history.\"\"\"\n        try:\n            result = self.command_handler.execute(command)\n            self.session_history.append((command, result, None))\n            return result\n        except Exception as e:\n            self.session_history.append((command, None, str(e)))\n            raise\n\n    def get_history(self):\n        \"\"\"Return session history for analysis.\"\"\"\n        return self.session_history\n\ndef test_full_session_workflow(self):\n    \"\"\"Test a complete user workflow.\"\"\"\n    session = MockReplSession(self.network)\n\n    # Simulate user workflow\n    workflow = [\n        (\"ls\", \"should list variables\"),\n        (\"P(Rain=True)\", \"should return probability\"),\n        (\"P(Rain=True | Sprinkler=True)\", \"should handle conditioning\"),\n        (\"entropy(Rain)\", \"should calculate entropy\"),\n        (\"showGraph()\", \"should display graph\")\n    ]\n\n    for command, description in workflow:\n        try:\n            result = session.execute(command)\n            self.assertIsNotNone(result, f\"Command '{command}' failed: {description}\")\n        except Exception as e:\n            self.fail(f\"Workflow step '{command}' failed: {e}\")\n</code></pre>"},{"location":"developer_guide/#completion-testing-patterns","title":"Completion Testing Patterns","text":""},{"location":"developer_guide/#testing-command-completion","title":"Testing Command Completion","text":"<pre><code>def test_command_name_completion(self):\n    \"\"\"Test completion of command names.\"\"\"\n    test_cases = [\n        (\"prin\", [\"printCPT\"]),\n        (\"show\", [\"showGraph\"]),\n        (\"isen\", [\"isindependent\"]),\n        (\"entro\", [\"entropy\"])\n    ]\n\n    for prefix, expected in test_cases:\n        doc = MockDocument(prefix)\n        completions = list(self.completer.get_completions(doc, None))\n        completion_texts = [c.text for c in completions]\n\n        for exp in expected:\n            # Check if any completion contains expected text\n            self.assertTrue(\n                any(exp in comp for comp in completion_texts),\n                f\"Expected '{exp}' in completions for '{prefix}': {completion_texts}\"\n            )\n</code></pre>"},{"location":"developer_guide/#testing-context-aware-completion","title":"Testing Context-Aware Completion","text":"<pre><code>def test_context_aware_completion(self):\n    \"\"\"Test completion respects command context.\"\"\"\n    # Inside printCPT(), should complete variable names\n    doc = MockDocument(\"printCPT(R\")\n    completions = list(self.completer.get_completions(doc, None))\n\n    # Should suggest variable names, not command names\n    completion_texts = [c.text for c in completions]\n    self.assertTrue(any(\"ain\" in comp for comp in completion_texts))  # \"Rain\"\n\n    # Outside commands, should complete command names\n    doc = MockDocument(\"prin\")\n    completions = list(self.completer.get_completions(doc, None))\n    completion_texts = [c.text for c in completions]\n    self.assertTrue(any(\"tCPT\" in comp for comp in completion_texts))  # \"printCPT\"\n</code></pre>"},{"location":"developer_guide/#integration-test-helpers","title":"Integration Test Helpers","text":""},{"location":"developer_guide/#end-to-end-workflow-testing","title":"End-to-End Workflow Testing","text":"<pre><code>def create_test_workflow(self):\n    \"\"\"Create a standard test workflow for REPL testing.\"\"\"\n    return [\n        # Basic exploration\n        \"ls\",\n        \"showGraph()\",\n\n        # Simple queries\n        \"P(Rain=True)\",\n        \"P(Sprinkler=True)\",\n\n        # Conditional queries\n        \"P(Rain=True | Sprinkler=True)\",\n\n        # Table display\n        \"printCPT(Rain)\",\n        \"printCPT(Sprinkler)\",\n\n        # Analysis commands\n        \"entropy(Rain)\",\n        \"isindependent(Rain, Sprinkler)\",\n\n        # Graph analysis\n        \"parents(Sprinkler)\",\n        \"children(Rain)\"\n    ]\n\ndef test_standard_workflow(self):\n    \"\"\"Test standard user workflow executes without errors.\"\"\"\n    session = MockReplSession(self.network)\n    workflow = self.create_test_workflow()\n\n    for i, command in enumerate(workflow):\n        try:\n            result = session.execute(command)\n            self.assertIsNotNone(result, f\"Step {i+1}: '{command}' returned None\")\n        except Exception as e:\n            self.fail(f\"Step {i+1}: '{command}' failed with: {e}\")\n</code></pre>"},{"location":"developer_guide/#code-quality-guidelines","title":"Code Quality Guidelines","text":""},{"location":"developer_guide/#python-style-guidelines","title":"Python Style Guidelines","text":""},{"location":"developer_guide/#pep-8-compliance","title":"PEP 8 Compliance","text":"<ul> <li>Line Length: Maximum 100 characters (slightly more than standard 79 for readability)</li> <li>Indentation: 4 spaces (no tabs)</li> <li>Imports: Organized according to PEP 8 (standard library, third-party, local)</li> <li>Naming Conventions:</li> <li>Functions and variables: <code>snake_case</code></li> <li>Classes: <code>PascalCase</code></li> <li>Constants: <code>UPPER_CASE</code></li> <li>Private members: <code>_leading_underscore</code></li> </ul>"},{"location":"developer_guide/#example-code-structure","title":"Example Code Structure","text":"<pre><code>\"\"\"\nModule docstring describing purpose and usage.\n\"\"\"\nfrom typing import Dict, List, Optional, Tuple\nimport os\nimport sys\n\nimport numpy as np\nfrom prompt_toolkit import PromptSession\n\nfrom .network_model import BayesianNetwork, Variable\nfrom .utils import validate_probability\n\n# Module-level constants\nDEFAULT_PRECISION = 4\nMAX_VARIABLES = 20\n\nclass ExampleClass:\n    \"\"\"Class docstring describing purpose and usage.\"\"\"\n\n    def __init__(self, network: BayesianNetwork):\n        \"\"\"Initialize with a Bayesian network.\"\"\"\n        self.network = network\n        self._cache: Dict[str, float] = {}\n\n    def public_method(self, variable_name: str) -&gt; Optional[float]:\n        \"\"\"\n        Public method with clear docstring.\n\n        Args:\n            variable_name: Name of the variable to process\n\n        Returns:\n            Computed probability or None if not found\n\n        Raises:\n            ValueError: If variable_name is invalid\n        \"\"\"\n        if not variable_name:\n            raise ValueError(\"Variable name cannot be empty\")\n\n        # Implementation here\n        return self._compute_probability(variable_name)\n\n    def _private_method(self, data: List[float]) -&gt; float:\n        \"\"\"Private helper method.\"\"\"\n        return sum(data) / len(data) if data else 0.0\n</code></pre>"},{"location":"developer_guide/#documentation-standards","title":"Documentation Standards","text":""},{"location":"developer_guide/#docstring-format","title":"Docstring Format","text":"<p>Use Google-style docstrings for consistency:</p> <pre><code>def complex_function(network: BayesianNetwork, \n                    variables: List[str],\n                    evidence: Dict[str, str] = None) -&gt; Dict[str, float]:\n    \"\"\"\n    Compute marginal probabilities for multiple variables.\n\n    This function performs variable elimination to compute the marginal\n    probability distribution for each variable in the provided list,\n    optionally conditioned on evidence.\n\n    Args:\n        network: The Bayesian network to query\n        variables: List of variable names to compute marginals for\n        evidence: Optional evidence as variable-&gt;value mapping\n\n    Returns:\n        Dictionary mapping variable names to their marginal probabilities\n\n    Raises:\n        ValueError: If any variable name is not found in the network\n        RuntimeError: If inference fails due to numerical issues\n\n    Example:\n        &gt;&gt;&gt; network = create_rain_network()\n        &gt;&gt;&gt; marginals = compute_marginals(network, [\"Rain\", \"Sprinkler\"])\n        &gt;&gt;&gt; print(marginals[\"Rain\"])\n        0.2\n    \"\"\"\n</code></pre>"},{"location":"developer_guide/#type-hints","title":"Type Hints","text":"<p>Use comprehensive type hints:</p> <pre><code>from typing import Dict, List, Optional, Tuple, Union, Any\n\n# Specific type hints\ndef process_probabilities(probs: Dict[Tuple[str, ...], float]) -&gt; List[float]:\n    \"\"\"Process probability dictionary.\"\"\"\n    return list(probs.values())\n\n# Union types for flexibility\ndef parse_value(value: Union[str, float, int]) -&gt; float:\n    \"\"\"Parse various input types to float.\"\"\"\n    return float(value)\n\n# Optional for nullable values\ndef find_variable(name: str) -&gt; Optional[Variable]:\n    \"\"\"Find variable by name, return None if not found.\"\"\"\n    return self.variables.get(name)\n</code></pre>"},{"location":"developer_guide/#error-handling-best-practices","title":"Error Handling Best Practices","text":""},{"location":"developer_guide/#specific-exception-types","title":"Specific Exception Types","text":"<pre><code># Custom exception hierarchy\nclass BayesCalcError(Exception):\n    \"\"\"Base exception for BayesCalc errors.\"\"\"\n    pass\n\nclass NetworkError(BayesCalcError):\n    \"\"\"Errors related to network structure.\"\"\"\n    pass\n\nclass QueryError(BayesCalcError):\n    \"\"\"Errors in query processing.\"\"\"\n    pass\n\nclass InferenceError(BayesCalcError):\n    \"\"\"Errors during probabilistic inference.\"\"\"\n    pass\n\n# Usage in code\ndef add_variable(self, name: str, domain: Tuple[str, ...]) -&gt; None:\n    \"\"\"Add variable to network.\"\"\"\n    if name in self.variables:\n        raise NetworkError(f\"Variable '{name}' already exists\")\n\n    if len(domain) &lt; 2:\n        raise NetworkError(f\"Variable '{name}' must have at least 2 values\")\n\n    self.variables[name] = Variable(name, domain)\n</code></pre>"},{"location":"developer_guide/#informative-error-messages","title":"Informative Error Messages","text":"<pre><code>def validate_probability_query(self, query: str) -&gt; None:\n    \"\"\"Validate probability query syntax.\"\"\"\n    if not query.startswith(\"P(\"):\n        raise QueryError(\n            f\"Invalid query '{query}': must start with 'P('. \"\n            f\"Example: P(Rain=True) or P(A|B=b)\"\n        )\n\n    if not query.endswith(\")\"):\n        raise QueryError(\n            f\"Invalid query '{query}': missing closing parenthesis. \"\n            f\"Check for balanced parentheses in '{query}'\"\n        )\n</code></pre>"},{"location":"developer_guide/#performance-guidelines","title":"Performance Guidelines","text":""},{"location":"developer_guide/#efficient-data-structures","title":"Efficient Data Structures","text":"<pre><code># Use tuples for immutable keys\nprobability_cache: Dict[Tuple[str, ...], float] = {}\n\n# Use sets for membership testing\nvariable_names: Set[str] = set(network.variables.keys())\nif \"Rain\" in variable_names:  # O(1) lookup\n    process_variable(\"Rain\")\n\n# Use list comprehensions for transformations\nprobabilities = [factor.get_probability(assignment) \n                for assignment in all_assignments]\n</code></pre>"},{"location":"developer_guide/#caching-strategies","title":"Caching Strategies","text":"<pre><code>from functools import lru_cache\n\nclass BayesianNetwork:\n    @lru_cache(maxsize=1000)\n    def _compute_marginal(self, variable: str, evidence_tuple: Tuple[Tuple[str, str], ...]) -&gt; float:\n        \"\"\"Cached marginal computation.\"\"\"\n        # Convert evidence tuple back to dict for processing\n        evidence = dict(evidence_tuple) if evidence_tuple else {}\n        return self._perform_inference(variable, evidence)\n\n    def compute_marginal(self, variable: str, evidence: Dict[str, str] = None) -&gt; float:\n        \"\"\"Public interface with caching.\"\"\"\n        evidence_tuple = tuple(sorted(evidence.items())) if evidence else ()\n        return self._compute_marginal(variable, evidence_tuple)\n</code></pre>"},{"location":"developer_guide/#testing-quality-standards","title":"Testing Quality Standards","text":""},{"location":"developer_guide/#comprehensive-test-coverage","title":"Comprehensive Test Coverage","text":"<pre><code>def test_all_edge_cases(self):\n    \"\"\"Test comprehensive edge cases for probability computation.\"\"\"\n    test_cases = [\n        # (description, input, expected_output, should_raise)\n        (\"zero probability\", {\"A\": 0.0, \"B\": 1.0}, 0.0, None),\n        (\"one probability\", {\"A\": 1.0, \"B\": 0.0}, 1.0, None),\n        (\"negative probability\", {\"A\": -0.1, \"B\": 1.1}, None, ValueError),\n        (\"probabilities sum &gt; 1\", {\"A\": 0.6, \"B\": 0.6}, None, ValueError),\n        (\"empty probabilities\", {}, None, ValueError),\n    ]\n\n    for description, input_data, expected, should_raise in test_cases:\n        with self.subTest(description=description):\n            if should_raise:\n                with self.assertRaises(should_raise):\n                    self.network.set_probabilities(input_data)\n            else:\n                result = self.network.compute_probability(input_data)\n                self.assertAlmostEqual(result, expected, places=6)\n</code></pre>"},{"location":"developer_guide/#test-data-management","title":"Test Data Management","text":"<pre><code>class NetworkTestBase(unittest.TestCase):\n    \"\"\"Base class for network tests with common fixtures.\"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        \"\"\"Set up test networks used across multiple tests.\"\"\"\n        cls.simple_network = cls._create_simple_network()\n        cls.complex_network = cls._create_complex_network()\n\n    @staticmethod\n    def _create_simple_network():\n        \"\"\"Create simple test network.\"\"\"\n        network_def = \"\"\"\n        variable A {True, False}\n        variable B {True, False}\n\n        A { P(True) = 0.5 }\n        B | A { \n            P(True | True) = 0.8\n            P(True | False) = 0.2\n        }\n        \"\"\"\n        return parse_string(network_def)\n\n    def setUp(self):\n        \"\"\"Set up fresh instances for each test.\"\"\"\n        # Copy networks to avoid test interference\n        self.network = self._copy_network(self.simple_network)\n</code></pre>"},{"location":"developer_guide/#development-workflow","title":"Development Workflow","text":""},{"location":"developer_guide/#environment-setup","title":"Environment Setup","text":""},{"location":"developer_guide/#development-environment","title":"Development Environment","text":"<pre><code># Clone repository\ngit clone https://github.com/johan162/bayescalc2.git\ncd bayescalc2\n\n# Create virtual environment\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n\n# Install development dependencies\npip install -e \".[dev]\"\n# pip install pytest pytest-cov black flake8 mypy\n\n# Verify installation\nbayescalc examples/rain_sprinkler_grass.net --cmd \"P(Rain=True)\"\n</code></pre>"},{"location":"developer_guide/#ide-configuration","title":"IDE Configuration","text":"<p>VS Code Settings (<code>.vscode/settings.json</code>): <pre><code>{\n    \"python.defaultInterpreterPath\": \"./.venv/bin/python\",\n    \"python.testing.pytestEnabled\": true,\n    \"python.testing.pytestArgs\": [\"tests\"],\n    \"python.linting.enabled\": true,\n    \"python.linting.flake8Enabled\": true,\n    \"python.formatting.provider\": \"black\",\n    \"python.formatting.blackArgs\": [\"--line-length=100\"]\n}\n</code></pre></p>"},{"location":"developer_guide/#git-workflow","title":"Git Workflow","text":""},{"location":"developer_guide/#branch-naming-convention","title":"Branch Naming Convention","text":"<ul> <li><code>feature/feature-name</code> - New features</li> <li><code>bugfix/bug-description</code> - Bug fixes</li> <li><code>hotfix/critical-fix</code> - Critical production fixes</li> <li><code>refactor/component-name</code> - Code refactoring</li> <li><code>docs/documentation-update</code> - Documentation changes</li> </ul>"},{"location":"developer_guide/#commit-message-format","title":"Commit Message Format","text":"<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n\n&lt;body&gt;\n\n&lt;footer&gt;\n</code></pre> <p>Types: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>style</code>, <code>refactor</code>, <code>test</code>, <code>chore</code></p> <p>Examples: <pre><code>feat(inference): add variable elimination caching\n\nImplement LRU cache for variable elimination results to improve\nperformance for repeated queries on the same network.\n\n- Add @lru_cache decorator to _eliminate_variable method\n- Update tests to verify caching behavior\n- Add performance benchmark for cached vs uncached queries\n\nCloses #123\n</code></pre></p>"},{"location":"developer_guide/#code-quality-checks","title":"Code Quality Checks","text":""},{"location":"developer_guide/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Create <code>.pre-commit-config.yaml</code>: <pre><code>repos:\n  - repo: https://github.com/psf/black\n    rev: 23.7.0\n    hooks:\n      - id: black\n        args: [--line-length=100]\n\n  - repo: https://github.com/pycqa/flake8\n    rev: 6.0.0\n    hooks:\n      - id: flake8\n        args: [--max-line-length=100, --ignore=E203,W503]\n\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.5.0\n    hooks:\n      - id: mypy\n        additional_dependencies: [types-all]\n</code></pre></p>"},{"location":"developer_guide/#manual-quality-checks","title":"Manual Quality Checks","text":"<pre><code># Format code\nblack src/ tests/\n\n# Check style\nflake8 src/ tests/\n\n# Type checking\nmypy src/\n\n# Run tests with coverage\npytest --cov=bayescalc --cov-report=term-missing --cov-fail-under=90\n</code></pre>"},{"location":"developer_guide/#continuous-integration","title":"Continuous Integration","text":""},{"location":"developer_guide/#github-actions-workflow-githubworkflowstestyml","title":"GitHub Actions Workflow (<code>.github/workflows/test.yml</code>):","text":"<pre><code>name: Test Suite\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [3.10, 3.11, 3.12]\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies\n      run: |\n        pip install -e .\n        pip install pytest pytest-cov\n\n    - name: Run tests\n      run: |\n        pytest --cov=bayescalc --cov-report=xml\n\n    - name: Upload coverage\n      uses: codecov/codecov-action@v3\n      with:\n        file: ./coverage.xml\n</code></pre>"},{"location":"developer_guide/#pull-request-guidelines","title":"Pull Request Guidelines","text":""},{"location":"developer_guide/#pr-requirements-checklist","title":"PR Requirements Checklist","text":""},{"location":"developer_guide/#before-submitting","title":"Before Submitting","text":"<ul> <li> Rebase to latest develop: <code>git rebase origin/develop</code></li> <li> All tests pass: <code>pytest</code> exits with 0</li> <li> Code coverage maintained: No decrease in overall coverage</li> <li> Style checks pass: <code>black</code>, <code>flake8</code>, <code>mypy</code> all pass</li> <li> Documentation updated: User guide and docstrings updated if needed</li> <li> CHANGELOG updated: Add entry describing changes</li> </ul>"},{"location":"developer_guide/#pr-content-requirements","title":"PR Content Requirements","text":"<p>1. Comprehensive Test Coverage Every PR must include tests that cover: - Happy path: Normal operation scenarios - Edge cases: Boundary conditions and corner cases - Error conditions: Invalid inputs and error handling - Integration: How changes interact with existing code</p> <p>2. Test Coverage Examples <pre><code># For a new command implementation\nclass TestNewCommand(unittest.TestCase):\n\n    def test_normal_operation(self):\n        \"\"\"Test command works with valid inputs.\"\"\"\n        pass\n\n    def test_edge_cases(self):\n        \"\"\"Test boundary conditions.\"\"\"\n        pass\n\n    def test_error_handling(self):\n        \"\"\"Test invalid inputs raise appropriate errors.\"\"\"\n        pass\n\n    def test_integration_with_existing_commands(self):\n        \"\"\"Test new command works with existing functionality.\"\"\"\n        pass\n</code></pre></p>"},{"location":"developer_guide/#pr-description-template","title":"PR Description Template","text":"<pre><code>## Description\nBrief description of changes and motivation.\n\n## Type of Change\n- [ ] Bug fix (non-breaking change which fixes an issue)\n- [ ] New feature (non-breaking change which adds functionality)\n- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)\n- [ ] Documentation update\n- [ ] Refactoring (no functional changes)\n\n## Testing\nDescribe the testing strategy and coverage:\n\n### New Tests Added\n- List new test files/methods\n- Describe test scenarios covered\n- Note any integration tests\n\n### Test Coverage\n- Current coverage: X%\n- Coverage after changes: Y%\n- Critical paths tested: [list]\n\n## Performance Impact\n- [ ] No performance impact\n- [ ] Performance improvement (describe)\n- [ ] Potential performance regression (describe mitigation)\n\n## Documentation\n- [ ] Code comments updated\n- [ ] Docstrings updated\n- [ ] User guide updated (if user-facing changes)\n- [ ] CHANGELOG.md updated\n\n## Checklist\n- [ ] Rebased to latest develop\n- [ ] All tests pass locally\n- [ ] Code style checks pass\n- [ ] No decrease in test coverage\n- [ ] Documentation updated\n- [ ] Self-review completed\n</code></pre>"},{"location":"developer_guide/#review-process","title":"Review Process","text":""},{"location":"developer_guide/#code-review-criteria","title":"Code Review Criteria","text":"<p>Functionality - Does the code solve the intended problem? - Are all requirements addressed? - Are edge cases handled appropriately?</p> <p>Code Quality - Is the code readable and well-structured? - Are naming conventions followed? - Is the code DRY (Don't Repeat Yourself)?</p> <p>Testing - Is test coverage comprehensive? - Do tests actually validate the intended behavior? - Are tests maintainable and clear?</p> <p>Documentation - Are docstrings complete and accurate? - Is user-facing documentation updated? - Are complex algorithms explained?</p>"},{"location":"developer_guide/#required-approvals","title":"Required Approvals","text":"<ul> <li>1 Reviewer Minimum: For small changes and bug fixes</li> <li>2 Reviewers Required: For new features and breaking changes</li> <li>Maintainer Approval: Required for all changes to core inference logic</li> </ul>"},{"location":"developer_guide/#merge-requirements","title":"Merge Requirements","text":""},{"location":"developer_guide/#automated-checks-must-pass","title":"Automated Checks Must Pass","text":"<ul> <li>All CI tests pass on all supported Python versions</li> <li>Code coverage remains above threshold (90%)</li> <li>Style and type checks pass</li> <li>No security vulnerabilities detected</li> </ul>"},{"location":"developer_guide/#manual-verification","title":"Manual Verification","text":"<ul> <li>Code review approval from required reviewers</li> <li>Functional testing on example networks</li> <li>Performance regression testing (for core changes)</li> <li>Documentation review (for user-facing changes)</li> </ul>"},{"location":"developer_guide/#debugging-and-performance","title":"Debugging and Performance","text":""},{"location":"developer_guide/#debugging-strategies","title":"Debugging Strategies","text":""},{"location":"developer_guide/#logging-configuration","title":"Logging Configuration","text":"<pre><code>import logging\n\n# Configure logging for development\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('bayescalc_debug.log'),\n        logging.StreamHandler()\n    ]\n)\n\n# Use in modules\nlogger = logging.getLogger(__name__)\n\nclass VariableElimination:\n    def eliminate_variable(self, variable: str) -&gt; None:\n        logger.debug(f\"Eliminating variable: {variable}\")\n        logger.debug(f\"Current factors: {[f.name for f in self.factors]}\")\n\n        # Implementation\n\n        logger.info(f\"Successfully eliminated {variable}\")\n</code></pre>"},{"location":"developer_guide/#debug-helper-functions","title":"Debug Helper Functions","text":"<pre><code>def debug_network_state(network: BayesianNetwork) -&gt; None:\n    \"\"\"Print detailed network state for debugging.\"\"\"\n    print(f\"Network has {len(network.variables)} variables:\")\n    for var_name, var in network.variables.items():\n        print(f\"  {var_name}: {var.domain}\")\n\n    print(f\"Network has {len(network.factors)} factors:\")\n    for factor in network.factors:\n        print(f\"  {factor.name}: {len(factor.probabilities)} entries\")\n\ndef debug_probability_computation(network: BayesianNetwork, query: str) -&gt; None:\n    \"\"\"Debug probability computation step-by-step.\"\"\"\n    print(f\"Computing: {query}\")\n\n    # Parse query\n    query_obj = network.parse_query(query)\n    print(f\"Parsed query: {query_obj}\")\n\n    # Show elimination order\n    elimination_order = network.get_elimination_order(query_obj)\n    print(f\"Elimination order: {elimination_order}\")\n\n    # Step through elimination\n    for step, variable in enumerate(elimination_order):\n        print(f\"Step {step + 1}: Eliminating {variable}\")\n        # ... detailed elimination logging\n</code></pre>"},{"location":"developer_guide/#performance-optimization","title":"Performance Optimization","text":""},{"location":"developer_guide/#profiling-code","title":"Profiling Code","text":"<pre><code>import cProfile\nimport pstats\nfrom functools import wraps\n\ndef profile_function(func):\n    \"\"\"Decorator to profile function execution.\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        profiler = cProfile.Profile()\n        profiler.enable()\n        try:\n            result = func(*args, **kwargs)\n            return result\n        finally:\n            profiler.disable()\n            stats = pstats.Stats(profiler)\n            stats.sort_stats('cumulative')\n            stats.print_stats(20)  # Top 20 functions\n    return wrapper\n\n# Usage\n@profile_function\ndef compute_complex_query(network, query):\n    return network.compute_probability(query)\n</code></pre>"},{"location":"developer_guide/#performance-benchmarks","title":"Performance Benchmarks","text":"<pre><code>import time\nfrom typing import List, Tuple\n\ndef benchmark_inference(network: BayesianNetwork, queries: List[str]) -&gt; List[Tuple[str, float]]:\n    \"\"\"Benchmark inference performance on multiple queries.\"\"\"\n    results = []\n\n    for query in queries:\n        start_time = time.time()\n        try:\n            result = network.compute_probability(query)\n            end_time = time.time()\n            duration = end_time - start_time\n            results.append((query, duration))\n            print(f\"{query}: {duration:.4f}s\")\n        except Exception as e:\n            print(f\"{query}: ERROR - {e}\")\n            results.append((query, -1))\n\n    return results\n\n# Example usage\nqueries = [\n    \"P(Rain=True)\",\n    \"P(Rain=True | Sprinkler=True)\",\n    \"P(GrassWet=True | Rain=False, Sprinkler=False)\"\n]\nbenchmark_results = benchmark_inference(network, queries)\n</code></pre>"},{"location":"developer_guide/#memory-optimization","title":"Memory Optimization","text":"<pre><code>import sys\nfrom typing import Dict, Any\n\ndef analyze_memory_usage(network: BayesianNetwork) -&gt; Dict[str, Any]:\n    \"\"\"Analyze memory usage of network components.\"\"\"\n    analysis = {}\n\n    # Variable memory\n    var_sizes = {name: sys.getsizeof(var) for name, var in network.variables.items()}\n    analysis['variables'] = {\n        'count': len(network.variables),\n        'total_size': sum(var_sizes.values()),\n        'individual_sizes': var_sizes\n    }\n\n    # Factor memory\n    factor_sizes = {}\n    for factor in network.factors:\n        size = sys.getsizeof(factor.probabilities)\n        factor_sizes[factor.name] = {\n            'probability_table_size': size,\n            'entry_count': len(factor.probabilities)\n        }\n\n    analysis['factors'] = factor_sizes\n    analysis['total_estimated_size'] = (\n        analysis['variables']['total_size'] + \n        sum(f['probability_table_size'] for f in factor_sizes.values())\n    )\n\n    return analysis\n</code></pre>"},{"location":"developer_guide/#release-process","title":"Release Process","text":""},{"location":"developer_guide/#version-management","title":"Version Management","text":""},{"location":"developer_guide/#semantic-versioning","title":"Semantic Versioning","text":"<p>BayesCalc2 follows Semantic Versioning: - MAJOR: Incompatible API changes - MINOR: New functionality (backwards compatible) - PATCH: Bug fixes (backwards compatible)</p>"},{"location":"developer_guide/#release-checklist","title":"Release Checklist","text":""},{"location":"developer_guide/#pre-release","title":"Pre-Release","text":"<ul> <li> All tests pass on all supported Python versions</li> <li> Documentation is up to date</li> <li> CHANGELOG.md is updated</li> <li> Version numbers are updated consistently</li> <li> Performance benchmarks show no regressions</li> <li> Security scan passes</li> </ul>"},{"location":"developer_guide/#git-flow-and-release-strategy","title":"Git Flow and Release Strategy","text":"<p>BayesCalc2 follows a simplified Git Flow branching strategy with continuous integration principles:</p>"},{"location":"developer_guide/#branching-model-diagrams","title":"Branching Model Diagrams","text":"<p>To make the workflow clearer, here are separate diagrams for each major proces.</p> <p>1. High-Level Overview</p> <p>This diagram shows the main relationship between the <code>develop</code> and <code>main</code> branches. Features are integrated into <code>develop</code>.</p> <pre><code>main   &lt;------------------ develop\n                              ^\n                              |\n                              '---- feature/bugfix/refactor/etc.\n</code></pre> <p>2. Feature/Bugfix/Refactor Branch Workflow</p> <p>Feature/bugfix/refactor branches are for developing new features and bugfixes. They are created from <code>develop</code> and merged back into <code>develop</code>.</p> <pre><code>           (start work)\ndevelop ------------------.----------------------------------.------------&gt;\n                           \\                                / (merge PR)\n                            `---( feature/new-feature )----`\n                                (commit 1) (commit 2)\n</code></pre>"},{"location":"developer_guide/#branch-types-and-purposes","title":"Branch Types and Purposes","text":"<p><code>main</code> Branch (Production) - Purpose: Stable, production-ready code - Protection: Direct pushes forbidden, only PRs from release branches - Tags: All releases tagged here (v1.0.0, v1.1.0, etc.) - Deployments: Automatic PyPI releases triggered from tags</p> <p><code>develop</code> Branch (Integration) - Purpose: Integration branch for feature development - Source: All feature branches merge here first - Target: Release branches created from here - CI: Continuous testing on every push</p> <p>Feature Branches (<code>feature/*</code>) - Purpose: Individual feature development - Naming: <code>feature/descriptive-name</code> (e.g., <code>feature/tab-completion</code>) - Source: Branch from <code>develop</code> - Target: Merge back to <code>develop</code> via PR (or direct merge)) - Lifetime: Short-lived (days to weeks)</p> <p>Bugfix Branches (<code>bugfix/*</code>) - Purpose: Individual bugfix development - Naming: <code>bugfix/bug-description</code> (e.g., <code>bugfix/missing-option-check</code>) - Source: Branch from <code>develop</code> - Target: Merge back to <code>develop</code> via PR (or direct merge) - Lifetime: Short-lived (days to weeks)</p>"},{"location":"developer_guide/#standard-release-process","title":"Standard Release Process","text":"<p>Simplified Direct Release - Stringent quality controls with streamlined workflow.</p> <p>Prerequisites: - All planned features merged to <code>develop</code> branch - No known critical bugs - Documentation updated for new features - All tests passing on latest <code>develop</code> by passing the build script <code>scripts/mkbld.sh</code></p> <p>Release Scripts </p> <p>The release process is a two-step stage process</p>"},{"location":"developer_guide/#release-step-1-createing-a-release-tag","title":"Release step 1: Createing a release tag","text":"<p>Running the git release script  <code>scripts/mkrelease.sh</code> while on the <code>develop</code> branch.    This will merge back and squash all changes on develop to main, tag the release, and finally    merge back changes from main onto develop. </p> <p>Usage: </p> <p><code>./scripts/mkrelease.sh &lt;version&gt; [major|minor|patch] [--dry-run] [--help]</code></p> <pre><code>$ ./scripts/mkrelease.sh 2.1.0 minor\n$ ./scripts/mkrelease.sh 2.1.0 minor --dry-run\n$ ./scripts/mkrelease.sh --help\n</code></pre> <p>Quality Gates Enforced: - \u2705 80%+ test coverage requirement - \u2705 All example networks must load and execute - \u2705 CLI and REPL functionality validation - \u2705 Package building and validation via twine - \u2705 Static analysis and code formatting checks - \u2705 Integration testing with real network files - \u2705 Version consistency across all files - \u2705 Clean repository state required - \u2705 Semver compliance validation - \u2705 Duplicate version prevention</p>"},{"location":"developer_guide/#release-step-2-creating-a-github-release","title":"Release step 2: Creating a GitHub Release","text":"<p>After a succesful run of the git/branch release script it is time to create the GitHub release. using the script <code>scripts/mkghrelease.sh</code>. This will use the latest tag created and name a new release with this name. The GitHub release will be made with an updated release note and the latest artifacts. Due to the CI/CD workflow this will also trigger a release to be pushed to PyPI with the given version number.</p> <p>Usage:</p> <p><code>./scripts/mkghrelease.sh [--dry-run] [--help] [--pre-release]</code></p> <pre><code>$ ./scripts/mkghrelease.sh\n$ ./scripts/mkghrelease.sh --dry-run\n$ ./scripts/mkghrelease.sh --help\n$ ./scripts/mkghrelease.sh --pre-release\n</code></pre> <p>Quality Gates Enforced: - \u2705 Authenticated That the user is authenticated to use <code>gh</code> - \u2705 Running workflows Checks that no workflows are currently running - \u2705 Auto-naming Identifies the latest tag on main branch - \u2705 Tag validation Validates tag format (vX.Y.Z or vX.Y.Z-rcN) - \u2705 Artifact validation Validates artifacts in dist/ directory - \u2705 Release creation Creates GitHub release with artifacts and release notes</p>"},{"location":"developer_guide/#post-release","title":"Post-Release","text":""},{"location":"developer_guide/#verification","title":"Verification","text":"<ul> <li> PyPI package installs correctly</li> <li> Documentation site updated</li> <li> GitHub release created with notes</li> <li> Announcement posted (if major release)</li> </ul>"},{"location":"developer_guide/#monitoring","title":"Monitoring","text":"<ul> <li>Monitor for bug reports</li> <li>Track download statistics</li> <li>Gather user feedback</li> <li>Plan next release cycle</li> </ul>"},{"location":"developer_guide/#appendix-a-variable-elimination-algorithm-detailed-implementation-guide","title":"Appendix A: Variable Elimination Algorithm - Detailed Implementation Guide","text":"<p>This appendix provides a comprehensive, step-by-step explanation of the Variable Elimination algorithm as implemented in BayesCalc2, complete with worked examples and implementation details.</p>"},{"location":"developer_guide/#algorithm-overview","title":"Algorithm Overview","text":"<p>Variable Elimination is an exact inference algorithm for Bayesian networks that computes marginal and conditional probabilities by systematically eliminating variables through factor operations. The algorithm transforms a complex joint probability computation into a sequence of simpler factor manipulations.</p>"},{"location":"developer_guide/#core-concept","title":"Core Concept","text":"<p>Instead of computing the full joint probability table (which grows exponentially), Variable Elimination works with factors - smaller probability tables that are combined and reduced as needed. This approach is much more efficient for most practical networks.</p>"},{"location":"developer_guide/#mathematical-foundation","title":"Mathematical Foundation","text":"<p>For a Bayesian network with variables X\u2081, X\u2082, ..., X\u2099, the joint probability factors as:</p> <p>P(X\u2081, X\u2082, ..., X\u2099) = \u220f\u1d62 P(X\u1d62 | Parents(X\u1d62))</p> <p>To compute a conditional probability P(Q | E) where Q are query variables and E is evidence:</p> <p>P(Q | E) = P(Q, E) / P(E) = \u2211{hidden} \u220f\u1d62 P(X\u1d62 | Parents(X\u1d62)) / \u2211_Q \u2211 \u220f\u1d62 P(X\u1d62 | Parents(X\u1d62))</p> <p>Variable elimination computes this efficiently by eliminating hidden variables in a strategic order.</p>"},{"location":"developer_guide/#step-by-step-algorithm","title":"Step-by-Step Algorithm","text":""},{"location":"developer_guide/#phase-1-network-preparation","title":"Phase 1: Network Preparation","text":"<p>Input: Query variables Q, Evidence E, Bayesian Network BN Output: Conditional probability distribution P(Q | E)</p> <ol> <li>Extract Factors: Convert CPTs to Factor objects</li> <li>Apply Evidence: Reduce factors by incorporating observed values</li> <li>Identify Variables: Determine which variables need elimination</li> <li>Order Selection: Choose elimination order (affects efficiency)</li> </ol>"},{"location":"developer_guide/#phase-2-variable-elimination-loop","title":"Phase 2: Variable Elimination Loop","text":"<p>For each variable X to eliminate: 1. Collect Factors: Find all factors containing X 2. Join Factors: Multiply factors together 3. Marginalize: Sum out X from the joined factor 4. Replace: Substitute new factor for old ones</p>"},{"location":"developer_guide/#phase-3-final-computation","title":"Phase 3: Final Computation","text":"<ol> <li>Join Remaining: Multiply all remaining factors</li> <li>Normalize: Convert to conditional probabilities</li> </ol>"},{"location":"developer_guide/#detailed-example-rain-sprinkler-grasswet-network","title":"Detailed Example: Rain-Sprinkler-GrassWet Network","text":"<p>Let's work through computing P(Rain | GrassWet=True) step by step.</p>"},{"location":"developer_guide/#network-definition","title":"Network Definition","text":"<pre><code>Variables:\n- Rain \u2208 {True, False}\n- Sprinkler \u2208 {True, False}  \n- GrassWet \u2208 {True, False}\n\nStructure:\nRain \u2192 Sprinkler\nRain \u2192 GrassWet\nSprinkler \u2192 GrassWet\n\nCPTs:\nP(Rain=True) = 0.2\nP(Rain=False) = 0.8\n\nP(Sprinkler=True | Rain=True) = 0.01\nP(Sprinkler=True | Rain=False) = 0.4\nP(Sprinkler=False | Rain=True) = 0.99\nP(Sprinkler=False | Rain=False) = 0.6\n\nP(GrassWet=True | Rain=True, Sprinkler=True) = 0.99\nP(GrassWet=True | Rain=True, Sprinkler=False) = 0.8\nP(GrassWet=True | Rain=False, Sprinkler=True) = 0.9\nP(GrassWet=True | Rain=False, Sprinkler=False) = 0.1\nP(GrassWet=False | Rain=True, Sprinkler=True) = 0.01\nP(GrassWet=False | Rain=True, Sprinkler=False) = 0.2\nP(GrassWet=False | Rain=False, Sprinkler=True) = 0.1\nP(GrassWet=False | Rain=False, Sprinkler=False) = 0.9\n</code></pre>"},{"location":"developer_guide/#phase-1-preparation","title":"Phase 1: Preparation","text":"<p>Step 1.1: Extract Initial Factors</p> <pre><code>Factor\u2081: \u03c6\u2081(Rain)\nVariables: [Rain]\nProbabilities: {\n    (True,): 0.2,\n    (False,): 0.8\n}\n\nFactor\u2082: \u03c6\u2082(Sprinkler, Rain)\nVariables: [Sprinkler, Rain]\nProbabilities: {\n    (True, True): 0.01,\n    (True, False): 0.4,\n    (False, True): 0.99,\n    (False, False): 0.6\n}\n\nFactor\u2083: \u03c6\u2083(GrassWet, Rain, Sprinkler)\nVariables: [GrassWet, Rain, Sprinkler]\nProbabilities: {\n    (True, True, True): 0.99,\n    (True, True, False): 0.8,\n    (True, False, True): 0.9,\n    (True, False, False): 0.1,\n    (False, True, True): 0.01,\n    (False, True, False): 0.2,\n    (False, False, True): 0.1,\n    (False, False, False): 0.9\n}\n</code></pre> <p>Step 1.2: Apply Evidence (GrassWet=True)</p> <p>We reduce Factor\u2083 by eliminating rows where GrassWet \u2260 True:</p> <pre><code>Factor\u2083': \u03c6\u2083'(Rain, Sprinkler)  # GrassWet eliminated by evidence\nVariables: [Rain, Sprinkler]\nProbabilities: {\n    (True, True): 0.99,     # was (True, True, True)\n    (True, False): 0.8,     # was (True, True, False)\n    (False, True): 0.9,     # was (True, False, True)\n    (False, False): 0.1     # was (True, False, False)\n}\n</code></pre> <p>Step 1.3: Identify Variables to Eliminate</p> <ul> <li>Query variables: {Rain}</li> <li>Evidence variables: {GrassWet}</li> <li>Variables to eliminate: {Sprinkler}</li> </ul>"},{"location":"developer_guide/#phase-2-variable-elimination","title":"Phase 2: Variable Elimination","text":"<p>Step 2.1: Eliminate Sprinkler</p> <p>Collect factors containing Sprinkler: - Factor\u2082: \u03c6\u2082(Sprinkler, Rain) - Factor\u2083': \u03c6\u2083'(Rain, Sprinkler)</p> <p>Join Factor\u2082 and Factor\u2083':</p> <p>The join operation multiplies factors. For each combination of Rain and Sprinkler values:</p> <pre><code># Join: \u03c6\u2084(Rain, Sprinkler) = \u03c6\u2082(Sprinkler, Rain) \u00d7 \u03c6\u2083'(Rain, Sprinkler)\n\n\u03c6\u2084(True, True) = \u03c6\u2082(True, True) \u00d7 \u03c6\u2083'(True, True)\n                = 0.01 \u00d7 0.99 = 0.0099\n\n\u03c6\u2084(True, False) = \u03c6\u2082(False, True) \u00d7 \u03c6\u2083'(True, False)  \n                 = 0.99 \u00d7 0.8 = 0.792\n\n\u03c6\u2084(False, True) = \u03c6\u2082(True, False) \u00d7 \u03c6\u2083'(False, True)\n                 = 0.4 \u00d7 0.9 = 0.36\n\n\u03c6\u2084(False, False) = \u03c6\u2082(False, False) \u00d7 \u03c6\u2083'(False, False)\n                  = 0.6 \u00d7 0.1 = 0.06\n\nFactor\u2084: \u03c6\u2084(Rain, Sprinkler)\nVariables: [Rain, Sprinkler]\nProbabilities: {\n    (True, True): 0.0099,\n    (True, False): 0.792,\n    (False, True): 0.36,\n    (False, False): 0.06\n}\n</code></pre> <p>Sum out Sprinkler from Factor\u2084:</p> <p>The marginalization operation sums over all values of the eliminated variable:</p> <pre><code># Marginalize: \u03c6\u2085(Rain) = \u2211_{Sprinkler} \u03c6\u2084(Rain, Sprinkler)\n\n\u03c6\u2085(True) = \u03c6\u2084(True, True) + \u03c6\u2084(True, False)\n         = 0.0099 + 0.792 = 0.8019\n\n\u03c6\u2085(False) = \u03c6\u2084(False, True) + \u03c6\u2084(False, False)\n          = 0.36 + 0.06 = 0.42\n\nFactor\u2085: \u03c6\u2085(Rain)\nVariables: [Rain]\nProbabilities: {\n    (True,): 0.8019,\n    (False,): 0.42\n}\n</code></pre>"},{"location":"developer_guide/#phase-3-final-computation_1","title":"Phase 3: Final Computation","text":"<p>Step 3.1: Join Remaining Factors</p> <p>Remaining factors: Factor\u2081 (\u03c6\u2081(Rain)) and Factor\u2085 (\u03c6\u2085(Rain))</p> <pre><code># Join: \u03c6\u2086(Rain) = \u03c6\u2081(Rain) \u00d7 \u03c6\u2085(Rain)\n\n\u03c6\u2086(True) = \u03c6\u2081(True) \u00d7 \u03c6\u2085(True) = 0.2 \u00d7 0.8019 = 0.16038\n\u03c6\u2086(False) = \u03c6\u2081(False) \u00d7 \u03c6\u2085(False) = 0.8 \u00d7 0.42 = 0.336\n\nFactor\u2086: \u03c6\u2086(Rain)  # Unnormalized\nVariables: [Rain]\nProbabilities: {\n    (True,): 0.16038,\n    (False,): 0.336\n}\n</code></pre> <p>Step 3.2: Normalize</p> <pre><code># Normalization: Convert to conditional probabilities\ntotal = 0.16038 + 0.336 = 0.49638\n\nP(Rain=True | GrassWet=True) = 0.16038 / 0.49638 \u2248 0.323\nP(Rain=False | GrassWet=True) = 0.336 / 0.49638 \u2248 0.677\n</code></pre>"},{"location":"developer_guide/#final-result","title":"Final Result","text":"<p>P(Rain | GrassWet=True) = {True: 0.323, False: 0.677}</p> <p>This means that given the grass is wet, there's approximately a 32.3% chance it rained and a 67.7% chance it didn't rain.</p>"},{"location":"developer_guide/#implementation-details","title":"Implementation Details","text":""},{"location":"developer_guide/#factor-data-structure","title":"Factor Data Structure","text":"<pre><code>@dataclass\nclass Factor:\n    variables: Tuple[Variable, ...]\n    probabilities: Dict[Tuple[str, ...], float] = field(default_factory=dict)\n\n    def __post_init__(self):\n        # Ensure probabilities are normalized for each parent configuration\n        self._validate_probabilities()\n</code></pre>"},{"location":"developer_guide/#join-operation-implementation","title":"Join Operation Implementation","text":"<pre><code>def _join_factors(self, factor1: Factor, factor2: Factor) -&gt; Factor:\n    \"\"\"Join two factors by multiplication.\"\"\"\n    # Union of variables\n    vars1 = set(factor1.variables)\n    vars2 = set(factor2.variables)\n    new_vars = tuple(vars1.union(vars2))\n\n    # Create mapping from new variable order to old orders\n    map1 = [new_vars.index(v) for v in factor1.variables]\n    map2 = [new_vars.index(v) for v in factor2.variables]\n\n    new_factor = Factor(new_vars)\n\n    # Generate all possible assignments to new variables\n    domains = [v.domain for v in new_vars]\n    for assignment in product(*domains):\n        # Extract sub-assignments for each original factor\n        ass1 = tuple(assignment[i] for i in map1)\n        ass2 = tuple(assignment[i] for i in map2)\n\n        # Multiply probabilities (default to 1.0 if not present)\n        prob1 = factor1.probabilities.get(ass1, 1.0)\n        prob2 = factor2.probabilities.get(ass2, 1.0)\n        new_factor.probabilities[assignment] = prob1 * prob2\n\n    return new_factor\n</code></pre>"},{"location":"developer_guide/#marginalization-implementation","title":"Marginalization Implementation","text":"<pre><code>def _sum_out(self, factor: Factor, var_to_eliminate: Variable) -&gt; Factor:\n    \"\"\"Sum out (marginalize) a variable from a factor.\"\"\"\n    if var_to_eliminate not in factor.variables:\n        return factor\n\n    # New variables exclude the eliminated variable\n    var_index = list(factor.variables).index(var_to_eliminate)\n    new_vars = tuple(v for v in factor.variables if v != var_to_eliminate)\n\n    new_factor = Factor(new_vars)\n\n    # Sum over all values of the eliminated variable\n    for old_assignment, prob in factor.probabilities.items():\n        # Create new assignment by removing the eliminated variable's value\n        new_assignment = tuple(\n            old_assignment[i] for i in range(len(old_assignment)) \n            if i != var_index\n        )\n\n        # Accumulate probability\n        current_prob = new_factor.probabilities.get(new_assignment, 0.0)\n        new_factor.probabilities[new_assignment] = current_prob + prob\n\n    return new_factor\n</code></pre>"},{"location":"developer_guide/#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"developer_guide/#elimination-order-selection","title":"Elimination Order Selection","text":"<p>The order in which variables are eliminated significantly affects performance. BayesCalc2 uses a simple heuristic:</p> <pre><code>def _select_elimination_order(self, variables_to_eliminate: Set[str]) -&gt; List[str]:\n    \"\"\"Select elimination order using min-fill heuristic.\"\"\"\n    return sorted(\n        variables_to_eliminate,\n        key=lambda var: sum(1 for f in self.factors if var in f.variable_names)\n    )\n</code></pre> <p>Better heuristics (for future implementation): - Min-fill: Choose variable that adds fewest edges to moral graph - Min-width: Choose variable that results in smallest factor size - Weighted min-fill: Consider both factor size and number of factors</p>"},{"location":"developer_guide/#complexity-analysis","title":"Complexity Analysis","text":"<p>Time Complexity: O(n \u00d7 d^w) where: - n = number of variables - d = maximum domain size - w = treewidth of elimination order</p> <p>Space Complexity: O(d^s) where s = size of largest intermediate factor</p> <p>Practical Considerations: - Networks with tree structure: polynomial time - Networks with cycles: potentially exponential - Good elimination order crucial for performance</p>"},{"location":"developer_guide/#common-implementation-pitfalls","title":"Common Implementation Pitfalls","text":""},{"location":"developer_guide/#1-factor-alignment-issues","title":"1. Factor Alignment Issues","text":"<p>Problem: Variables in different orders between factors <pre><code># Wrong - assumes same variable order\nfactor1_vars = [A, B]  \nfactor2_vars = [B, A]  # Different order!\nresult = factor1.prob[0] * factor2.prob[0]  # Incorrect alignment\n</code></pre></p> <p>Solution: Use variable mapping <pre><code># Correct - map variables properly\nmap1 = [new_vars.index(v) for v in factor1.variables]\nmap2 = [new_vars.index(v) for v in factor2.variables]\n</code></pre></p>"},{"location":"developer_guide/#2-evidence-handling-errors","title":"2. Evidence Handling Errors","text":"<p>Problem: Not properly reducing factors with evidence <pre><code># Wrong - evidence not applied consistently\nif var_name in evidence and assignment[var_idx] != evidence[var_name]:\n    continue  # Skip inconsistent assignments\n</code></pre></p> <p>Solution: Normalize evidence values consistently <pre><code># Correct - handle T/F vs True/False\ndef normalize_value(value):\n    if value in [\"T\", \"True\"]: return \"True\"\n    if value in [\"F\", \"False\"]: return \"False\"  \n    return value\n</code></pre></p>"},{"location":"developer_guide/#3-numerical-precision-issues","title":"3. Numerical Precision Issues","text":"<p>Problem: Floating point errors accumulate <pre><code># May have precision issues\nif total_probability == 1.0:  # Exact comparison problematic\n</code></pre></p> <p>Solution: Use appropriate tolerances <pre><code># Better - use epsilon for comparisons\nif abs(total_probability - 1.0) &lt; 1e-9:\n</code></pre></p>"},{"location":"developer_guide/#testing-variable-elimination","title":"Testing Variable Elimination","text":""},{"location":"developer_guide/#unit-test-structure","title":"Unit Test Structure","text":"<pre><code>def test_variable_elimination_step_by_step(self):\n    \"\"\"Test each step of variable elimination.\"\"\"\n    # Setup\n    network = self.create_rain_sprinkler_network()\n    inference = Inference(network)\n\n    # Test factor extraction\n    factors = inference._extract_factors()\n    self.assertEqual(len(factors), 3)\n\n    # Test evidence reduction  \n    evidence = {\"GrassWet\": \"True\"}\n    reduced_factors = inference._apply_evidence(factors, evidence)\n\n    # Verify evidence was applied correctly\n    grass_factor = next(f for f in reduced_factors if \"GrassWet\" in f.variable_names)\n    self.assertTrue(all(\"True\" in str(assignment) for assignment in grass_factor.probabilities.keys()))\n\n    # Test variable elimination\n    result = inference.variable_elimination([\"Rain\"], evidence)\n\n    # Verify normalization\n    total_prob = sum(result.probabilities.values())\n    self.assertAlmostEqual(total_prob, 1.0, places=6)\n</code></pre>"},{"location":"developer_guide/#integration-tests","title":"Integration Tests","text":"<pre><code>def test_inference_against_hand_calculation(self):\n    \"\"\"Verify inference results match hand calculations.\"\"\"\n    known_results = {\n        \"P(Rain=True | GrassWet=True)\": 0.323,\n        \"P(Rain=False | GrassWet=True)\": 0.677,\n        \"P(Sprinkler=True | GrassWet=True)\": 0.429,\n        \"P(Sprinkler=False | GrassWet=True)\": 0.571\n    }\n\n    for query, expected in known_results.items():\n        result = self.inference.compute_probability(query)\n        self.assertAlmostEqual(result, expected, places=3, \n                             msg=f\"Failed for query: {query}\")\n</code></pre> <p>This detailed implementation guide provides everything needed to understand, modify, and extend the Variable Elimination algorithm in BayesCalc2. The step-by-step example demonstrates the algorithm's mechanics, while the implementation details show how theory translates to working code.</p>"},{"location":"developer_guide/#appendix-b-github-release-script-documentation","title":"APPENDIX B: GitHub Release Script Documentation","text":""},{"location":"developer_guide/#overview","title":"Overview","text":"<p><code>mkghrelease.sh</code> automates GitHub release creation using the <code>gh</code> CLI tool. It's designed to be run after <code>mkrelease.sh</code> completes and all GitHub Actions workflows pass.</p>"},{"location":"developer_guide/#installation-prerequisites","title":"Installation Prerequisites","text":""},{"location":"developer_guide/#install-github-cli","title":"Install GitHub CLI","text":"<pre><code># macOS\nbrew install gh\n\n# Ubuntu/Debian\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-key C99B11DEB97541F0\nsudo apt-add-repository https://cli.github.com/packages\nsudo apt update\nsudo apt install gh\n\n# Fedora\nsudo dnf install gh\n\n# Windows\nwinget install --id GitHub.cli\n</code></pre>"},{"location":"developer_guide/#authenticate-with-github","title":"Authenticate with GitHub","text":"<pre><code># Interactive authentication\ngh auth login\n\n# Select: GitHub.com\n# Select: HTTPS\n# Authenticate with: Login with a web browser\n# Follow the prompts\n</code></pre>"},{"location":"developer_guide/#verify-installation","title":"Verify Installation","text":"<pre><code>gh --version\n# Should show: gh version 2.0.0 or higher\n\ngh auth status\n# Should show: Logged in to github.com as &lt;username&gt;\n</code></pre>"},{"location":"developer_guide/#usage","title":"Usage","text":""},{"location":"developer_guide/#basic-release-creation","title":"Basic Release Creation","text":"<pre><code># After mkrelease.sh completes:\n./scripts/mkghrelease.sh\n</code></pre> <p>This will: 1. Check prerequisites 2. Verify no workflows are running 3. Extract release notes from CHANGELOG.md 4. Open editor for you to review/edit notes 5. Create GitHub release with artifacts 6. Upload wheel and sdist files</p>"},{"location":"developer_guide/#pre-release-creation","title":"Pre-release Creation","text":"<pre><code># For release candidates (auto-detected from tag):\n./scripts/mkghrelease.sh\n# Tag v1.0.0-rc1 \u2192 automatically marked as pre-release\n\n# Force pre-release regardless of tag:\n./scripts/mkghrelease.sh --pre-release\n</code></pre>"},{"location":"developer_guide/#dry-run-preview","title":"Dry Run (Preview)","text":"<pre><code># See what would be done without executing:\n./scripts/mkghrelease.sh --dry-run\n</code></pre>"},{"location":"developer_guide/#complete-workflow-example","title":"Complete Workflow Example","text":"<pre><code># Step 1: Create release on local/GitHub\n./scripts/mkrelease.sh v1.0.0 major\n\n# Step 2: Wait for CI to complete\ngh run list --branch main\n# Or watch in real-time:\ngh run watch\n\n# Step 3: Verify CI passed\ngh run list --branch main --limit 1\n\n# Step 4: Create GitHub release\n./scripts/mkghrelease.sh\n\n# Step 5: Verify release\ngh release view v1.0.0\n# Or visit: https://github.com/johan162/bayescalc2/releases/tag/v1.0.0\n</code></pre>"},{"location":"developer_guide/#release-notes-editing","title":"Release Notes Editing","text":"<p>The script extracts release notes from CHANGELOG.md and opens your editor:</p>"},{"location":"developer_guide/#default-editor-priority","title":"Default Editor Priority","text":"<ol> <li><code>$EDITOR</code> environment variable</li> <li><code>$VISUAL</code> environment variable</li> <li><code>nano</code> (fallback)</li> </ol>"},{"location":"developer_guide/#set-your-preferred-editor","title":"Set Your Preferred Editor","text":"<pre><code># In ~/.bashrc or ~/.zshrc\nexport EDITOR=vim\n# or\nexport EDITOR=code  # VS Code\n# or\nexport EDITOR=nano\n</code></pre>"},{"location":"developer_guide/#release-notes-format","title":"Release Notes Format","text":"<p>The script extracts the section matching your tag from CHANGELOG.md:</p> <pre><code>## [v1.0.0] - 2025-10-10\n\n### \ud83d\udccb Summary\nMajor refactor with new inference algorithm...\n\n### \u2728 Additions\n- New load() command\n- Graph visualization\n\n### \ud83d\ude80 Improvements\n- Faster inference engine\n- Better error messages\n</code></pre> <p>You can edit this before the release is created.</p>"},{"location":"developer_guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"developer_guide/#error-gh-is-not-installed","title":"Error: \"gh is not installed\"","text":"<pre><code># Install gh CLI (see Installation Prerequisites above)\nbrew install gh  # macOS\n</code></pre>"},{"location":"developer_guide/#error-not-authenticated-with-github","title":"Error: \"Not authenticated with GitHub\"","text":"<pre><code>gh auth login\n# Follow the prompts\n</code></pre>"},{"location":"developer_guide/#error-there-are-n-workflows-currently-running","title":"Error: \"There are N workflow(s) currently running\"","text":"<pre><code># Wait for workflows to complete\ngh run list --branch main\n\n# Watch in real-time\ngh run watch\n</code></pre>"},{"location":"developer_guide/#error-latest-workflow-did-not-succeed","title":"Error: \"Latest workflow did not succeed\"","text":"<pre><code># Check workflow status\ngh run list --branch main --limit 5\n\n# View specific run details\ngh run view &lt;run-id&gt;\n\n# Fix the issue and re-run workflows\n</code></pre>"},{"location":"developer_guide/#error-release-v100-already-exists","title":"Error: \"Release v1.0.0 already exists\"","text":"<pre><code># Option 1: Delete and recreate\ngh release delete v1.0.0\n./scripts/mkghrelease.sh\n\n# Option 2: Create new version\n./scripts/mkrelease.sh v1.0.1 patch\n./scripts/mkghrelease.sh\n</code></pre>"},{"location":"developer_guide/#error-wheel-file-not-found-for-version-xyz","title":"Error: \"Wheel file not found for version X.Y.Z\"","text":"<pre><code># Rebuild the package\n./scripts/mkbld.sh\n\n# Or re-run release script\n./scripts/mkrelease.sh v1.0.0 major\n</code></pre>"},{"location":"developer_guide/#error-must-be-on-main-branch","title":"Error: \"Must be on 'main' branch\"","text":"<pre><code>git checkout main\ngit pull origin main\n./scripts/mkghrelease.sh\n</code></pre>"},{"location":"developer_guide/#pre-release-vs-stable-release","title":"Pre-release vs Stable Release","text":""},{"location":"developer_guide/#automatic-detection","title":"Automatic Detection","text":"<p>The script automatically determines release type:</p> Tag Format Release Type Example <code>vX.Y.Z-rcN</code> Pre-release <code>v1.0.0-rc1</code>, <code>v2.1.0-rc5</code> <code>vX.Y.Z</code> Stable <code>v1.0.0</code>, <code>v2.1.0</code>"},{"location":"developer_guide/#force-pre-release","title":"Force Pre-release","text":"<pre><code># Override automatic detection\n./scripts/mkghrelease.sh --pre-release\n# Even v1.0.0 will be marked as pre-release\n</code></pre>"},{"location":"developer_guide/#artifacts-uploaded","title":"Artifacts Uploaded","text":"<p>For each release, the script uploads:</p> <ol> <li>Wheel file: <code>bayescalc2-X.Y.Z-py3-none-any.whl</code></li> <li>Binary distribution</li> <li>Fast installation</li> <li> <p>Platform independent</p> </li> <li> <p>Source distribution: <code>bayescalc2-X.Y.Z.tar.gz</code></p> </li> <li>Complete source code</li> <li>Includes all files from MANIFEST.in</li> <li>For building from source</li> </ol> <p>Both files are validated for: - Correct version number in filename - Minimum file size (&gt; 1KB) - Existence in <code>dist/</code> directory</p>"},{"location":"developer_guide/#integration-with-pypi","title":"Integration with PyPI","text":"<p>After creating GitHub release, optionally upload to PyPI:</p> <pre><code># Test PyPI first (recommended)\npython -m twine upload --repository testpypi dist/*\n\n# Production PyPI\npython -m twine upload dist/*\n</code></pre>"},{"location":"developer_guide/#script-exit-codes","title":"Script Exit Codes","text":"<ul> <li><code>0</code> - Success</li> <li><code>1</code> - Error (validation failed, prerequisites not met, etc.)</li> <li><code>130</code> - User aborted (Ctrl+C or empty release notes)</li> </ul>"},{"location":"developer_guide/#environment-variables","title":"Environment Variables","text":"<p>None required. The script uses: - <code>$EDITOR</code> or <code>$VISUAL</code> - For editing release notes - Git repository context (branch, tags, etc.)</p>"},{"location":"developer_guide/#files-createdmodified","title":"Files Created/Modified","text":""},{"location":"developer_guide/#temporary-files","title":"Temporary Files","text":"<ul> <li><code>.github_release_notes.tmp</code> - Extracted release notes (deleted after use)</li> </ul>"},{"location":"developer_guide/#no-permanent-changes","title":"No Permanent Changes","text":"<p>The script does NOT modify: - Git repository (no commits, tags, or branch changes) - Source code - CHANGELOG.md - Version files</p> <p>All changes should be done via <code>mkrelease.sh</code> before running this script.</p>"},{"location":"developer_guide/#security-considerations","title":"Security Considerations","text":"<ul> <li>Requires GitHub authentication via <code>gh auth</code></li> <li>Uses existing git tags (no new tags created)</li> <li>Only uploads files from <code>dist/</code> directory</li> <li>Validates artifact names match tag version</li> </ul>"},{"location":"developer_guide/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always run mkrelease.sh first <pre><code>./scripts/mkrelease.sh v1.0.0 major\n</code></pre></p> </li> <li> <p>Wait for CI to complete <pre><code>gh run watch\n</code></pre></p> </li> <li> <p>Review artifacts before release <pre><code>ls -lh dist/\n</code></pre></p> </li> <li> <p>Use dry-run for first-time releases <pre><code>./scripts/mkghrelease.sh --dry-run\n</code></pre></p> </li> <li> <p>Keep CHANGELOG.md updated</p> </li> <li>Script extracts notes from here</li> <li>Better notes = better release documentation</li> </ol>"},{"location":"developer_guide/#see-also","title":"See Also","text":"<ul> <li>../scripts/mkrelease.sh - Create the release (run first)</li> <li>../scripts/mkbld.sh - Build and test the package</li> <li>../scripts/README.md - Complete scripts documentation</li> <li>GitHub CLI documentation</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This page provides detailed examples of using BayesCalc2 for various probabilistic reasoning tasks.</p>"},{"location":"examples/#medical-diagnosis","title":"Medical Diagnosis","text":"<p>The medical diagnosis network demonstrates Bayesian reasoning about diseases and test results.</p>"},{"location":"examples/#network-definition-medical_testnet","title":"Network Definition (<code>medical_test.net</code>)","text":"<pre><code>variable Disease {Present, Absent}\nvariable TestResult {Positive, Negative}\nvariable Symptom {Severe, Mild, None}\n\nDisease { P(Present) = 0.01 }\n\nSymptom | Disease {\n    P(Severe | Present) = 0.6\n    P(Mild | Present) = 0.3\n    P(None | Present) = 0.1\n    P(Severe | Absent) = 0.01\n    P(Mild | Absent) = 0.09\n    P(None | Absent) = 0.9\n}\n\nTestResult | Disease {\n    P(Positive | Present) = 0.95\n    P(Negative | Present) = 0.05\n    P(Positive | Absent) = 0.10\n    P(Negative | Absent) = 0.90\n}\n</code></pre>"},{"location":"examples/#example-queries","title":"Example Queries","text":"<p>Prior probability of disease: <pre><code>BayesCalc&gt; P(Disease=Present)\nP(Disease=Present) = 0.0100\n</code></pre></p> <p>Probability with positive test: <pre><code>BayesCalc&gt; P(Disease=Present|TestResult=Positive)\nP(Disease=Present | TestResult=Positive) = 0.0876\n</code></pre></p> <p>Probability with symptoms and positive test: <pre><code>BayesCalc&gt; P(Disease=Present|TestResult=Positive, Symptom=Severe)\nP(Disease=Present | TestResult=Positive, Symptom=Severe) = 0.8632\n</code></pre></p>"},{"location":"examples/#insights","title":"Insights","text":"<ul> <li>A positive test alone only raises disease probability to ~9% (from 1% prior)</li> <li>Combining positive test with severe symptoms raises probability to ~86%</li> <li>This demonstrates the importance of multiple evidence sources</li> </ul>"},{"location":"examples/#weather-prediction","title":"Weather Prediction","text":"<p>A classic Bayesian network example showing how rain and sprinklers affect grass wetness.</p>"},{"location":"examples/#network-definition-rain_sprinkler_grassnet","title":"Network Definition (<code>rain_sprinkler_grass.net</code>)","text":"<pre><code>variable Rain {True, False}\nvariable Sprinkler {On, Off}\nvariable GrassWet {Yes, No}\n\nRain { P(True) = 0.2 }\n\nSprinkler | Rain {\n    P(On | True) = 0.01\n    P(On | False) = 0.4\n}\n\nGrassWet | Rain, Sprinkler {\n    P(Yes | True, On) = 0.99\n    P(Yes | True, Off) = 0.90\n    P(Yes | False, On) = 0.85\n    P(Yes | False, Off) = 0.05\n}\n</code></pre>"},{"location":"examples/#example-queries_1","title":"Example Queries","text":"<p>Explaining away phenomenon: <pre><code>BayesCalc&gt; P(Rain|GrassWet=Yes)\nP(Rain=True | GrassWet=Yes) = 0.6203\n\nBayesCalc&gt; P(Rain|GrassWet=Yes, Sprinkler=On)\nP(Rain=True | GrassWet=Yes, Sprinkler=On) = 0.2686\n</code></pre></p> <p>Learning the sprinkler was on \"explains away\" some of the evidence for rain.</p>"},{"location":"examples/#student-network","title":"Student Network","text":"<p>Models student exam performance based on intelligence and exam difficulty.</p>"},{"location":"examples/#network-definition-student_networknet","title":"Network Definition (<code>student_network.net</code>)","text":"<pre><code>variable Intelligence {High, Medium, Low}\nvariable Difficulty {Hard, Easy}\nvariable Grade {A, B, C}\n\nIntelligence {\n    P(High) = 0.3\n    P(Medium) = 0.5\n    P(Low) = 0.2\n}\n\nDifficulty { P(Hard) = 0.4 }\n\nGrade | Intelligence, Difficulty {\n    P(A | High, Hard) = 0.6\n    P(B | High, Hard) = 0.3\n    P(C | High, Hard) = 0.1\n\n    P(A | High, Easy) = 0.9\n    P(B | High, Easy) = 0.08\n    P(C | High, Easy) = 0.02\n\n    P(A | Medium, Hard) = 0.2\n    P(B | Medium, Hard) = 0.5\n    P(C | Medium, Hard) = 0.3\n\n    P(A | Medium, Easy) = 0.5\n    P(B | Medium, Easy) = 0.4\n    P(C | Medium, Easy) = 0.1\n\n    P(A | Low, Hard) = 0.05\n    P(B | Low, Hard) = 0.25\n    P(C | Low, Hard) = 0.7\n\n    P(A | Low, Easy) = 0.2\n    P(B | Low, Easy) = 0.4\n    P(C | Low, Easy) = 0.4\n}\n</code></pre>"},{"location":"examples/#example-queries_2","title":"Example Queries","text":"<p>Inferring intelligence from grade: <pre><code>BayesCalc&gt; P(Intelligence|Grade=A)\nP(Intelligence=High | Grade=A) = 0.5368\nP(Intelligence=Medium | Grade=A) = 0.3473\nP(Intelligence=Low | Grade=A) = 0.1159\n</code></pre></p> <p>Effect of knowing difficulty: <pre><code>BayesCalc&gt; P(Intelligence=High|Grade=A, Difficulty=Hard)\nP(Intelligence=High | Grade=A, Difficulty=Hard) = 0.7568\n</code></pre></p> <p>A grade of 'A' on a hard exam is stronger evidence of high intelligence.</p>"},{"location":"examples/#asia-chest-clinic","title":"Asia Chest Clinic","text":"<p>A more complex medical diagnosis network from the Bayesian network literature.</p>"},{"location":"examples/#network-structure","title":"Network Structure","text":"<ul> <li>Visit to Asia: Binary variable</li> <li>Tuberculosis: Influenced by Asia visit</li> <li>Smoking: Binary variable</li> <li>Lung Cancer: Influenced by smoking</li> <li>Bronchitis: Influenced by smoking</li> <li>TuberculosisOrCancer: Logical OR of tuberculosis and lung cancer</li> <li>X-Ray Result: Influenced by TuberculosisOrCancer</li> <li>Dyspnoea: Influenced by TuberculosisOrCancer and bronchitis</li> </ul>"},{"location":"examples/#example-queries_3","title":"Example Queries","text":"<pre><code>BayesCalc&gt; load examples/asia_chest_clinic.net\nNetwork loaded successfully.\n\nBayesCalc&gt; P(LungCancer|Dyspnoea=Yes, XRayResult=Abnormal)\nP(LungCancer=Yes | Dyspnoea=Yes, XRayResult=Abnormal) = 0.1025\n\nBayesCalc&gt; P(LungCancer|Dyspnoea=Yes, XRayResult=Abnormal, Smoking=Yes)\nP(LungCancer=Yes | Dyspnoea=Yes, XRayResult=Abnormal, Smoking=Yes) = 0.1217\n</code></pre>"},{"location":"examples/#boolean-shorthand","title":"Boolean Shorthand","text":"<p>BayesCalc2 supports convenient shorthand for Boolean variables:</p> <pre><code>variable Rain {True, False}\n\nRain { P(True) = 0.2 }\n</code></pre> <p>Query with shorthand: <pre><code>BayesCalc&gt; P(Rain)        # Same as P(Rain=True)\nP(Rain=True) = 0.2000\n\nBayesCalc&gt; P(!Rain)       # Same as P(Rain=False)\nP(Rain=False) = 0.8000\n</code></pre></p> <p>Conditional queries: <pre><code>BayesCalc&gt; P(Rain|GrassWet)  # Same as P(Rain=True|GrassWet=True)\nP(Rain=True | GrassWet=True) = 0.6203\n</code></pre></p>"},{"location":"examples/#expression-evaluation","title":"Expression Evaluation","text":"<p>Combine multiple probabilities in arithmetic expressions:</p> <pre><code>BayesCalc&gt; P(Rain) * P(Sprinkler)\n0.0200\n\nBayesCalc&gt; P(Rain|GrassWet) / P(Rain)\n3.1015\n\nBayesCalc&gt; 1 - P(Rain)\n0.8000\n</code></pre>"},{"location":"examples/#network-visualization","title":"Network Visualization","text":"<p>Generate PDF diagrams of your networks:</p> <pre><code>BayesCalc&gt; visualize network.pdf\nVisualization saved to network.pdf\n\nBayesCalc&gt; visualize network.pdf --page-size=letter --scale=1.2\nVisualization saved to network.pdf (letter size, 120% scale)\n</code></pre> <p>Supported page sizes: <code>a4</code>, <code>letter</code>, <code>legal</code>, <code>a3</code>, <code>tabloid</code></p>"},{"location":"examples/#batch-processing","title":"Batch Processing","text":"<p>Create a command file <code>analysis.txt</code>:</p> <pre><code># Load network\nload examples/medical_test.net\n\n# Basic queries\nP(Disease=Present)\nP(TestResult=Positive)\n\n# Conditional probabilities\nP(Disease=Present|TestResult=Positive)\nP(Disease=Present|TestResult=Positive, Symptom=Severe)\n\n# Visualize\nvisualize medical_diagnosis.pdf\n\n# Save results\n# (Would need to redirect stdout in shell)\n</code></pre> <p>Run in batch mode: <pre><code>bayescalc -b analysis.txt\n</code></pre></p>"},{"location":"examples/#advanced-analysis","title":"Advanced Analysis","text":""},{"location":"examples/#information-theory","title":"Information Theory","text":"<p>Calculate entropy and mutual information:</p> <pre><code>BayesCalc&gt; entropy(Disease)\nH(Disease) = 0.0808 bits\n\nBayesCalc&gt; mutualInformation(Disease, TestResult)\nI(Disease; TestResult) = 0.0352 bits\n</code></pre>"},{"location":"examples/#network-inspection","title":"Network Inspection","text":"<pre><code>BayesCalc&gt; ls\nVariables:\n  - Disease: {Present, Absent}\n  - TestResult: {Positive, Negative}\n  - Symptom: {Severe, Mild, None}\n\nBayesCalc&gt; printCPT Disease\nCPT for Disease:\nP(Disease=Present) = 0.0100\nP(Disease=Absent) = 0.9900\n\nBayesCalc&gt; printCPT TestResult\nCPT for TestResult | Disease:\nP(TestResult=Positive | Disease=Present) = 0.9500\nP(TestResult=Negative | Disease=Present) = 0.0500\nP(TestResult=Positive | Disease=Absent) = 0.1000\nP(TestResult=Negative | Disease=Absent) = 0.9000\n</code></pre>"},{"location":"examples/#tips-and-tricks","title":"Tips and Tricks","text":""},{"location":"examples/#1-use-tab-completion","title":"1. Use Tab Completion","text":"<p>In interactive mode, press Tab to complete: - Variable names - Command names - Domain values</p>"},{"location":"examples/#2-auto-normalization","title":"2. Auto-normalization","text":"<p>You don't need to specify all probabilities:</p> <pre><code>variable Coin {Heads, Tails}\nCoin { P(Heads) = 0.5 }  # Tails automatically gets 0.5\n</code></pre>"},{"location":"examples/#3-missing-probabilities","title":"3. Missing Probabilities","text":"<p>If you don't specify probabilities for some combinations, they're auto-normalized:</p> <pre><code>GrassWet | Rain, Sprinkler {\n    P(Yes | True, On) = 0.99\n    P(Yes | True, Off) = 0.90\n    # Other combinations auto-normalized\n}\n</code></pre>"},{"location":"examples/#4-error-checking","title":"4. Error Checking","text":"<p>BayesCalc2 validates your network definition: - Probabilities must sum to 1.0 - All parent configurations must be covered - Variable names must be unique - Domain values must be unique within a variable</p>"},{"location":"examples/#5-performance","title":"5. Performance","text":"<p>For large networks: - Variable elimination is efficient (much better than joint tables) - Order queries from most to least specific evidence - Consider breaking very large networks into subnetworks</p>"},{"location":"examples/#more-examples","title":"More Examples","text":"<p>Explore the <code>examples/</code> directory for more networks:</p> <ul> <li><code>alarm_network.net</code> - Home alarm system</li> <li><code>car_starting.net</code> - Car troubleshooting</li> <li><code>credit_approval.net</code> - Credit risk assessment</li> <li><code>genetic_inheritance.net</code> - Genetic traits</li> <li><code>heart_disease.net</code> - Cardiovascular diagnosis</li> <li><code>marketing_funnel.net</code> - Customer conversion</li> <li><code>monty_hall.net</code> - The famous probability puzzle</li> <li><code>text_classification.net</code> - Document categorization</li> </ul> <p>Each demonstrates different aspects of Bayesian reasoning!</p>"},{"location":"github_changelog_template/","title":"Release Notes for v1.0.0-rc2","text":""},{"location":"github_changelog_template/#features","title":"\u2728  Features","text":""},{"location":"github_changelog_template/#improvements","title":"\ud83d\ude80 Improvements","text":"<p>Command line history</p> <p>Documentation restructure - The documentation is now stored under <code>docs/</code> directory and have a newly written \"User Guide\".</p> <p>More example BN - Additional example of Bayesian Networks are included under the <code>exmples/</code> directory</p>"},{"location":"github_changelog_template/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>None (no-reported bugs)</li> </ul>"},{"location":"github_changelog_template/#build-system","title":"\ud83d\udee0  Build system","text":"<ul> <li>Renamed main entry point to <code>bayescalc.main</code></li> </ul>"},{"location":"github_changelog_template/#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>Major rehaul</li> </ul> <p>Full Changelog: </p>"},{"location":"user_guide/","title":"BayesCalc2 User Guide","text":"<p>A comprehensive guide to using the Bayesian Network Calculator for learning, teaching, and research.</p>"},{"location":"user_guide/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Installation</li> <li>Network File Format</li> <li>Usage Walkthrough</li> <li>Appendix A: Complete Command Reference</li> <li>Appendix B: Visualization Guide</li> <li>Appendix C: Mathematical Background</li> </ol>"},{"location":"user_guide/#overview","title":"Overview","text":""},{"location":"user_guide/#purpose","title":"Purpose","text":"<p>BayesCalc2 is an educational and research tool designed to:</p> <ul> <li>Learn Bayesian Networks: Understand probabilistic relationships through hands-on experimentation</li> <li>Teach Probability: Provide an interactive environment for exploring conditional probability, independence, and inference</li> <li>Research Support: Rapid prototyping and analysis of small to medium-sized Bayesian networks</li> <li>Validate Calculations: Double-check manual probability calculations and reasoning</li> </ul>"},{"location":"user_guide/#key-features","title":"Key Features","text":"<ul> <li>Interactive REPL: Real-time probability queries with tab completion</li> <li>Batch Processing: Script multiple commands for automated analysis</li> <li>Rich Query Language: Support for conditional probabilities, arithmetic expressions, and logical operations</li> <li>Information Theory: Built-in entropy, mutual information, and conditional entropy calculations</li> <li>Network Analysis: Independence testing, graph visualization, and structural queries</li> <li>Educational Focus: Clear output formatting and helpful error messages</li> </ul>"},{"location":"user_guide/#limitations","title":"Limitations","text":"<p>Network Size: Optimized for networks with fewer than 15-20 variables. Performance degrades with larger networks due to exponential complexity.</p> <p>Exact Inference Only: Uses exact algorithms (variable elimination). No approximate inference methods like sampling or variational approaches.</p> <p>Static Networks: No support for dynamic Bayesian networks, temporal reasoning, or online learning.</p> <p>Discrete Variables Only: Continuous variables are not supported. All variables must have finite, discrete domains.</p> <p>No Parameter Learning: Network structure and parameters must be specified manually. No learning from data.</p>"},{"location":"user_guide/#installation","title":"Installation","text":""},{"location":"user_guide/#standard-installation","title":"Standard Installation","text":"<p>The graph visualization makes use of <code>graphviz</code> so this must be installed first:</p> <ul> <li>MacOS: <code>brew install graphviz</code></li> <li>Linux Fedore: <code>sudo dnf install grphviz</code></li> <li>Ubuntu: <code>sudo apt-get install graphviz</code></li> </ul> <p>The simplest way to install BayesCalc2:</p> <pre><code>pip install bayescalc2\n</code></pre> <p>This installs the package globally and makes the <code>bayescalc</code> command available system-wide.</p>"},{"location":"user_guide/#development-installation","title":"Development Installation","text":"<p>For development or if you want to modify the source code:</p> <pre><code># Clone the repository\ngit clone https://github.com/johan162/bayescalc2.git \ncd bayescalc2\n\n# Create and activate virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install in development mode\npip install -e .\n</code></pre>"},{"location":"user_guide/#virtual-environment-setup","title":"Virtual Environment Setup","text":"<p>To create an isolated environment (recommended):</p> <pre><code># Create virtual environment\npython -m venv bayescalc-env\n\n# Activate it\nsource bayescalc-env/bin/activate  # On Windows: bayescalc-env\\Scripts\\activate\n\n# Install BayesCalc2\npip install bayescalc2\n\n# Deactivate when done\ndeactivate\n</code></pre>"},{"location":"user_guide/#replicating-the-development-environment","title":"Replicating the Development Environment","text":"<p>To exactly replicate the development environment:</p> <pre><code># Clone the repository\ngit clone https://github.com/johan162/bayescalc2.git\ncd bayescalc2\n\n# Create virtual environment with Python 3.10+\npython -m venv .venv\nsource .venv/bin/activate\n\n# Install dev dependencies from `pyproject.toml`:\npip install -e \".[dev]\"\n\n# Verify installation\nbayescalc --help\n</code></pre>"},{"location":"user_guide/#requirements","title":"Requirements","text":"<ul> <li>Python: 3.10 or higher</li> <li>Dependencies: </li> <li><code>prompt_toolkit &gt;= 3.0.0</code> (for interactive REPL)</li> <li><code>numpy &gt;= 2.3.3</code> (for numerical computations)</li> <li><code>graphviz</code> (for network visualization)</li> </ul>"},{"location":"user_guide/#usage","title":"Usage","text":""},{"location":"user_guide/#usage-mainpy-h-b-batch_file-cmd-cmd_string-network_file-a-bayesian-network-calculator-positional-arguments-network_file-path-to-the-bayesian-network-definition-file-net-or-jpt-options-h-help-show-this-help-message-and-exit-b-batch-batch_file-path-to-a-file-with-commands-to-execute-in-batch-mode-cmd-cmd_string-a-string-of-commands-to-execute-separated-by-semicolons","title":"<pre><code>usage: main.py [-h] [-b BATCH_FILE | --cmd CMD_STRING] network_file\n\nA Bayesian Network Calculator.\n\npositional arguments:\n  network_file          Path to the Bayesian network definition file (*.net or *.jpt).\n\noptions:\n  -h, --help            show this help message and exit\n  -b, --batch BATCH_FILE\n                        Path to a file with commands to execute in batch mode.\n  --cmd CMD_STRING      A string of commands to execute, separated by semicolons.\n</code></pre>","text":""},{"location":"user_guide/#network-file-format","title":"Network File Format","text":""},{"location":"user_guide/#ebnf-grammar","title":"EBNF Grammar","text":"<pre><code>(* Bayesian Network Definition Grammar *)\n\nnetwork          = { statement } ;\nstatement        = variable_decl | cpt_block ;\nvariable_decl    = \"variable\" identifier [ domain_spec ] ;\nboolean_decl     = \"boolean\" identifier ;\ndomain_spec      = \"{\" identifier_list \"}\" ;\nidentifier_list  = identifier { \",\" identifier } ;\n\ncpt_block        = identifier [ \"|\" parent_list ] \"{\" { cpt_entry } \"}\" ;\nparent_list      = identifier_list ;\ncpt_entry        = \"P(\" assignment_list \")\" \"=\" number ;\nassignment_list  = assignment { \",\" assignment } ;\nassignment       = identifier [ \"=\" identifier ] ;\n\nidentifier       = letter { letter | digit | \"_\" } ;\nnumber          = [ \"-\" ] digit { digit } [ \".\" { digit } ] ;\nletter          = \"A\" | ... | \"Z\" | \"a\" | ... | \"z\" ;\ndigit           = \"0\" | ... | \"9\" ;\n\n(* Comments start with # and continue to end of line *)\ncomment         = \"#\" { any_character } newline ;\n</code></pre>"},{"location":"user_guide/#file-structure","title":"File Structure","text":"<p>A network file consists of two main sections:</p> <ol> <li>Variable Declarations: Define variables and their possible values</li> <li>CPT Blocks: Specify conditional probability tables</li> </ol>"},{"location":"user_guide/#variable-declarations","title":"Variable Declarations","text":""},{"location":"user_guide/#basic-syntax","title":"Basic Syntax","text":"<pre><code>variable VariableName {value1, value2, ...}\n</code></pre>"},{"location":"user_guide/#boolean-variables-shorthand","title":"Boolean Variables (Shorthand)","text":"<pre><code>boolean BooleanVar  # Automatically gets domain {True, False}\n</code></pre>"},{"location":"user_guide/#examples","title":"Examples","text":"<pre><code># Explicit domain specification\nvariable Weather {Sunny, Rainy, Cloudy}\nvariable Grade {A, B, C, D, F}\n\n# Boolean variables (implicit True/False domain)\nvariable Raining\nvariable StudyHard\n</code></pre>"},{"location":"user_guide/#cpt-conditional-probability-table-blocks","title":"CPT (Conditional Probability Table) Blocks","text":""},{"location":"user_guide/#root-variables-no-parents","title":"Root Variables (No Parents)","text":"<pre><code>VariableName {\n    P(value1) = probability1\n    P(value2) = probability2\n    # Remaining probabilities auto-completed to sum to 1.0\n}\n</code></pre>"},{"location":"user_guide/#variables-with-parents","title":"Variables with Parents","text":"<pre><code>ChildVariable | Parent1, Parent2 {\n    P(child_value | parent1_value, parent2_value) = probability\n    # Specify probabilities for each parent combination\n}\n</code></pre>"},{"location":"user_guide/#complete-examples","title":"Complete Examples","text":""},{"location":"user_guide/#simple-rain-sprinkler-network","title":"Simple Rain-Sprinkler Network","text":"<pre><code># Weather affects both sprinkler and grass\nvariable Rain {True, False}\nvariable Sprinkler {True, False} \nvariable GrassWet {True, False}\n\n# Prior probability of rain\nRain {\n    P(True) = 0.2\n    # P(False) = 0.8 (auto-completed)\n}\n\n# Sprinkler depends on rain (less likely when raining)\nSprinkler | Rain {\n    P(True | True) = 0.01   # Rarely use sprinkler when raining\n    P(True | False) = 0.4   # More likely when not raining\n}\n\n# Grass wetness depends on both rain and sprinkler\nGrassWet | Rain, Sprinkler {\n    P(True | True, True) = 0.99    # Almost certain when both\n    P(True | True, False) = 0.8    # Likely with just rain\n    P(True | False, True) = 0.9    # Likely with just sprinkler\n    P(True | False, False) = 0.1   # Unlikely with neither\n}\n</code></pre>"},{"location":"user_guide/#student-performance-network","title":"Student Performance Network","text":"<pre><code># Multi-valued variables example\nvariable Difficulty {Easy, Medium, Hard}\nvariable Intelligence {Low, Medium, High}\nvariable Grade {A, B, C, D, F}\nvariable SAT {Low, Medium, High}\n\n# Course difficulty prior\nDifficulty {\n    P(Easy) = 0.3\n    P(Medium) = 0.5\n    # P(Hard) = 0.2 (auto-completed)\n}\n\n# Student intelligence prior  \nIntelligence {\n    P(Low) = 0.2\n    P(Medium) = 0.6\n    P(High) = 0.2\n}\n\n# Grade depends on both difficulty and intelligence\nGrade | Difficulty, Intelligence {\n    # Easy course, Low intelligence\n    P(A | Easy, Low) = 0.1\n    P(B | Easy, Low) = 0.2\n    P(C | Easy, Low) = 0.4\n    P(D | Easy, Low) = 0.2\n    P(F | Easy, Low) = 0.1\n\n    # Easy course, Medium intelligence  \n    P(A | Easy, Medium) = 0.3\n    P(B | Easy, Medium) = 0.4\n    P(C | Easy, Medium) = 0.2\n    P(D | Easy, Medium) = 0.08\n    P(F | Easy, Medium) = 0.02\n\n    # ... (continue for all combinations)\n}\n\n# SAT correlates with intelligence\nSAT | Intelligence {\n    P(High | High) = 0.8\n    P(Medium | High) = 0.15\n    P(Low | High) = 0.05\n\n    P(High | Medium) = 0.3\n    P(Medium | Medium) = 0.5\n    P(Low | Medium) = 0.2\n\n    P(High | Low) = 0.05\n    P(Medium | Low) = 0.25\n    P(Low | Low) = 0.7\n}\n</code></pre>"},{"location":"user_guide/#format-rules-and-tips","title":"Format Rules and Tips","text":""},{"location":"user_guide/#comments","title":"Comments","text":"<ul> <li>Use <code>#</code> for line comments</li> <li>Comments can appear on separate lines or at the end of statements</li> <li>Useful for documenting network structure and assumptions</li> </ul>"},{"location":"user_guide/#probability-specifications","title":"Probability Specifications","text":"<ul> <li>Auto-completion: You don't need to specify all probabilities. The system will auto-complete missing values to ensure each conditional distribution sums to 1.0</li> <li>Boolean shortcuts: For boolean variables, you can use <code>T</code>/<code>F</code> or <code>True</code>/<code>False</code></li> <li>Decimal precision: Use appropriate decimal precision (e.g., <code>0.33</code> vs <code>0.333333</code>)</li> </ul>"},{"location":"user_guide/#common-patterns","title":"Common Patterns","text":"<pre><code># Root node with uniform distribution\nUniformVariable {\n    # All values get equal probability automatically\n}\n\n# Boolean variable with bias\nBiasedCoin {\n    P(True) = 0.7  # P(False) = 0.3 automatically\n}\n\n# Deterministic relationship  \nEffect | Cause {\n    P(True | True) = 1.0   # Always happens\n    P(True | False) = 0.0  # Never happens otherwise\n}\n</code></pre>"},{"location":"user_guide/#usage-walkthrough","title":"Usage Walkthrough","text":"<p>This section walks through a complete session using BayesCalc2, from loading a network to performing various analyses.</p>"},{"location":"user_guide/#starting-bayescalc2","title":"Starting BayesCalc2","text":""},{"location":"user_guide/#interactive-mode","title":"Interactive Mode","text":"<pre><code># Start with a network file\nbayescalc examples/rain_sprinkler_grass.net\n\n# You'll see:\nBayesian Network Calculator (using prompt_toolkit)\nType 'help' for a list of commands, 'exit' to quit.\n&gt;&gt; \n</code></pre>"},{"location":"user_guide/#batch-mode","title":"Batch Mode","text":"<pre><code># Execute a single command\nbayescalc network.net --cmd \"P(Rain|GrassWet=True);showGraph()\"\n\n# Run multiple commands from file\nbayescalc network.net --batch commands.txt\n</code></pre>"},{"location":"user_guide/#example-session-weather-analysis","title":"Example Session: Weather Analysis","text":"<p>Let's work through analyzing the rain-sprinkler-grass network:</p> <pre><code>&gt;&gt; # First, let's explore the network structure\n&gt;&gt; ls\nVariable    | Type       | States\n-----------|------------|------------------\nRain        | Discrete   | True, False\nSprinkler   | Discrete   | True, False  \nGrassWet    | Discrete   | True, False\n\n&gt;&gt; # View the network structure\n&gt;&gt; showGraph()\nRain\n\u251c\u2500\u2500 Sprinkler\n\u2514\u2500\u2500 GrassWet\nSprinkler\n\u2514\u2500\u2500 GrassWet\n\n&gt;&gt; # Check what affects grass wetness\n&gt;&gt; parents(GrassWet)\nParents of GrassWet: {Rain, Sprinkler}\n\n&gt;&gt; # Look at the conditional probability table\n&gt;&gt; printCPT(GrassWet)\nChild    | Parents           | Probability\n---------|-------------------|-------------\nGrassWet | Rain=True, Sprinkler=True  | 0.99\nGrassWet | Rain=True, Sprinkler=False | 0.80\nGrassWet | Rain=False, Sprinkler=True | 0.90\nGrassWet | Rain=False, Sprinkler=False| 0.10\n</code></pre>"},{"location":"user_guide/#basic-probability-queries","title":"Basic Probability Queries","text":"<pre><code>&gt;&gt; # What's the probability of rain?\n&gt;&gt; P(Rain=True)\n0.2\n\n&gt;&gt; # What if we observe wet grass?\n&gt;&gt; P(Rain=True | GrassWet=True)\n0.358\n\n&gt;&gt; # Joint probability\n&gt;&gt; P(Rain=True, Sprinkler=False)\n0.198\n\n&gt;&gt; # Multiple conditions\n&gt;&gt; P(Rain=True | GrassWet=True, Sprinkler=False)\n0.571\n</code></pre>"},{"location":"user_guide/#arithmetic-with-probabilities","title":"Arithmetic with Probabilities","text":"<pre><code>&gt;&gt; # Bayes' rule calculation\n&gt;&gt; P(Rain=True | GrassWet=True) * P(GrassWet=True) / P(Rain=True)\n0.894\n\n&gt;&gt; # Probability of at least one cause\n&gt;&gt; P(Rain=True) + P(Sprinkler=True) - P(Rain=True, Sprinkler=True)\n0.398\n\n&gt;&gt; # Conditional independence check numerically\n&gt;&gt; P(Rain=True | Sprinkler=True) - P(Rain=True)\n0.0\n</code></pre>"},{"location":"user_guide/#independence-analysis","title":"Independence Analysis","text":"<pre><code>&gt;&gt; # Are rain and sprinkler independent?\n&gt;&gt; isindependent(Rain, Sprinkler)\nTrue\n\n&gt;&gt; # Are rain and grass conditionally independent given sprinkler?\n&gt;&gt; iscondindependent(Rain, GrassWet | Sprinkler)\nFalse\n\n&gt;&gt; # Verify with probabilities\n&gt;&gt; P(Rain=True | GrassWet=True, Sprinkler=True)\n0.111\n&gt;&gt; P(Rain=True | Sprinkler=True) \n0.2\n</code></pre>"},{"location":"user_guide/#information-theory-analysis","title":"Information Theory Analysis","text":"<pre><code>&gt;&gt; # How much uncertainty is in each variable?\n&gt;&gt; entropy(Rain)\n0.722\n\n&gt;&gt; entropy(GrassWet)\n0.971\n\n&gt;&gt; # How much does observing grass reduce rain uncertainty?\n&gt;&gt; conditional_entropy(Rain | GrassWet)\n0.639\n\n&gt;&gt; # Mutual information between variables\n&gt;&gt; mutual_information(Rain, GrassWet)\n0.083\n</code></pre>"},{"location":"user_guide/#advanced-queries","title":"Advanced Queries","text":"<pre><code>&gt;&gt; # Compare different scenarios\n&gt;&gt; P(GrassWet=True | Rain=True)\n0.82\n\n&gt;&gt; P(GrassWet=True | Sprinkler=True)\n0.918\n\n&gt;&gt; # Find most likely explanation\n&gt;&gt; P(Rain=True, Sprinkler=False | GrassWet=True)\n0.321\n\n&gt;&gt; P(Rain=False, Sprinkler=True | GrassWet=True)\n0.358\n\n&gt;&gt; # The sprinkler scenario is more likely!\n</code></pre>"},{"location":"user_guide/#batch-processing-example","title":"Batch Processing Example","text":"<p>Create a file <code>analysis.txt</code>: <pre><code># Weather network analysis script\nshowGraph()\nP(Rain=True)\nP(GrassWet=True | Rain=True)\nP(GrassWet=True | Sprinkler=True)  \nisindependent(Rain, Sprinkler)\nmutual_information(Rain, GrassWet)\nprintCPT(Sprinkler)\n</code></pre></p> <p>Run it: <pre><code>bayescalc rain_sprinkler_grass.net --batch analysis.txt\n</code></pre></p>"},{"location":"user_guide/#error-handling-and-debugging","title":"Error Handling and Debugging","text":"<pre><code>&gt;&gt; # Invalid variable name\n&gt;&gt; P(InvalidVar=True)\nError: Variable 'InvalidVar' not found\n\n&gt;&gt; # Invalid value\n&gt;&gt; P(Rain=Maybe)\nError: Value 'Maybe' not in domain of variable 'Rain'\n\n&gt;&gt; # Syntax error\n&gt;&gt; P(Rain=True |)\nError: Expected variable name after '|'\n\n&gt;&gt; # Check variable domains when in doubt\n&gt;&gt; ls\n</code></pre>"},{"location":"user_guide/#pro-tips-for-effective-usage","title":"Pro Tips for Effective Usage","text":"<ol> <li>Start with structure: Use <code>showGraph()</code> and <code>ls</code> to understand the network</li> <li>Validate with simple queries: Check marginal probabilities make sense</li> <li>Use tab completion: Type partial variable names and press Tab</li> <li>Save complex queries: Use batch files for repeated analysis</li> <li>Verify with multiple approaches: Cross-check independence with conditional probabilities</li> <li>Build incrementally: Start with small networks, add complexity gradually</li> </ol>"},{"location":"user_guide/#appendix-a-complete-command-reference","title":"Appendix A: Complete Command Reference","text":""},{"location":"user_guide/#initialization","title":"Initialization","text":""},{"location":"user_guide/#load","title":"<code>load</code>","text":"<p>Purpose: Load a new network from a file</p> <p>Syntax: <code>load(filename)</code></p>"},{"location":"user_guide/#features","title":"Features","text":"<ul> <li>Tab Completion: File paths support tab completion for easy navigation</li> <li>Automatic Reload: All internal state (queries, inference engine, completers) are automatically updated</li> <li>Error Handling: Clear error messages for missing or invalid files</li> <li>Path Expansion: Supports <code>~</code> for home directory expansion</li> </ul>"},{"location":"user_guide/#basic-usage","title":"Basic Usage","text":"<pre><code>&gt;&gt; load(examples/rain_sprinkler_grass.net)\nSuccessfully loaded network from: examples/rain_sprinkler_grass.net\nVariables (3): GrassWet, Rain, Sprinkler\n</code></pre>"},{"location":"user_guide/#notes","title":"Notes","text":"<ul> <li>The previous network state is completely replaced</li> <li>All queries and computations reference the new network after loading</li> <li>File paths are relative to the current working directory where BayesCalc2 was launched</li> <li>Only <code>.net</code> files appear in tab completion suggestions (directories also shown for navigation)</li> </ul>"},{"location":"user_guide/#probability-queries","title":"Probability Queries","text":""},{"location":"user_guide/#basic-probability-syntax","title":"Basic Probability Syntax","text":"<ul> <li><code>P(Variable=Value)</code> - Marginal probability</li> <li><code>P(Variable)</code> - Full distribution over variable (when supported)</li> <li><code>P(A=a, B=b)</code> - Joint probability</li> <li><code>P(A=a | B=b)</code> - Conditional probability</li> <li><code>P(A=a | B=b, C=c)</code> - Multiple conditions</li> </ul>"},{"location":"user_guide/#arithmetic-expressions","title":"Arithmetic Expressions","text":"<ul> <li><code>P(A) * P(B|A)</code> - Multiplication</li> <li><code>P(A) + P(B) - P(A,B)</code> - Addition/subtraction  </li> <li><code>P(A|B) / P(A)</code> - Division</li> <li><code>(P(A) + P(B)) * 0.5</code> - Parentheses and constants</li> </ul>"},{"location":"user_guide/#network-structure-commands","title":"Network Structure Commands","text":""},{"location":"user_guide/#showgraph","title":"<code>showGraph()</code>","text":"<p>Purpose: Display ASCII representation of network structure</p> <p>Output: Tree-like visualization showing parent-child relationships</p> <p>Example: <pre><code>&gt;&gt; showGraph()\nTemp\n\u251c\u2500\u2500 JohnRun\n\u251c\u2500\u2500 MaryRun\n\u2514\u2500\u2500 Meet\n</code></pre></p>"},{"location":"user_guide/#visualizeoutput_file","title":"<code>visualize(output_file)</code>","text":"<p>See: Appendix C</p>"},{"location":"user_guide/#parentsvariable","title":"<code>parents(Variable)</code>","text":"<p>Purpose: List parent variables of specified variable</p> <p>Parameters: Variable name</p> <p>Returns: Set of parent variable names</p> <p>Example:  <pre><code>&gt;&gt; parents(GrassWet)\nParents of GrassWet: {Rain, Sprinkler}\n</code></pre></p>"},{"location":"user_guide/#childrenvariable","title":"<code>children(Variable)</code>","text":"<p>Purpose: List child variables of specified variable</p> <p>Parameters: Variable name</p> <p>Returns: Set of child variable names</p> <p>Example: <pre><code>&gt;&gt; children(Rain)\nChildren of Rain: {Sprinkler, GrassWet}\n</code></pre></p>"},{"location":"user_guide/#ls-vars","title":"<code>ls</code> / <code>vars</code>","text":"<p>Purpose: List all variables with their types and domains</p> <p>Aliases: <code>ls</code>, <code>vars</code></p> <p>Output: Formatted table of variable information</p> <p>Example: <pre><code>&gt;&gt; ls\nVariable    | Type       | States\n-----------|------------|------------------\nRain        | Discrete   | True, False\nWeather     | Discrete   | Sunny, Rainy, Cloudy\n</code></pre></p>"},{"location":"user_guide/#probability-tables","title":"Probability Tables","text":""},{"location":"user_guide/#printcptvariable","title":"<code>printCPT(Variable)</code>","text":"<p>Purpose: Display conditional probability table for specified variable</p> <p>Parameters: Variable name</p> <p>Output: Three-column table (Child | Parents | Probability)</p> <p>Example: <pre><code>&gt;&gt; printCPT(GrassWet)\nChild    | Parents           | Probability\n---------|-------------------|-------------\nGrassWet | Rain=True, Sprinkler=True  | 0.99\nGrassWet | Rain=True, Sprinkler=False | 0.80\nGrassWet | Rain=False, Sprinkler=True | 0.90\nGrassWet | Rain=False, Sprinkler=False| 0.10\n</code></pre></p>"},{"location":"user_guide/#printjpt","title":"<code>printJPT()</code>","text":"<p>Purpose: Display complete joint probability table</p> <p>Warning: Exponentially large for big networks</p> <p>Output: All possible variable assignments with probabilities</p> <p>Use: Small networks only (&lt; 10 variables recommended)</p>"},{"location":"user_guide/#independence-testing","title":"Independence Testing","text":""},{"location":"user_guide/#isindependentvariable1-variable2","title":"<code>isindependent(Variable1, Variable2)</code>","text":"<p>Purpose: Test marginal independence between two variables</p> <p>Parameters: Two variable names</p> <p>Returns: <code>True</code> if independent, <code>False</code> otherwise</p> <p>Mathematical Test: P(A,B) = P(A) \u00d7 P(B)</p> <p>Example: <pre><code>&gt;&gt; isindependent(Rain, Sprinkler)\nTrue\n</code></pre></p>"},{"location":"user_guide/#iscondindependentvariable1-variable2-conditioningset","title":"<code>iscondindependent(Variable1, Variable2 | ConditioningSet)</code>","text":"<p>Purpose: Test conditional independence</p> <p>Syntax: <code>iscondindependent(A, B | C, D, ...)</code></p> <p>Returns: <code>True</code> if conditionally independent</p> <p>Mathematical Test: P(A,B|C) = P(A|C) \u00d7 P(B|C)</p> <p>Example: <pre><code>&gt;&gt; iscondindependent(Rain, GrassWet | Sprinkler)\nFalse\n</code></pre></p>"},{"location":"user_guide/#information-theory","title":"Information Theory","text":""},{"location":"user_guide/#entropyvariable","title":"<code>entropy(Variable)</code>","text":"<p>Purpose: Compute Shannon entropy of variable</p> <p>Formula: H(X) = -\u2211 P(x) log\u2082 P(x)</p> <p>Units: bits</p> <p>Range: [0, log\u2082(|domain|)]</p> <p>Example: <pre><code>&gt;&gt; entropy(Rain)\n0.722  # bits\n</code></pre></p>"},{"location":"user_guide/#conditional_entropyvariable1-variable2","title":"<code>conditional_entropy(Variable1 | Variable2)</code>","text":"<p>Purpose: Compute conditional entropy</p> <p>Syntax: <code>conditional_entropy(X | Y)</code></p> <p>Formula: H(X|Y) = -\u2211\u2211 P(x,y) log\u2082 P(x|y)</p> <p>Interpretation: Average uncertainty in X given Y</p> <p>Example: <pre><code>&gt;&gt; conditional_entropy(Rain | GrassWet)\n0.639\n</code></pre></p>"},{"location":"user_guide/#mutual_informationvariable1-variable2","title":"<code>mutual_information(Variable1, Variable2)</code>","text":"<p>Purpose: Compute mutual information between variables</p> <p>Formula: I(X;Y) = H(X) - H(X|Y) = H(Y) - H(Y|X)</p> <p>Range: [0, min(H(X), H(Y))]</p> <p>Interpretation: Information shared between variables</p> <p>Example: <pre><code>&gt;&gt; mutual_information(Rain, GrassWet)\n0.083\n</code></pre></p>"},{"location":"user_guide/#advanced-probability-commands","title":"Advanced Probability Commands","text":""},{"location":"user_guide/#marginalsn","title":"<code>marginals(N)</code>","text":"<p>Purpose: Generate marginal probabilities for N variables</p> <p>Parameters: Number of variables to include</p> <p>Output: All marginal probability combinations</p> <p>Use: Systematic probability analysis</p>"},{"location":"user_guide/#condprobsn-m","title":"<code>condprobs(N, M)</code>","text":"<p>Purpose: Generate conditional probabilities</p> <p>Parameters: N variables conditioned on M variables</p> <p>Output: All conditional probability combinations</p> <p>Use: Systematic conditional analysis</p>"},{"location":"user_guide/#utility-commands","title":"Utility Commands","text":""},{"location":"user_guide/#help","title":"<code>help</code>","text":"<p>Purpose: Display help message with command summary</p> <p>Aliases: <code>help</code>, <code>?</code></p> <p>Output: Formatted command reference</p>"},{"location":"user_guide/#exit","title":"<code>exit</code>","text":"<p>Purpose: Exit the interactive session</p> <p>Aliases: <code>exit</code>, <code>quit</code>, Ctrl-C, Ctrl-D</p>"},{"location":"user_guide/#command-syntax-rules","title":"Command Syntax Rules","text":""},{"location":"user_guide/#variable-names","title":"Variable Names","text":"<ul> <li>Case-sensitive</li> <li>Must match exactly as defined in network file</li> <li>Tab completion available</li> </ul>"},{"location":"user_guide/#boolean-values","title":"Boolean Values","text":"<ul> <li><code>True</code>/<code>False</code> (recommended)</li> <li><code>T</code>/<code>F</code> (shorthand)</li> <li>Case-sensitive</li> </ul>"},{"location":"user_guide/#arithmetic-operators","title":"Arithmetic Operators","text":"<ul> <li><code>+</code> Addition</li> <li><code>-</code> Subtraction  </li> <li><code>*</code> Multiplication</li> <li><code>/</code> Division</li> <li><code>()</code> Parentheses for grouping</li> </ul>"},{"location":"user_guide/#conditional-syntax","title":"Conditional Syntax","text":"<ul> <li><code>|</code> separates condition variables</li> <li><code>,</code> separates multiple variables</li> <li><code>=</code> assigns values to variables</li> </ul>"},{"location":"user_guide/#appendix-b-visualization-guide","title":"Appendix B: Visualization Guide","text":""},{"location":"user_guide/#overview_1","title":"Overview","text":"<p>BayesCalc2 now supports generating visual representations of Bayesian networks with optional CPT (Conditional Probability Table) displays. This feature uses graphviz to create publication-quality visualizations in multiple formats.</p>"},{"location":"user_guide/#installation_1","title":"Installation","text":""},{"location":"user_guide/#1-install-python-package","title":"1. Install Python Package","text":"<p>The graphviz Python package is included in BayesCalc2's dependencies:</p> <pre><code>pip install bayescalc2\n</code></pre> <p>Or if installing from source:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre>"},{"location":"user_guide/#2-install-graphviz-system-package","title":"2. Install Graphviz System Package","text":"<p>You also need the graphviz system binary:</p> <p>macOS: <pre><code>brew install graphviz\n</code></pre></p> <p>Ubuntu/Debian: <pre><code>sudo apt-get install graphviz\n</code></pre></p> <p>Windows: Download from https://graphviz.org/download/ and add to PATH</p>"},{"location":"user_guide/#usage_1","title":"Usage","text":""},{"location":"user_guide/#basic-command","title":"Basic Command","text":"<pre><code>visualize(output_file)\n</code></pre>"},{"location":"user_guide/#command-syntax","title":"Command Syntax","text":"<pre><code>visualize(output_file, format=FORMAT, show_cpt=BOOL, layout=LAYOUT, rankdir=DIR, page_size=SIZE, scale=FACTOR)\n</code></pre> <p>Parameters:</p> <ul> <li><code>output_file</code> (required): Output filename with or without extension</li> <li><code>format</code>: Output format (<code>pdf</code>, <code>png</code>, <code>svg</code>, <code>jpg</code>) - default: determined from filename or <code>pdf</code></li> <li><code>show_cpt</code>: Include CPT tables in visualization (<code>True</code>/<code>False</code>) - default: <code>True</code></li> <li><code>layout</code>: Graph layout engine - default: <code>dot</code><ul> <li><code>dot</code>: Hierarchical layout (best for DAGs)</li> <li><code>neato</code>: Spring model layout</li> <li><code>fdp</code>: Force-directed placement</li> <li><code>circo</code>: Circular layout</li> <li><code>twopi</code>: Radial layout</li> </ul> </li> <li><code>rankdir</code>: Graph direction - default: <code>TB</code><ul> <li><code>TB</code>: Top to bottom</li> <li><code>LR</code>: Left to right</li> <li><code>BT</code>: Bottom to top</li> <li><code>RL</code>: Right to left</li> </ul> </li> <li><code>page_size</code>: PDF page size (<code>A3</code>, <code>A4</code>, <code>A5</code>, or custom size as <code>WxH</code> in mm, e.g. <code>297x210</code>) - PDF only</li> <li><code>scale</code>: Scale factor for the graph (float, e.g. <code>1.0</code>, <code>0.8</code>, <code>2.0</code>) - PDF only</li> </ul>"},{"location":"user_guide/#pdf-page-size-and-scale","title":"PDF Page Size and Scale","text":"<p>When generating PDF output, you can control the page size and scaling:</p> <ul> <li><code>page_size</code>: Choose from standard sizes (<code>A3</code>, <code>A4</code>, <code>A5</code>) or specify custom dimensions in millimeters (<code>WxH</code>, e.g. <code>210x148</code>).</li> <li><code>scale</code>: Adjusts the overall size of the graph on the page. Use values less than 1.0 to shrink, greater than 1.0 to enlarge.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt; visualize(network.pdf, page_size=A4, scale=0.8)\n&gt;&gt; visualize(network.pdf, page_size=297x210, scale=1.2)\n</code></pre> <p>If omitted, defaults are <code>page_size=None</code> (Graphviz default) and <code>scale=1.0</code> (no scaling).</p>"},{"location":"user_guide/#examples_1","title":"Examples","text":""},{"location":"user_guide/#basic-visualization-with-cpt","title":"Basic Visualization with CPT","text":"<pre><code>&gt;&gt; load(examples/rain_sprinkler_grass.net)\n&gt;&gt; visualize(network.pdf)\nNetwork visualization saved to: network.pdf\n</code></pre>"},{"location":"user_guide/#png-without-cpt-tables","title":"PNG Without CPT Tables","text":"<pre><code>&gt;&gt; visualize(simple_network.png, show_cpt=False)\nNetwork visualization saved to: simple_network.png\n</code></pre>"},{"location":"user_guide/#svg-with-horizontal-layout","title":"SVG with Horizontal Layout","text":"<pre><code>&gt;&gt; visualize(network.svg, rankdir=LR)\nNetwork visualization saved to: network.svg\n</code></pre>"},{"location":"user_guide/#custom-layout-engine","title":"Custom Layout Engine","text":"<pre><code>&gt;&gt; visualize(network.pdf, layout=neato)\nNetwork visualization saved to: network.pdf\n</code></pre>"},{"location":"user_guide/#multiple-options","title":"Multiple Options","text":"<pre><code>&gt;&gt; visualize(exam_network.png, show_cpt=True, layout=dot, rankdir=LR, format=png)\nNetwork visualization saved to: exam_network.png\n</code></pre>"},{"location":"user_guide/#using-the-alias","title":"Using the Alias","text":"<p>The command has a short alias <code>viz</code>:</p> <pre><code>&gt;&gt; viz(network.pdf)\nNetwork visualization saved to: network.pdf\n</code></pre>"},{"location":"user_guide/#output-examples","title":"Output Examples","text":""},{"location":"user_guide/#with-cpt-tables-show_cpttrue","title":"With CPT Tables (<code>show_cpt=True</code>)","text":"<p>Nodes display: - Variable name (header) - Domain values - Probability values for each state - For conditional probabilities, shows parent conditions</p> <p>Example node display: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      Rain           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   True, False       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 P(True)  \u2502  0.2000  \u2502\n\u2502 P(False) \u2502  0.8000  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"user_guide/#without-cpt-tables-show_cptfalse","title":"Without CPT Tables (<code>show_cpt=False</code>)","text":"<p>Shows only variable names and network structure (useful for large networks or presentations).</p>"},{"location":"user_guide/#layout-comparison","title":"Layout Comparison","text":""},{"location":"user_guide/#dot-default","title":"dot (default)","text":"<p>Best for Bayesian networks - creates hierarchical tree layout respecting parent-child relationships.</p>"},{"location":"user_guide/#neato","title":"neato","text":"<p>Force-directed layout - good for showing network connectivity patterns.</p>"},{"location":"user_guide/#fdp","title":"fdp","text":"<p>Similar to neato but uses different force model - useful for larger networks.</p>"},{"location":"user_guide/#circo","title":"circo","text":"<p>Circular layout - good for visualizing networks with cyclic structures or for aesthetic purposes.</p>"},{"location":"user_guide/#tab-completion","title":"Tab Completion","text":"<p>The visualize command supports tab completion:</p> <pre><code>&gt;&gt; visualize(&lt;TAB&gt;\nnetwork.pdf    network.png    network.svg    network_simple.pdf\n\n&gt;&gt; visualize(network.pdf, &lt;TAB&gt;\nformat=pdf    format=png    format=svg    show_cpt=True    show_cpt=False    \nlayout=dot    layout=neato  layout=fdp    rankdir=TB       rankdir=LR\n</code></pre>"},{"location":"user_guide/#use-cases","title":"Use Cases","text":""},{"location":"user_guide/#1-documentation","title":"1. Documentation","text":"<p>Generate diagrams for papers, reports, or documentation: <pre><code>&gt;&gt; visualize(paper_figure.pdf, show_cpt=False, rankdir=LR)\n</code></pre></p>"},{"location":"user_guide/#2-teaching","title":"2. Teaching","text":"<p>Create educational materials showing both structure and probabilities: <pre><code>&gt;&gt; visualize(lecture_slide.png, show_cpt=True)\n</code></pre></p>"},{"location":"user_guide/#3-debugging","title":"3. Debugging","text":"<p>Quickly visualize network structure during development: <pre><code>&gt;&gt; viz(debug.svg, show_cpt=False)\n</code></pre></p>"},{"location":"user_guide/#4-presentations","title":"4. Presentations","text":"<p>Generate clean, professional-looking network diagrams: <pre><code>&gt;&gt; visualize(presentation.pdf, show_cpt=True, layout=dot, rankdir=TB)\n</code></pre></p>"},{"location":"user_guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user_guide/#error-graphviz-package-not-installed","title":"Error: graphviz package not installed","text":"<p>Install the Python package: <pre><code>pip install graphviz\n</code></pre></p>"},{"location":"user_guide/#error-failed-to-execute-dot","title":"Error: failed to execute 'dot'","text":"<p>Install the graphviz system package (see Installation section above).</p>"},{"location":"user_guide/#large-cpt-tables","title":"Large CPT Tables","text":"<p>For variables with many parent combinations, the visualizer automatically truncates the CPT display to show only the first 8 entries, with a note indicating how many more exist.</p>"},{"location":"user_guide/#graph-too-large","title":"Graph Too Large","text":"<p>For large networks: 1. Use <code>show_cpt=False</code> to reduce node size 2. Try different layouts (<code>neato</code>, <code>fdp</code>) for better spacing 3. Use <code>rankdir=LR</code> for horizontal layout 4. Generate SVG format for scalable output</p>"},{"location":"user_guide/#programmatic-use","title":"Programmatic Use","text":"<p>For advanced users, the visualizer can be used programmatically:</p> <pre><code>from bayescalc.visualizer import NetworkVisualizer\n\nvisualizer = NetworkVisualizer(network)\noutput_path = visualizer.generate_graph(\n    output_file=\"custom_network\",\n    format=\"pdf\",\n    show_cpt=True,\n    layout=\"dot\",\n    rankdir=\"TB\"\n)\nprint(f\"Saved to: {output_path}\")\n</code></pre>"},{"location":"user_guide/#file-formats","title":"File Formats","text":"<ul> <li>PDF: Best for documents and papers (vector format, scales perfectly)</li> <li>PNG: Good for web and presentations (raster format)</li> <li>SVG: Best for web and editing (vector format, editable)</li> <li>JPG: Compact raster format (lower quality)</li> </ul>"},{"location":"user_guide/#tips","title":"Tips","text":"<ol> <li>Start simple: First generate without CPT tables to see structure</li> <li>Iterate: Try different layouts to find best visualization</li> <li>Choose format wisely: Use PDF/SVG for publications, PNG for quick sharing</li> <li>Direction matters: Top-bottom works well for small networks, left-right for wide ones</li> <li>Tab completion: Use tab completion to discover options quickly</li> </ol>"},{"location":"user_guide/#appendix-c-mathematical-background","title":"Appendix C: Mathematical Background","text":""},{"location":"user_guide/#bayesian-networks-fundamentals","title":"Bayesian Networks Fundamentals","text":""},{"location":"user_guide/#definition","title":"Definition","text":"<p>A Bayesian network is a probabilistic graphical model representing conditional dependencies between random variables through a directed acyclic graph (DAG).</p> <p>Components: 1. Graph Structure: Nodes represent variables, edges represent direct dependencies 2. Parameters: Conditional probability tables (CPTs) quantify relationships</p>"},{"location":"user_guide/#joint-probability-factorization","title":"Joint Probability Factorization","text":"<p>For variables X\u2081, X\u2082, ..., X\u2099 with parents Pa(X\u1d62):</p> <p>P(X\u2081, X\u2082, ..., X\u2099) = \u220f\u1d62 P(X\u1d62 | Pa(X\u1d62))</p> <p>This factorization enables efficient representation and computation.</p>"},{"location":"user_guide/#independence-relations","title":"Independence Relations","text":""},{"location":"user_guide/#marginal-independence","title":"Marginal Independence","text":"<p>Variables A and B are independent if: P(A, B) = P(A) \u00d7 P(B)</p> <p>Equivalently: P(A | B) = P(A) and P(B | A) = P(B)</p>"},{"location":"user_guide/#conditional-independence","title":"Conditional Independence","text":"<p>Variables A and B are conditionally independent given C if: P(A, B | C) = P(A | C) \u00d7 P(B | C)</p> <p>Equivalently: P(A | B, C) = P(A | C)</p>"},{"location":"user_guide/#d-separation","title":"d-Separation","text":"<p>Graph-theoretic criterion for reading independence relations: - Chain: A \u2192 B \u2192 C, A and C are independent given B - Fork: A \u2190 B \u2192 C, A and C are independent given B - Collider: A \u2192 B \u2190 C, A and C are dependent given B</p>"},{"location":"user_guide/#inference-algorithms","title":"Inference Algorithms","text":""},{"location":"user_guide/#variable-elimination","title":"Variable Elimination","text":"<p>BayesCalc2 uses variable elimination for exact inference:</p> <ol> <li>Eliminate variables not in query in reverse topological order</li> <li>Sum out variables by marginalizing joint distributions  </li> <li>Normalize final result</li> </ol> <p>Complexity: Exponential in tree-width of moral graph</p>"},{"location":"user_guide/#query-types-supported","title":"Query Types Supported","text":"<ul> <li>Marginal: P(X = x)</li> <li>Conditional: P(X = x | E = e) </li> <li>Joint: P(X\u2081 = x\u2081, X\u2082 = x\u2082, ...)</li> <li>MAP: Most probable assignment (partially supported)</li> </ul>"},{"location":"user_guide/#information-theory-measures","title":"Information Theory Measures","text":""},{"location":"user_guide/#shannon-entropy","title":"Shannon Entropy","text":"<p>Measures uncertainty/information content: H(X) = -\u2211\u2093 P(x) log\u2082 P(x)</p> <p>Properties: - H(X) \u2265 0 (non-negative) - H(X) = 0 iff X is deterministic - H(X) \u2264 log\u2082|X| (maximized by uniform distribution)</p>"},{"location":"user_guide/#conditional-entropy","title":"Conditional Entropy","text":"<p>Expected entropy of X given Y: H(X|Y) = \u2211\u1d67 P(y) H(X|Y=y) = -\u2211\u2093,\u1d67 P(x,y) log\u2082 P(x|y)</p> <p>Chain Rule: H(X,Y) = H(X) + H(Y|X) = H(Y) + H(X|Y)</p>"},{"location":"user_guide/#mutual-information","title":"Mutual Information","text":"<p>Information shared between variables: I(X;Y) = H(X) - H(X|Y) = H(Y) - H(Y|X)</p> <p>Alternative form: I(X;Y) = \u2211\u2093,\u1d67 P(x,y) log\u2082[P(x,y)/(P(x)P(y))]</p> <p>Properties: - I(X;Y) \u2265 0 (non-negative) - I(X;Y) = 0 iff X \u22a5 Y (independence) - I(X;Y) = I(Y;X) (symmetric)</p>"},{"location":"user_guide/#computational-complexity","title":"Computational Complexity","text":""},{"location":"user_guide/#network-size-limitations","title":"Network Size Limitations","text":"<ul> <li>Variables: Practical limit ~15-20 variables</li> <li>Domain Size: Product of all domain sizes affects complexity</li> <li>Tree Width: Determines inference complexity</li> </ul>"},{"location":"user_guide/#exponential-blowup","title":"Exponential Blowup","text":"<p>Joint probability table size: \u220f\u1d62 |Domain(X\u1d62)|</p> <p>For n binary variables: 2\u207f entries</p>"},{"location":"user_guide/#optimization-strategies","title":"Optimization Strategies","text":"<ol> <li>Variable Ordering: Affects intermediate factor sizes</li> <li>Caching: Store computed factors for reuse</li> <li>Lazy Evaluation: Compute only needed probabilities</li> </ol>"},{"location":"user_guide/#practical-considerations","title":"Practical Considerations","text":""},{"location":"user_guide/#numerical-precision","title":"Numerical Precision","text":"<ul> <li>Underflow: Very small probabilities may underflow</li> <li>Log Space: Consider log-probabilities for stability  </li> <li>Normalization: Ensure probabilities sum to 1.0</li> </ul>"},{"location":"user_guide/#model-validation","title":"Model Validation","text":"<ul> <li>CPT Consistency: Each conditional distribution sums to 1</li> <li>Acyclicity: Graph must be directed and acyclic</li> <li>Completeness: All parent combinations must be specified</li> </ul>"},{"location":"user_guide/#common-patterns_1","title":"Common Patterns","text":"<p>Naive Bayes: All features conditionally independent given class <pre><code>Class \u2192 Feature1\nClass \u2192 Feature2  \nClass \u2192 Feature3\n</code></pre></p> <p>Markov Chain: Sequential dependence <pre><code>X\u2081 \u2192 X\u2082 \u2192 X\u2083 \u2192 X\u2084\n</code></pre></p> <p>Tree: Hierarchical structure with single paths <pre><code>Root \u2192 Child1 \u2192 Grandchild1\nRoot \u2192 Child2 \u2192 Grandchild2\n</code></pre></p>"},{"location":"user_guide/#conclusion","title":"Conclusion","text":"<p>BayesCalc2 provides a powerful yet accessible platform for exploring Bayesian networks. This guide covers the essential concepts and practical usage patterns needed to effectively use the tool for learning, teaching, and research.</p> <p>For additional support: - Check the <code>examples/</code> directory for more network files - Use the built-in <code>help</code> command for quick reference - Consult the source code for implementation details</p> <p>Happy exploring with Bayesian networks!</p>"},{"location":"api/","title":"API Reference","text":"<p>This section provides detailed API documentation for BayesCalc2's internal modules.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>BayesCalc2 is organized into several key modules:</p>"},{"location":"api/#core-components","title":"Core Components","text":"<ul> <li> <p>Network Model: Core data structures for Bayesian networks</p> <ul> <li><code>BayesianNetwork</code>: Main network container</li> <li><code>Variable</code>: Network variable with domain</li> <li><code>CPT</code>: Conditional probability table</li> <li><code>Factor</code>: Probability factor for inference</li> </ul> </li> <li> <p>Parser: Parses <code>.net</code> files into network structures</p> <ul> <li><code>Parser</code>: Main parser class</li> <li>AST node types for network definition elements</li> </ul> </li> <li> <p>Lexer: Tokenizes <code>.net</code> files</p> <ul> <li><code>Lexer</code>: Main lexer class</li> <li><code>Token</code>: Token representation</li> <li><code>TokenType</code>: Token type enumeration</li> </ul> </li> </ul>"},{"location":"api/#inference-engine","title":"Inference Engine","text":"<ul> <li>Inference: Probability computation engine<ul> <li><code>Inference</code>: Main inference class</li> <li>Variable elimination algorithm</li> <li>Factor operations (multiply, marginalize, normalize)</li> </ul> </li> </ul>"},{"location":"api/#query-processing","title":"Query Processing","text":"<ul> <li> <p>Query Parser: Parses and executes probability queries</p> <ul> <li><code>QueryParser</code>: Main query parser</li> <li>Support for <code>P(A|B)</code> syntax</li> <li>Boolean shorthand handling</li> </ul> </li> <li> <p>Expression Parser: Evaluates arithmetic expressions</p> <ul> <li><code>ExpressionParser</code>: Expression evaluator</li> <li>Support for <code>P(A) * P(B) / P(C)</code> syntax</li> </ul> </li> </ul>"},{"location":"api/#interactive-components","title":"Interactive Components","text":"<ul> <li> <p>REPL: Interactive shell interface</p> <ul> <li><code>REPL</code>: Main REPL class</li> <li>Command-line interface with history and completion</li> </ul> </li> <li> <p>Commands: Command handlers</p> <ul> <li><code>CommandHandler</code>: Command execution</li> <li>Built-in commands (ls, printCPT, visualize, etc.)</li> </ul> </li> <li> <p>Completer: Tab completion</p> <ul> <li><code>BayesCalcCompleter</code>: Auto-completion engine</li> <li>Variable, command, and domain value completion</li> </ul> </li> </ul>"},{"location":"api/#batch-processing","title":"Batch Processing","text":"<ul> <li>Batch Runner: Non-interactive command execution<ul> <li>Batch file processing</li> <li>Command execution without REPL</li> </ul> </li> </ul>"},{"location":"api/#architecture","title":"Architecture","text":"<p>The system follows a pipeline architecture:</p> <pre><code>Input (.net file) \u2192 Lexer \u2192 Parser \u2192 BayesianNetwork\n                                            \u2193\n                                    Inference Engine\n                                            \u2191\n                                     Query Parser \u2190 User Query\n</code></pre>"},{"location":"api/#network-definition-pipeline","title":"Network Definition Pipeline","text":"<ol> <li>Lexer (<code>lexer.py</code>): Tokenizes input text into tokens</li> <li>Parser (<code>parser.py</code>): Builds AST and creates network model</li> <li>BayesianNetwork (<code>network_model.py</code>): Stores network structure and CPTs</li> </ol>"},{"location":"api/#query-execution-pipeline","title":"Query Execution Pipeline","text":"<ol> <li>QueryParser (<code>queries.py</code>): Parses probability query syntax</li> <li>Inference (<code>inference.py</code>): Computes probability using variable elimination</li> <li>ExpressionParser (<code>expression_parser.py</code>): Evaluates arithmetic on probabilities</li> </ol>"},{"location":"api/#interactive-mode","title":"Interactive Mode","text":"<ol> <li>REPL (<code>repl.py</code>): Main interactive loop</li> <li>CommandHandler (<code>commands.py</code>): Executes user commands</li> <li>BayesCalcCompleter (<code>completer.py</code>): Provides tab completion</li> </ol>"},{"location":"api/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/#loading-a-network","title":"Loading a Network","text":"<pre><code>from bayescalc.lexer import Lexer\nfrom bayescalc.parser import Parser\n\n# Read network file\nwith open('network.net', 'r') as f:\n    net_str = f.read()\n\n# Parse network\nlexer = Lexer(net_str)\ntokens = lexer.tokenize()\nparser = Parser(tokens)\nnetwork = parser.parse()\n</code></pre>"},{"location":"api/#running-inference","title":"Running Inference","text":"<pre><code>from bayescalc.inference import Inference\n\n# Create inference engine\ninference = Inference(network)\n\n# Query probability\nquery_vars = [('Rain', 'True')]\nevidence = [('GrassWet', 'Yes')]\nresult = inference.query(query_vars, evidence)\n\nprint(f\"P(Rain=True | GrassWet=Yes) = {result:.4f}\")\n</code></pre>"},{"location":"api/#using-the-repl","title":"Using the REPL","text":"<pre><code>from bayescalc.repl import REPL\n\n# Create and run REPL\nrepl = REPL(network)\nrepl.run()  # Interactive session\n</code></pre>"},{"location":"api/#batch-processing_1","title":"Batch Processing","text":"<pre><code>from bayescalc.batch import run_batch\n\n# Execute commands from file\nrun_batch(network, 'commands.txt')\n</code></pre>"},{"location":"api/#key-classes","title":"Key Classes","text":""},{"location":"api/#bayesiannetwork","title":"BayesianNetwork","text":"<p>Central data structure holding: - Variables and their domains - Conditional probability tables - Network topology</p>"},{"location":"api/#variable","title":"Variable","text":"<p>Represents a random variable: - Name - Domain (possible values) - Parent variables - CPT (conditional probability table)</p>"},{"location":"api/#inference","title":"Inference","text":"<p>Implements variable elimination: - Factor creation from CPTs - Factor multiplication - Marginalization (summing out variables) - Normalization</p>"},{"location":"api/#queryparser","title":"QueryParser","text":"<p>Handles query syntax: - Parse <code>P(A|B)</code> notation - Boolean shorthand (<code>Rain</code> \u2192 <code>Rain=True</code>) - Evidence specification</p>"},{"location":"api/#testing","title":"Testing","text":"<p>All modules include comprehensive test suites in the <code>tests/</code> directory:</p> <ul> <li><code>test_lexer.py</code>: Lexer tokenization tests</li> <li><code>test_parser.py</code>: Parser and network construction tests</li> <li><code>test_network_model.py</code>: Data model tests</li> <li><code>test_inference.py</code>: Inference algorithm tests</li> <li><code>test_queries.py</code>: Query parsing tests</li> <li><code>test_commands.py</code>: Command execution tests</li> <li><code>test_repl_e2e.py</code>: End-to-end REPL tests</li> </ul> <p>Run tests with: <pre><code>pytest tests/\n</code></pre></p>"},{"location":"api/#extension-points","title":"Extension Points","text":""},{"location":"api/#adding-new-commands","title":"Adding New Commands","text":"<p>Register in <code>CommandHandler._initialize_command_registry()</code>:</p> <pre><code>def _initialize_command_registry(self):\n    self.command_registry = {\n        'mycommand': self.cmd_mycommand,\n        # ...\n    }\n\ndef cmd_mycommand(self, args: List[str]) -&gt; None:\n    \"\"\"Execute my custom command.\"\"\"\n    # Implementation\n</code></pre>"},{"location":"api/#custom-inference-algorithms","title":"Custom Inference Algorithms","text":"<p>Subclass <code>Inference</code> and override <code>query()</code> method:</p> <pre><code>from bayescalc.inference import Inference\n\nclass CustomInference(Inference):\n    def query(self, query_vars, evidence):\n        # Custom implementation\n        pass\n</code></pre>"},{"location":"api/#custom-query-syntax","title":"Custom Query Syntax","text":"<p>Extend <code>QueryParser</code> to support new syntax:</p> <pre><code>from bayescalc.queries import QueryParser\n\nclass ExtendedQueryParser(QueryParser):\n    def parse(self, query_str):\n        # Handle custom syntax\n        pass\n</code></pre>"},{"location":"api/#api-documentation","title":"API Documentation","text":"<p>For detailed API documentation of each module, see the individual module pages in the sidebar.</p>"},{"location":"api/batch/","title":"Batch Runner","text":""},{"location":"api/batch/#bayescalc.batch","title":"<code>bayescalc.batch</code>","text":"<p>This module handles batch mode execution for the Bayesian Network calculator.</p>"},{"location":"api/batch/#bayescalc.batch-classes","title":"Classes","text":""},{"location":"api/batch/#bayescalc.batch-functions","title":"Functions","text":""},{"location":"api/batch/#bayescalc.batch.execute_commands","title":"<code>execute_commands(network, commands)</code>","text":"<p>Executes a list of commands.</p> Source code in <code>src/bayescalc/batch.py</code> <pre><code>def execute_commands(network: BayesianNetwork, commands: list[str]):\n    \"\"\"\n    Executes a list of commands.\n    \"\"\"\n    query_parser = QueryParser(network)\n    command_handler = CommandHandler(network)\n\n    for line in commands:\n        line = line.strip()\n        if not line or line.startswith(\"#\"):\n            continue\n\n        print(f\"&gt;&gt; {line}\")\n        try:\n            if line.lower() == \"exit\":\n                break\n            if line.startswith(\"P(\"):\n                result = query_parser.parse_and_execute(line)\n                for assignment, prob in result.probabilities.items():\n                    print(f\"  P({', '.join(assignment)}) = {prob:.6f}\")\n            else:\n                result = command_handler.execute(line)\n                print(result)\n        except (ValueError, SyntaxError, KeyError) as e:\n            print(f\"Error processing command '{line}': {e}\", file=sys.stderr)\n        finally:\n            print(\"-\" * 20)\n</code></pre>"},{"location":"api/batch/#bayescalc.batch.run_batch","title":"<code>run_batch(network, commands_file)</code>","text":"<p>Executes a list of commands from a file in batch mode.</p> Source code in <code>src/bayescalc/batch.py</code> <pre><code>def run_batch(network: BayesianNetwork, commands_file: str):\n    \"\"\"\n    Executes a list of commands from a file in batch mode.\n    \"\"\"\n    try:\n        with open(commands_file, \"r\") as f:\n            commands = f.readlines()\n            execute_commands(network, commands)\n\n    except FileNotFoundError:\n        print(f\"Error: Commands file not found at '{commands_file}'\", file=sys.stderr)\n</code></pre>"},{"location":"api/commands/","title":"Commands","text":""},{"location":"api/commands/#bayescalc.commands","title":"<code>bayescalc.commands</code>","text":"<p>This module implements the utility commands for the Bayesian Network calculator.</p>"},{"location":"api/commands/#bayescalc.commands-classes","title":"Classes","text":""},{"location":"api/commands/#bayescalc.commands.CommandHandler","title":"<code>CommandHandler</code>","text":"Source code in <code>src/bayescalc/commands.py</code> <pre><code>class CommandHandler:\n    def __init__(\n        self,\n        network: BayesianNetwork,\n        reload_callback: Optional[Callable[[BayesianNetwork], None]] = None,\n    ):\n        self.network = network\n        self.inference = Inference(network)\n        self.reload_callback = reload_callback\n        self._initialize_command_registry()\n\n    def _initialize_command_registry(self):\n        \"\"\"Initialize the command registry with all available commands.\"\"\"\n        self.commands = {\n            # Command name -&gt; {aliases, handler, help, requires_args, special_parsing, arg_count, validate_args}\n            \"printCPT\": {\n                \"aliases\": [],\n                \"handler\": self.print_cpt,\n                \"help\": \"printCPT(variable_name) - Print the Conditional Probability Table for a variable\",\n                \"requires_args\": True,\n                \"special_parsing\": False,\n                \"arg_count\": 1,\n                \"validate_args\": True,\n            },\n            \"parents\": {\n                \"aliases\": [],\n                \"handler\": self.get_parents,\n                \"help\": \"parents(variable_name) - Get the parent variables of a given variable\",\n                \"requires_args\": True,\n                \"special_parsing\": False,\n                \"arg_count\": 1,\n                \"validate_args\": True,\n            },\n            \"children\": {\n                \"aliases\": [],\n                \"handler\": self.get_children,\n                \"help\": \"children(variable_name) - Get the child variables of a given variable\",\n                \"requires_args\": True,\n                \"special_parsing\": False,\n                \"arg_count\": 1,\n                \"validate_args\": True,\n            },\n            \"isindependent\": {\n                \"aliases\": [],\n                \"handler\": self.is_independent,\n                \"help\": \"isindependent(var1, var2) - Check if two variables are independent\",\n                \"requires_args\": True,\n                \"special_parsing\": False,\n                \"arg_count\": 2,\n                \"validate_args\": True,\n            },\n            \"iscondindependent\": {\n                \"aliases\": [],\n                \"handler\": self._handle_cond_independent,\n                \"help\": \"iscondindependent(var1, var2 | cond_vars...) - Check conditional independence\",\n                \"requires_args\": True,\n                \"special_parsing\": True,\n                \"arg_count\": None,  # Variable arguments due to special parsing\n                \"validate_args\": False,  # Validation handled in special parser\n            },\n            \"entropy\": {\n                \"aliases\": [],\n                \"handler\": self.entropy,\n                \"help\": \"entropy(variable_name) - Calculate the entropy of a variable\",\n                \"requires_args\": True,\n                \"special_parsing\": False,\n                \"arg_count\": 1,\n                \"validate_args\": True,\n            },\n            \"conditional_entropy\": {\n                \"aliases\": [],\n                \"handler\": self._handle_conditional_entropy,\n                \"help\": \"conditional_entropy(X | Y) - Calculate conditional entropy H(X|Y)\",\n                \"requires_args\": True,\n                \"special_parsing\": True,\n                \"arg_count\": None,  # Variable arguments due to special parsing\n                \"validate_args\": False,  # Validation handled in special parser\n            },\n            \"mutual_information\": {\n                \"aliases\": [],\n                \"handler\": self.mutual_information,\n                \"help\": \"mutual_information(var1, var2) - Calculate mutual information between two variables\",\n                \"requires_args\": True,\n                \"special_parsing\": False,\n                \"arg_count\": 2,\n                \"validate_args\": True,\n            },\n            \"ls\": {\n                \"aliases\": [\"vars\"],\n                \"handler\": self.list_variables,\n                \"help\": \"ls() or vars() - List all variables and their domains\",\n                \"requires_args\": False,\n                \"special_parsing\": False,\n                \"arg_count\": 0,\n                \"validate_args\": False,  # No args to validate\n            },\n            \"showGraph\": {\n                \"aliases\": [],\n                \"handler\": self.show_graph,\n                \"help\": \"showGraph() - Display an ASCII representation of the network graph\",\n                \"requires_args\": False,\n                \"special_parsing\": False,\n                \"arg_count\": 0,\n                \"validate_args\": False,  # No args to validate\n            },\n            \"printJPT\": {\n                \"aliases\": [],\n                \"handler\": self.print_jpt,\n                \"help\": \"printJPT() - Print the complete Joint Probability Table\",\n                \"requires_args\": False,\n                \"special_parsing\": False,\n                \"arg_count\": 0,\n                \"validate_args\": False,  # No args to validate\n            },\n            \"help\": {\n                \"aliases\": [\"?\"],\n                \"handler\": self._handle_help,\n                \"help\": \"help() or help(command) - Show help for all commands or a specific command\",\n                \"requires_args\": False,\n                \"special_parsing\": True,\n                \"arg_count\": None,  # Optional argument\n                \"validate_args\": False,  # Validation handled in special parser\n            },\n            \"marginals\": {\n                \"aliases\": [],\n                \"handler\": self.marginals,\n                \"help\": \"marginals(n) - List marginal probabilities for all n-variable combinations\",\n                \"requires_args\": True,\n                \"special_parsing\": False,\n                \"arg_count\": 1,\n                \"validate_args\": True,\n            },\n            \"condprobs\": {\n                \"aliases\": [],\n                \"handler\": self.condprobs,\n                \"help\": \"condprobs(n, m) - List all conditional probabilities P(A|B) for n-by-m variable combinations\",\n                \"requires_args\": True,\n                \"special_parsing\": False,\n                \"arg_count\": 2,\n                \"validate_args\": True,\n            },\n            \"load\": {\n                \"aliases\": [],\n                \"handler\": self.load_network,\n                \"help\": \"load(filename) - Load a new Bayesian network from a file\",\n                \"requires_args\": True,\n                \"special_parsing\": False,\n                \"arg_count\": 1,\n                \"validate_args\": True,\n            },\n            \"visualize\": {\n                \"aliases\": [\"viz\"],\n                \"handler\": self._handle_visualize,\n                \"help\": (\n                    \"visualize(output_file, format=pdf, show_cpt=True, layout=dot, rankdir=TB) - Generate network visualization\\n\"\n                    \"    output_file: Path to output file (without extension)\\n\"\n                    \"    format: Output format (pdf, png, svg, jpg) [default: pdf]\\n\"\n                    \"    show_cpt: Include CPT tables in visualization (True/False) [default: True]\\n\"\n                    \"    layout: Graph layout engine (dot, neato, fdp, circo, twopi) [default: dot]\\n\"\n                    \"    rankdir: Graph direction (TB, LR, BT, RL) [default: TB]\\n\"\n                    \"    Examples: visualize(network.pdf), visualize(graph, format=png, show_cpt=False)\"\n                ),\n                \"requires_args\": True,\n                \"special_parsing\": True,\n                \"arg_count\": None,\n                \"validate_args\": False,\n            },\n        }\n\n        # Create alias lookup table\n        self.alias_to_command = {}\n        for cmd_name, cmd_info in self.commands.items():\n            self.alias_to_command[cmd_name] = cmd_name\n            for alias in cmd_info[\"aliases\"]:\n                self.alias_to_command[alias] = cmd_name\n\n    def is_command(self, command_str: str) -&gt; bool:\n        \"\"\"\n        Check if the given string looks like a command from the command registry.\n\n        Args:\n            command_str: The string to check\n\n        Returns:\n            bool: True if it matches a known command pattern\n        \"\"\"\n        command_str = command_str.strip()\n\n        # Check if it's a command without arguments\n        if command_str in self.alias_to_command:\n            return True\n\n        # Check if it matches command(args) pattern\n        match = re.match(r\"(\\w+)\\(\", command_str)\n        if match:\n            command = match.group(1)\n            return command in self.alias_to_command\n\n        return False\n\n    def execute(self, command_str: str):\n        \"\"\"Parses and executes a command using the command registry.\"\"\"\n        command_str = command_str.strip()\n\n        # Handle commands without arguments/parentheses (shortcuts)\n        if command_str in self.alias_to_command:\n            cmd_name = self.alias_to_command[command_str]\n            cmd_info = self.commands[cmd_name]\n            if not cmd_info[\"requires_args\"]:\n                return cmd_info[\"handler\"]()\n            else:\n                raise ValueError(\n                    f\"Command '{command_str}' requires arguments. Use: {cmd_info['help']}\"\n                )\n\n        # Parse command with parentheses\n        match = re.match(r\"(\\w+)\\((.*)\\)\", command_str)\n        if not match:\n            raise ValueError(\n                f\"Invalid command format: {command_str}. Use 'help()' to see available commands.\"\n            )\n\n        command = match.group(1)\n        args_str = match.group(2)\n\n        # Look up command in registry\n        if command not in self.alias_to_command:\n            raise ValueError(\n                f\"Unknown command: {command}. Use 'help()' to see available commands.\"\n            )\n\n        cmd_name = self.alias_to_command[command]\n        cmd_info = self.commands[cmd_name]\n\n        # Handle commands that require special parsing\n        if cmd_info[\"special_parsing\"]:\n            return cmd_info[\"handler\"](args_str)\n\n        # Handle commands that don't require arguments\n        if not cmd_info[\"requires_args\"]:\n            if args_str.strip():\n                raise ValueError(\n                    f\"Command '{command}' does not take arguments. Use: {cmd_info['help']}\"\n                )\n            return cmd_info[\"handler\"]()\n\n        # Handle regular commands with comma-separated arguments\n        args = [arg.strip() for arg in args_str.split(\",\")] if args_str else []\n\n        # Validate argument count using registry information\n        if cmd_info[\"validate_args\"]:\n            expected_count = cmd_info[\"arg_count\"]\n            if len(args) != expected_count:\n                if expected_count == 1:\n                    raise ValueError(\n                        f\"{cmd_name} requires one argument. Use: {cmd_info['help']}\"\n                    )\n                elif expected_count == 2:\n                    raise ValueError(\n                        f\"{cmd_name} requires two arguments. Use: {cmd_info['help']}\"\n                    )\n                else:\n                    raise ValueError(\n                        f\"{cmd_name} requires {expected_count} arguments. Use: {cmd_info['help']}\"\n                    )\n\n        return cmd_info[\"handler\"](*args)\n\n    def _handle_help(self, args_str: str = \"\") -&gt; str:\n        \"\"\"Handle help command - show help for all commands or a specific command.\"\"\"\n        command_name = args_str.strip() if args_str else None\n\n        if not command_name:\n            # Show help for all commands\n            lines = [\"Available commands:\"]\n            lines.append(\"=\" * 50)\n            for cmd_name in sorted(self.commands.keys()):\n                cmd_info = self.commands[cmd_name]\n                lines.append(f\"  {cmd_info['help']}\")\n                if cmd_info[\"aliases\"]:\n                    lines.append(f\"    Aliases: {', '.join(cmd_info['aliases'])}\")\n            return \"\\n\".join(lines)\n        else:\n            # Show help for specific command\n            if command_name not in self.alias_to_command:\n                return f\"Unknown command: {command_name}\"\n\n            cmd_name = self.alias_to_command[command_name]\n            cmd_info = self.commands[cmd_name]\n            help_text = cmd_info[\"help\"]\n            if cmd_info[\"aliases\"]:\n                help_text += f\"\\nAliases: {', '.join(cmd_info['aliases'])}\"\n            return help_text\n\n    def _handle_cond_independent(self, args_str: str) -&gt; bool:\n        \"\"\"Handle conditional independence command with special parsing.\"\"\"\n        parts = args_str.split(\"|\")\n        if len(parts) != 2:\n            raise ValueError(\"iscondindependent format: A, B | C, D\")\n        vars_part = [v.strip() for v in parts[0].split(\",\")]\n        cond_part = [v.strip() for v in parts[1].split(\",\")]\n        if len(vars_part) != 2:\n            raise ValueError(\"iscondindependent requires two variables to check\")\n        return self.is_cond_independent(vars_part[0], vars_part[1], cond_part)\n\n    def _handle_conditional_entropy(self, args_str: str) -&gt; float:\n        \"\"\"Handle conditional entropy command with special parsing.\"\"\"\n        parts = args_str.split(\"|\")\n        if (\n            len(parts) != 2\n            or len(parts[0].split(\",\")) != 1\n            or len(parts[1].split(\",\")) != 1\n        ):\n            raise ValueError(\"conditional_entropy format: X | Y\")\n        return self.conditional_entropy(parts[0].strip(), parts[1].strip())\n\n    def marginals(self, n_str: str) -&gt; str:\n        \"\"\"Compute and display marginal probabilities for all n-variable combinations.\"\"\"\n        try:\n            n = int(n_str)\n        except ValueError:\n            raise ValueError(f\"Invalid argument '{n_str}': n must be an integer\")\n\n        if n &lt;= 0:\n            raise ValueError(f\"n must be positive, got {n}\")\n\n        all_vars = list(self.network.variables.keys())\n        num_vars = len(all_vars)\n\n        if n &gt; num_vars:\n            raise ValueError(\n                f\"n={n} exceeds number of variables ({num_vars}) in the network\"\n            )\n\n        from itertools import combinations\n\n        # Get all combinations of n variables\n        var_combinations = list(combinations(all_vars, n))\n\n        if not var_combinations:\n            return \"No variable combinations available.\"\n\n        # Compute marginals for each combination\n        results = []\n        max_prob_width = 0\n\n        for var_combo in var_combinations:\n            # Convert list of variable names to the expected Dict[str, str | None] format\n            query_vars_dict: Dict[str, str | None] = {\n                var_name: None for var_name in var_combo\n            }\n\n            # Compute marginal distribution for this combination\n            marginal = self.inference.variable_elimination(query_vars_dict, {})\n\n            # Get all possible value assignments for these variables\n            var_objects = [self.network.variables[var_name] for var_name in var_combo]\n\n            from itertools import product\n\n            value_assignments = list(product(*(var.domain for var in var_objects)))\n\n            for assignment in value_assignments:\n                # Create probability string representation\n                prob_key = assignment\n                probability = marginal.probabilities.get(prob_key, 0.0)\n\n                # Create variable assignment string with negations for False/No/Off values\n                var_strs = []\n                for i, (var_name, value) in enumerate(zip(var_combo, assignment)):\n                    if value.lower() in [\"false\", \"no\", \"off\"]:\n                        var_strs.append(f\"~{var_name}\")\n                    else:\n                        var_strs.append(var_name)\n\n                prob_str = f\"P({', '.join(var_strs)})\"\n                prob_value = f\"{probability:.6f}\"\n\n                results.append((prob_str, prob_value))\n                max_prob_width = max(max_prob_width, len(prob_str))\n\n        # Format output with aligned columns\n        lines = []\n        for prob_str, prob_value in results:\n            lines.append(f\"{prob_str:&lt;{max_prob_width}} = {prob_value}\")\n\n        return \"\\n\".join(lines)\n\n    def condprobs(self, n_str: str, m_str: str) -&gt; str:\n        \"\"\"Compute and display conditional probabilities P(A|B) for all n-by-m variable combinations.\"\"\"\n        try:\n            n = int(n_str)\n            m = int(m_str)\n        except ValueError:\n            raise ValueError(\n                f\"Invalid arguments: n={n_str} and m={m_str} must be integers\"\n            )\n\n        if n &lt;= 0 or m &lt;= 0:\n            raise ValueError(f\"n and m must be positive, got n={n}, m={m}\")\n\n        all_vars = list(self.network.variables.keys())\n        num_vars = len(all_vars)\n\n        if n + m &gt; num_vars:\n            raise ValueError(\n                f\"n+m={n+m} exceeds number of variables ({num_vars}) in the network\"\n            )\n\n        from itertools import combinations, product\n\n        # Get all combinations of n variables (for the condition part A)\n        condition_var_combinations = list(combinations(all_vars, n))\n\n        # Get all combinations of m variables (for the evidence part B)\n        evidence_var_combinations = list(combinations(all_vars, m))\n\n        if not condition_var_combinations or not evidence_var_combinations:\n            return \"No variable combinations available.\"\n\n        results = []\n        max_prob_width = 0\n\n        # For each combination of condition variables and evidence variables\n        for cond_vars in condition_var_combinations:\n            for evid_vars in evidence_var_combinations:\n\n                # Skip if there's overlap between condition and evidence variables\n                if set(cond_vars) &amp; set(evid_vars):\n                    continue\n\n                # Get variable objects\n                cond_var_objects = [\n                    self.network.variables[var_name] for var_name in cond_vars\n                ]\n                evid_var_objects = [\n                    self.network.variables[var_name] for var_name in evid_vars\n                ]\n\n                # Get all possible value assignments for condition variables\n                cond_value_assignments = list(\n                    product(*(var.domain for var in cond_var_objects))\n                )\n\n                # Get all possible value assignments for evidence variables\n                evid_value_assignments = list(\n                    product(*(var.domain for var in evid_var_objects))\n                )\n\n                # Compute P(A|B) for each combination of values\n                for cond_assignment in cond_value_assignments:\n                    for evid_assignment in evid_value_assignments:\n\n                        # Create evidence dictionary for the inference\n                        evidence = dict(zip(evid_vars, evid_assignment))\n\n                        # Compute P(A|B) using variable elimination\n                        try:\n                            query_vars_dict: Dict[str, str | None] = {\n                                var_name: None for var_name in cond_vars\n                            }\n                            conditional_dist = self.inference.variable_elimination(\n                                query_vars_dict, evidence\n                            )\n\n                            # Get probability for this specific assignment of condition variables\n                            probability = conditional_dist.probabilities.get(\n                                cond_assignment, 0.0\n                            )\n\n                            # Create string representations with negations\n                            cond_strs = []\n                            for var_name, value in zip(cond_vars, cond_assignment):\n                                if value.lower() in [\"false\", \"no\", \"off\"]:\n                                    cond_strs.append(f\"~{var_name}\")\n                                else:\n                                    cond_strs.append(var_name)\n\n                            evid_strs = []\n                            for var_name, value in zip(evid_vars, evid_assignment):\n                                if value.lower() in [\"false\", \"no\", \"off\"]:\n                                    evid_strs.append(f\"~{var_name}\")\n                                else:\n                                    evid_strs.append(var_name)\n\n                            prob_str = (\n                                f\"P({', '.join(cond_strs)} | {', '.join(evid_strs)})\"\n                            )\n                            prob_value = f\"{probability:.6f}\"\n\n                            results.append((prob_str, prob_value))\n                            max_prob_width = max(max_prob_width, len(prob_str))\n\n                        except Exception:\n                            # Handle cases where conditional probability cannot be computed\n                            # (e.g., when evidence has zero probability)\n                            continue\n\n        if not results:\n            return \"No valid conditional probabilities found (may be due to disjoint variable sets or zero evidence probabilities).\"\n\n        # Sort results for consistent output\n        results.sort(key=lambda x: x[0])\n\n        # Format output with aligned columns\n        lines = []\n        for prob_str, prob_value in results:\n            lines.append(f\"{prob_str:&lt;{max_prob_width}} = {prob_value}\")\n\n        return \"\\n\".join(lines)\n\n    def print_cpt(self, variable_name: str) -&gt; str:\n        \"\"\"Prints the CPT for a given variable with proper column alignment.\"\"\"\n        if variable_name not in self.network.factors:\n            return f\"No CPT found for variable '{variable_name}'.\"\n\n        factor = self.network.factors[variable_name]\n        variable = self.network.variables[variable_name]\n        parents = [v for v in factor.variables if v != variable]\n\n        # New format: Child | Parents (comma-separated) | Probability\n        if not parents:\n            # No parents case - just show variable and probability\n            col_names = [variable.name, \"P\"]\n            col_widths = [len(variable.name), 1]\n\n            data_rows = []\n            for val in variable.domain:\n                prob = factor.probabilities.get((val,), 0.0)\n                row_data = [val, f\"{prob:.4f}\"]\n                data_rows.append(row_data)\n        else:\n            # Has parents - new 3-column format\n            col_names = [variable.name, \" \".join(f\"{p.name:&lt;10}\" for p in parents), \"P\"]\n            # col_widths = [len(variable.name), len(\", \".join([p.name for p in parents])), 6]  # Set minimum widths\n\n            col_widths = [\n                len(variable.name),\n                len(col_names[1]),\n                6,\n            ]  # Set minimum widths\n            data_rows = []\n            parent_domains = [p.domain for p in parents]\n            from itertools import product\n\n            parent_combinations = list(product(*parent_domains))\n\n            for val in variable.domain:\n                for p_comb in parent_combinations:\n                    key = (val,) + p_comb\n                    prob = factor.probabilities.get(key, 0.0)\n                    # Format parent values with wider spacing like in the target\n                    parent_values = []\n                    for i, pval in enumerate(p_comb):\n                        if i &lt; len(p_comb) - 1:\n                            sval = pval + \",\"\n                            parent_values.append(f\"{sval:&lt;10}\")\n                        else:\n                            parent_values.append(f\"{pval}\")\n                    parent_str = \" \".join(parent_values)\n                    row_data = [val, parent_str, f\"{prob:.4f}\"]\n                    data_rows.append(row_data)\n\n        # Update column widths based on data\n        for row_data in data_rows:\n            for i, cell in enumerate(row_data):\n                col_widths[i] = max(col_widths[i], len(str(cell)))\n\n        # Build formatted output\n        lines = []\n\n        # Header row\n        header_parts = [f\"{name:&lt;{col_widths[i]}}\" for i, name in enumerate(col_names)]\n        header = \" | \".join(header_parts)\n        lines.append(header)\n\n        # Separator line\n        separator_parts = [\"-\" * col_widths[i] for i in range(len(col_names))]\n        separator = \"-+-\".join(separator_parts)\n        lines.append(separator)\n\n        # Data rows\n        for row_data in data_rows:\n            row_parts = [\n                f\"{str(cell):&lt;{col_widths[i]}}\" for i, cell in enumerate(row_data)\n            ]\n            row = \" | \".join(row_parts)\n            lines.append(row)\n\n        return \"\\n\".join(lines)\n\n    def get_parents(self, variable_name: str) -&gt; Set[str]:\n        \"\"\"Returns the parents of a variable.\"\"\"\n        return self.network.get_parents(variable_name)\n\n    def get_children(self, variable_name: str) -&gt; Set[str]:\n        \"\"\"Returns the children of a variable.\"\"\"\n        return self.network.get_children(variable_name)\n\n    def show_graph(self) -&gt; str:\n        \"\"\"Returns an ASCII representation of the network graph.\"\"\"\n        lines = [\"Bayesian Network Graph:\"]\n        for var, children in self.network.adj.items():\n            if children:\n                lines.append(f\"  {var} -&gt; {{{', '.join(children)}}}\")\n        if not any(self.network.adj.values()):\n            lines.append(\"  (No connections in the graph)\")\n        return \"\\n\".join(lines)\n\n    def is_independent(self, var1_name: str, var2_name: str) -&gt; bool:\n        \"\"\"Checks if two variables are independent.\"\"\"\n        # P(A, B) == P(A) * P(B)\n        p_a = self.inference.variable_elimination({var1_name: None}, {})\n        p_b = self.inference.variable_elimination({var2_name: None}, {})\n        p_ab = self.inference.variable_elimination(\n            {var1_name: None, var2_name: None}, {}\n        )\n\n        var1 = self.network.variables[var1_name]\n        var2 = self.network.variables[var2_name]\n\n        for val1 in var1.domain:\n            for val2 in var2.domain:\n                prob_a = p_a.probabilities.get((val1,), 0.0)\n                prob_b = p_b.probabilities.get((val2,), 0.0)\n\n                # Find correct assignment order in joint probability factor\n                if p_ab.variables[0].name == var1_name:\n                    prob_ab = p_ab.probabilities.get((val1, val2), 0.0)\n                else:\n                    prob_ab = p_ab.probabilities.get((val2, val1), 0.0)\n\n                if not np.isclose(prob_ab, prob_a * prob_b):\n                    return False\n        return True\n\n    def is_cond_independent(\n        self, var1_name: str, var2_name: str, cond_vars: List[str]\n    ) -&gt; bool:\n        \"\"\"Checks if two variables are conditionally independent given other variables.\"\"\"\n        # P(A, B | C) == P(A | C) * P(B | C)\n        cond_evidence_domains = [self.network.variables[v].domain for v in cond_vars]\n        from itertools import product\n\n        for cond_values in product(*cond_evidence_domains):\n            evidence = dict(zip(cond_vars, cond_values))\n\n            p_a_given_c = self.inference.variable_elimination(\n                {var1_name: None}, evidence\n            )\n            p_b_given_c = self.inference.variable_elimination(\n                {var2_name: None}, evidence\n            )\n            p_ab_given_c = self.inference.variable_elimination(\n                {var1_name: None, var2_name: None}, evidence\n            )\n\n            var1 = self.network.variables[var1_name]\n            var2 = self.network.variables[var2_name]\n\n            for val1 in var1.domain:\n                for val2 in var2.domain:\n                    prob_a = p_a_given_c.probabilities.get((val1,), 0.0)\n                    prob_b = p_b_given_c.probabilities.get((val2,), 0.0)\n\n                    if p_ab_given_c.variables[0].name == var1_name:\n                        prob_ab = p_ab_given_c.probabilities.get((val1, val2), 0.0)\n                    else:\n                        prob_ab = p_ab_given_c.probabilities.get((val2, val1), 0.0)\n\n                    if not np.isclose(prob_ab, prob_a * prob_b):\n                        return False\n        return True\n\n    def entropy(self, var_name: str) -&gt; float:\n        \"\"\"Computes the entropy of a variable.\"\"\"\n        p_x = self.inference.variable_elimination({var_name: None}, {})\n        probs = np.array(list(p_x.probabilities.values()))\n        return -np.sum(probs * np.log2(probs))\n\n    def conditional_entropy(self, var_x_name: str, var_y_name: str) -&gt; float:\n        \"\"\"Computes the conditional entropy H(X|Y).\"\"\"\n        p_xy = self.inference.variable_elimination(\n            {var_x_name: None, var_y_name: None}, {}\n        )\n        p_y = self.inference.variable_elimination({var_y_name: None}, {})\n\n        var_x = self.network.variables[var_x_name]\n        var_y = self.network.variables[var_y_name]\n\n        h_x_given_y = 0.0\n        for val_y in var_y.domain:\n            prob_y = p_y.probabilities.get((val_y,), 0.0)\n            if prob_y &gt; 1e-9:\n                h_x_given_y_val = 0.0\n                for val_x in var_x.domain:\n                    if p_xy.variables[0].name == var_x_name:\n                        prob_xy = p_xy.probabilities.get((val_x, val_y), 0.0)\n                    else:\n                        prob_xy = p_xy.probabilities.get((val_y, val_x), 0.0)\n\n                    prob_x_given_y = prob_xy / prob_y\n                    if prob_x_given_y &gt; 1e-9:\n                        h_x_given_y_val -= prob_x_given_y * math.log2(prob_x_given_y)\n                h_x_given_y += prob_y * h_x_given_y_val\n        return h_x_given_y\n\n    def mutual_information(self, var1_name: str, var2_name: str) -&gt; float:\n        \"\"\"Computes the mutual information between two variables.\"\"\"\n        # I(X;Y) = H(X) - H(X|Y)\n        h_x = self.entropy(var1_name)\n        h_x_given_y = self.conditional_entropy(var1_name, var2_name)\n        return h_x - h_x_given_y\n\n    def print_jpt(self) -&gt; str:\n        \"\"\"Computes and prints the full Joint Probability Table with proper column alignment.\"\"\"\n        all_vars = list(self.network.variables.keys())\n        jpt = self.inference.variable_elimination({var: None for var in all_vars}, {})\n\n        # Get variables in their original declaration order\n        ordered_vars = [\n            self.network.variables[var_name] for var_name in self.network.variable_order\n        ]\n\n        # Calculate column widths\n        col_names = [var.name for var in ordered_vars] + [\"P\"]\n        col_widths = [len(name) for name in col_names]\n\n        # Collect all data rows to determine maximum widths\n        data_rows = []\n\n        from itertools import product\n\n        # Generate all possible assignments in the declaration order\n        all_assignments = product(*(var.domain for var in ordered_vars))\n\n        for assignment in all_assignments:\n            # The JPT factor's variables might be in a different order.\n            # We need to map our ordered assignment to the JPT's order.\n            jpt_var_names = [v.name for v in jpt.variables]\n\n            # Create a dictionary for the current assignment based on ordered_vars\n            assignment_dict = {\n                ordered_vars[i].name: assignment[i] for i in range(len(ordered_vars))\n            }\n\n            # Reorder the assignment tuple to match the JPT factor's variable order\n            jpt_assignment_tuple = tuple(\n                assignment_dict[var_name] for var_name in jpt_var_names\n            )\n\n            prob = jpt.probabilities.get(jpt_assignment_tuple, 0.0)\n\n            row_data = list(assignment) + [f\"{prob:.6f}\"]\n            data_rows.append(row_data)\n\n        # Update column widths based on data\n        for row_data in data_rows:\n            for i, cell in enumerate(row_data):\n                col_widths[i] = max(col_widths[i], len(str(cell)))\n\n        # Build formatted output\n        lines = []\n\n        # Header row\n        header_parts = [f\"{name:&lt;{col_widths[i]}}\" for i, name in enumerate(col_names)]\n        header = \" | \".join(header_parts)\n        lines.append(header)\n\n        # Separator line\n        separator_parts = [\"-\" * col_widths[i] for i in range(len(col_names))]\n        separator = \"-+-\".join(separator_parts)\n        lines.append(separator)\n\n        # Data rows\n        for row_data in data_rows:\n            row_parts = [\n                f\"{str(cell):&lt;{col_widths[i]}}\" for i, cell in enumerate(row_data)\n            ]\n            row = \" | \".join(row_parts)\n            lines.append(row)\n\n        return \"\\n\".join(lines)\n\n    def list_variables(self) -&gt; str:\n        \"\"\"Lists all variables and their domains.\"\"\"\n        if not self.network.variables:\n            return \"No variables defined in the network.\"\n\n        # Determine column widths\n        var_width = max(len(var) for var in self.network.variables.keys()) + 2\n        type_width = max(len(\"Boolean\"), len(\"Multival\")) + 2  # Width for Type column\n        states_width = (\n            max(len(\", \".join(var.domain)) for var in self.network.variables.values())\n            + 2\n        )\n\n        header = f\"{'Variable':&lt;{var_width}} | {'Type':&lt;{type_width}} | {'States':&lt;{states_width}}\"\n        separator = \"-\" * (var_width + 3 + type_width + 3 + states_width)\n\n        lines = [header, separator]\n\n        # Add each variable, its type, and its states\n        for var_name, var_obj in sorted(self.network.variables.items()):\n            states = \", \".join(var_obj.domain)\n            var_type = var_obj.var_type\n            lines.append(\n                f\"{var_name:&lt;{var_width}} | {var_type:&lt;{type_width}} | {states:&lt;{states_width}}\"\n            )\n\n        return \"\\n\".join(lines)\n\n    def load_network(self, filename: str) -&gt; str:\n        \"\"\"\n        Load a new Bayesian network from a file.\n\n        Args:\n            filename: Path to the network file (.net)\n\n        Returns:\n            Success message with network details\n\n        Raises:\n            FileNotFoundError: If the file doesn't exist\n            ValueError: If the file cannot be parsed\n        \"\"\"\n        filename = filename.strip()\n\n        # Expand user home directory if needed\n        filename = os.path.expanduser(filename)\n\n        # Check if file exists\n        if not os.path.exists(filename):\n            raise FileNotFoundError(f\"Network file not found: {filename}\")\n\n        try:\n            # Read the file\n            with open(filename, \"r\") as f:\n                network_str = f.read()\n\n            # Parse the network\n            lexer = Lexer(network_str)\n            tokens = lexer.tokenize()\n            parser = Parser(tokens)\n            new_network = parser.parse()\n\n            # Update the network and inference engine\n            self.network = new_network\n            self.inference = Inference(new_network)\n\n            # Notify the REPL to update its references if callback is provided\n            if self.reload_callback:\n                self.reload_callback(new_network)\n\n            # Generate success message\n            num_vars = len(new_network.variables)\n            var_names = \", \".join(sorted(new_network.variables.keys()))\n\n            return (\n                f\"Successfully loaded network from: {filename}\\n\"\n                f\"Variables ({num_vars}): {var_names}\"\n            )\n\n        except (SyntaxError, ValueError) as e:\n            raise ValueError(f\"Error parsing network file '{filename}': {e}\")\n        except Exception as e:\n            raise ValueError(f\"Error loading network file '{filename}': {e}\")\n\n    def _handle_visualize(self, args_str: str) -&gt; str:\n        \"\"\"\n        Handle the visualize command with flexible argument parsing.\n\n        Args:\n            args_str: Arguments string (e.g., \"output.pdf, show_cpt=False, layout=neato\")\n\n        Returns:\n            Success message with output file path\n        \"\"\"\n        # Check if graphviz is available\n        try:\n            from .visualizer import NetworkVisualizer\n        except ImportError:\n            return (\n                \"Error: graphviz package not installed.\\n\"\n                \"Install it with: pip install graphviz\\n\"\n                \"You also need the graphviz system package:\\n\"\n                \"  macOS: brew install graphviz\\n\"\n                \"  Ubuntu/Debian: sudo apt-get install graphviz\\n\"\n                \"  Windows: Download from https://graphviz.org/download/\"\n            )\n\n        # Parse arguments\n        args_str = args_str.strip()\n        if not args_str:\n            return \"Error: Output filename required. Usage: visualize(output.pdf)\"\n\n        parts = [p.strip() for p in args_str.split(\",\")]\n\n        # First argument is always the output file\n        output_file = parts[0]\n\n        # Parse optional arguments\n        format_arg = None\n        show_cpt = True\n        layout = \"dot\"\n        rankdir = \"TB\"\n        page_size = None\n        scale = 1.0\n\n        for part in parts[1:]:\n            if \"=\" in part:\n                key, value = part.split(\"=\", 1)\n                key = key.strip().lower()\n                value = value.strip()\n\n                if key == \"format\":\n                    format_arg = value\n                elif key == \"show_cpt\":\n                    show_cpt = value.lower() in (\"true\", \"1\", \"yes\")\n                elif key == \"layout\":\n                    layout = value\n                elif key == \"rankdir\":\n                    rankdir = value.upper()\n                elif key == \"page_size\":\n                    page_size = value\n                elif key == \"scale\":\n                    try:\n                        scale = float(value)\n                    except ValueError:\n                        return (\n                            f\"Error: Invalid scale value '{value}'. Must be a number.\"\n                        )\n\n        # Determine format from filename extension if not explicitly specified\n        if format_arg is None:\n            if \".\" in output_file:\n                format_arg = output_file.rsplit(\".\", 1)[1].lower()\n                output_file = output_file.rsplit(\".\", 1)[0]\n            else:\n                format_arg = \"pdf\"\n\n        try:\n            visualizer = NetworkVisualizer(self.network)\n            output_path = visualizer.generate_graph(\n                output_file=output_file,\n                format=format_arg,\n                show_cpt=show_cpt,\n                layout=layout,\n                rankdir=rankdir,\n                page_size=page_size,\n                scale=scale,\n            )\n            return f\"Network visualization saved to: {output_path}\"\n\n        except ImportError as e:\n            return f\"Error: {e}\\nMake sure graphviz is installed on your system.\"\n        except ValueError as e:\n            return f\"Error: {e}\"\n        except Exception as e:\n            return f\"Error generating visualization: {e}\"\n</code></pre>"},{"location":"api/commands/#bayescalc.commands.CommandHandler-functions","title":"Functions","text":""},{"location":"api/commands/#bayescalc.commands.CommandHandler.is_command","title":"<code>is_command(command_str)</code>","text":"<p>Check if the given string looks like a command from the command registry.</p> <p>Parameters:</p> Name Type Description Default <code>command_str</code> <code>str</code> <p>The string to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if it matches a known command pattern</p> Source code in <code>src/bayescalc/commands.py</code> <pre><code>def is_command(self, command_str: str) -&gt; bool:\n    \"\"\"\n    Check if the given string looks like a command from the command registry.\n\n    Args:\n        command_str: The string to check\n\n    Returns:\n        bool: True if it matches a known command pattern\n    \"\"\"\n    command_str = command_str.strip()\n\n    # Check if it's a command without arguments\n    if command_str in self.alias_to_command:\n        return True\n\n    # Check if it matches command(args) pattern\n    match = re.match(r\"(\\w+)\\(\", command_str)\n    if match:\n        command = match.group(1)\n        return command in self.alias_to_command\n\n    return False\n</code></pre>"},{"location":"api/commands/#bayescalc.commands.CommandHandler.execute","title":"<code>execute(command_str)</code>","text":"<p>Parses and executes a command using the command registry.</p> Source code in <code>src/bayescalc/commands.py</code> <pre><code>def execute(self, command_str: str):\n    \"\"\"Parses and executes a command using the command registry.\"\"\"\n    command_str = command_str.strip()\n\n    # Handle commands without arguments/parentheses (shortcuts)\n    if command_str in self.alias_to_command:\n        cmd_name = self.alias_to_command[command_str]\n        cmd_info = self.commands[cmd_name]\n        if not cmd_info[\"requires_args\"]:\n            return cmd_info[\"handler\"]()\n        else:\n            raise ValueError(\n                f\"Command '{command_str}' requires arguments. Use: {cmd_info['help']}\"\n            )\n\n    # Parse command with parentheses\n    match = re.match(r\"(\\w+)\\((.*)\\)\", command_str)\n    if not match:\n        raise ValueError(\n            f\"Invalid command format: {command_str}. Use 'help()' to see available commands.\"\n        )\n\n    command = match.group(1)\n    args_str = match.group(2)\n\n    # Look up command in registry\n    if command not in self.alias_to_command:\n        raise ValueError(\n            f\"Unknown command: {command}. Use 'help()' to see available commands.\"\n        )\n\n    cmd_name = self.alias_to_command[command]\n    cmd_info = self.commands[cmd_name]\n\n    # Handle commands that require special parsing\n    if cmd_info[\"special_parsing\"]:\n        return cmd_info[\"handler\"](args_str)\n\n    # Handle commands that don't require arguments\n    if not cmd_info[\"requires_args\"]:\n        if args_str.strip():\n            raise ValueError(\n                f\"Command '{command}' does not take arguments. Use: {cmd_info['help']}\"\n            )\n        return cmd_info[\"handler\"]()\n\n    # Handle regular commands with comma-separated arguments\n    args = [arg.strip() for arg in args_str.split(\",\")] if args_str else []\n\n    # Validate argument count using registry information\n    if cmd_info[\"validate_args\"]:\n        expected_count = cmd_info[\"arg_count\"]\n        if len(args) != expected_count:\n            if expected_count == 1:\n                raise ValueError(\n                    f\"{cmd_name} requires one argument. Use: {cmd_info['help']}\"\n                )\n            elif expected_count == 2:\n                raise ValueError(\n                    f\"{cmd_name} requires two arguments. Use: {cmd_info['help']}\"\n                )\n            else:\n                raise ValueError(\n                    f\"{cmd_name} requires {expected_count} arguments. Use: {cmd_info['help']}\"\n                )\n\n    return cmd_info[\"handler\"](*args)\n</code></pre>"},{"location":"api/commands/#bayescalc.commands.CommandHandler.marginals","title":"<code>marginals(n_str)</code>","text":"<p>Compute and display marginal probabilities for all n-variable combinations.</p> Source code in <code>src/bayescalc/commands.py</code> <pre><code>def marginals(self, n_str: str) -&gt; str:\n    \"\"\"Compute and display marginal probabilities for all n-variable combinations.\"\"\"\n    try:\n        n = int(n_str)\n    except ValueError:\n        raise ValueError(f\"Invalid argument '{n_str}': n must be an integer\")\n\n    if n &lt;= 0:\n        raise ValueError(f\"n must be positive, got {n}\")\n\n    all_vars = list(self.network.variables.keys())\n    num_vars = len(all_vars)\n\n    if n &gt; num_vars:\n        raise ValueError(\n            f\"n={n} exceeds number of variables ({num_vars}) in the network\"\n        )\n\n    from itertools import combinations\n\n    # Get all combinations of n variables\n    var_combinations = list(combinations(all_vars, n))\n\n    if not var_combinations:\n        return \"No variable combinations available.\"\n\n    # Compute marginals for each combination\n    results = []\n    max_prob_width = 0\n\n    for var_combo in var_combinations:\n        # Convert list of variable names to the expected Dict[str, str | None] format\n        query_vars_dict: Dict[str, str | None] = {\n            var_name: None for var_name in var_combo\n        }\n\n        # Compute marginal distribution for this combination\n        marginal = self.inference.variable_elimination(query_vars_dict, {})\n\n        # Get all possible value assignments for these variables\n        var_objects = [self.network.variables[var_name] for var_name in var_combo]\n\n        from itertools import product\n\n        value_assignments = list(product(*(var.domain for var in var_objects)))\n\n        for assignment in value_assignments:\n            # Create probability string representation\n            prob_key = assignment\n            probability = marginal.probabilities.get(prob_key, 0.0)\n\n            # Create variable assignment string with negations for False/No/Off values\n            var_strs = []\n            for i, (var_name, value) in enumerate(zip(var_combo, assignment)):\n                if value.lower() in [\"false\", \"no\", \"off\"]:\n                    var_strs.append(f\"~{var_name}\")\n                else:\n                    var_strs.append(var_name)\n\n            prob_str = f\"P({', '.join(var_strs)})\"\n            prob_value = f\"{probability:.6f}\"\n\n            results.append((prob_str, prob_value))\n            max_prob_width = max(max_prob_width, len(prob_str))\n\n    # Format output with aligned columns\n    lines = []\n    for prob_str, prob_value in results:\n        lines.append(f\"{prob_str:&lt;{max_prob_width}} = {prob_value}\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/commands/#bayescalc.commands.CommandHandler.condprobs","title":"<code>condprobs(n_str, m_str)</code>","text":"<p>Compute and display conditional probabilities P(A|B) for all n-by-m variable combinations.</p> Source code in <code>src/bayescalc/commands.py</code> <pre><code>def condprobs(self, n_str: str, m_str: str) -&gt; str:\n    \"\"\"Compute and display conditional probabilities P(A|B) for all n-by-m variable combinations.\"\"\"\n    try:\n        n = int(n_str)\n        m = int(m_str)\n    except ValueError:\n        raise ValueError(\n            f\"Invalid arguments: n={n_str} and m={m_str} must be integers\"\n        )\n\n    if n &lt;= 0 or m &lt;= 0:\n        raise ValueError(f\"n and m must be positive, got n={n}, m={m}\")\n\n    all_vars = list(self.network.variables.keys())\n    num_vars = len(all_vars)\n\n    if n + m &gt; num_vars:\n        raise ValueError(\n            f\"n+m={n+m} exceeds number of variables ({num_vars}) in the network\"\n        )\n\n    from itertools import combinations, product\n\n    # Get all combinations of n variables (for the condition part A)\n    condition_var_combinations = list(combinations(all_vars, n))\n\n    # Get all combinations of m variables (for the evidence part B)\n    evidence_var_combinations = list(combinations(all_vars, m))\n\n    if not condition_var_combinations or not evidence_var_combinations:\n        return \"No variable combinations available.\"\n\n    results = []\n    max_prob_width = 0\n\n    # For each combination of condition variables and evidence variables\n    for cond_vars in condition_var_combinations:\n        for evid_vars in evidence_var_combinations:\n\n            # Skip if there's overlap between condition and evidence variables\n            if set(cond_vars) &amp; set(evid_vars):\n                continue\n\n            # Get variable objects\n            cond_var_objects = [\n                self.network.variables[var_name] for var_name in cond_vars\n            ]\n            evid_var_objects = [\n                self.network.variables[var_name] for var_name in evid_vars\n            ]\n\n            # Get all possible value assignments for condition variables\n            cond_value_assignments = list(\n                product(*(var.domain for var in cond_var_objects))\n            )\n\n            # Get all possible value assignments for evidence variables\n            evid_value_assignments = list(\n                product(*(var.domain for var in evid_var_objects))\n            )\n\n            # Compute P(A|B) for each combination of values\n            for cond_assignment in cond_value_assignments:\n                for evid_assignment in evid_value_assignments:\n\n                    # Create evidence dictionary for the inference\n                    evidence = dict(zip(evid_vars, evid_assignment))\n\n                    # Compute P(A|B) using variable elimination\n                    try:\n                        query_vars_dict: Dict[str, str | None] = {\n                            var_name: None for var_name in cond_vars\n                        }\n                        conditional_dist = self.inference.variable_elimination(\n                            query_vars_dict, evidence\n                        )\n\n                        # Get probability for this specific assignment of condition variables\n                        probability = conditional_dist.probabilities.get(\n                            cond_assignment, 0.0\n                        )\n\n                        # Create string representations with negations\n                        cond_strs = []\n                        for var_name, value in zip(cond_vars, cond_assignment):\n                            if value.lower() in [\"false\", \"no\", \"off\"]:\n                                cond_strs.append(f\"~{var_name}\")\n                            else:\n                                cond_strs.append(var_name)\n\n                        evid_strs = []\n                        for var_name, value in zip(evid_vars, evid_assignment):\n                            if value.lower() in [\"false\", \"no\", \"off\"]:\n                                evid_strs.append(f\"~{var_name}\")\n                            else:\n                                evid_strs.append(var_name)\n\n                        prob_str = (\n                            f\"P({', '.join(cond_strs)} | {', '.join(evid_strs)})\"\n                        )\n                        prob_value = f\"{probability:.6f}\"\n\n                        results.append((prob_str, prob_value))\n                        max_prob_width = max(max_prob_width, len(prob_str))\n\n                    except Exception:\n                        # Handle cases where conditional probability cannot be computed\n                        # (e.g., when evidence has zero probability)\n                        continue\n\n    if not results:\n        return \"No valid conditional probabilities found (may be due to disjoint variable sets or zero evidence probabilities).\"\n\n    # Sort results for consistent output\n    results.sort(key=lambda x: x[0])\n\n    # Format output with aligned columns\n    lines = []\n    for prob_str, prob_value in results:\n        lines.append(f\"{prob_str:&lt;{max_prob_width}} = {prob_value}\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/commands/#bayescalc.commands.CommandHandler.print_cpt","title":"<code>print_cpt(variable_name)</code>","text":"<p>Prints the CPT for a given variable with proper column alignment.</p> Source code in <code>src/bayescalc/commands.py</code> <pre><code>def print_cpt(self, variable_name: str) -&gt; str:\n    \"\"\"Prints the CPT for a given variable with proper column alignment.\"\"\"\n    if variable_name not in self.network.factors:\n        return f\"No CPT found for variable '{variable_name}'.\"\n\n    factor = self.network.factors[variable_name]\n    variable = self.network.variables[variable_name]\n    parents = [v for v in factor.variables if v != variable]\n\n    # New format: Child | Parents (comma-separated) | Probability\n    if not parents:\n        # No parents case - just show variable and probability\n        col_names = [variable.name, \"P\"]\n        col_widths = [len(variable.name), 1]\n\n        data_rows = []\n        for val in variable.domain:\n            prob = factor.probabilities.get((val,), 0.0)\n            row_data = [val, f\"{prob:.4f}\"]\n            data_rows.append(row_data)\n    else:\n        # Has parents - new 3-column format\n        col_names = [variable.name, \" \".join(f\"{p.name:&lt;10}\" for p in parents), \"P\"]\n        # col_widths = [len(variable.name), len(\", \".join([p.name for p in parents])), 6]  # Set minimum widths\n\n        col_widths = [\n            len(variable.name),\n            len(col_names[1]),\n            6,\n        ]  # Set minimum widths\n        data_rows = []\n        parent_domains = [p.domain for p in parents]\n        from itertools import product\n\n        parent_combinations = list(product(*parent_domains))\n\n        for val in variable.domain:\n            for p_comb in parent_combinations:\n                key = (val,) + p_comb\n                prob = factor.probabilities.get(key, 0.0)\n                # Format parent values with wider spacing like in the target\n                parent_values = []\n                for i, pval in enumerate(p_comb):\n                    if i &lt; len(p_comb) - 1:\n                        sval = pval + \",\"\n                        parent_values.append(f\"{sval:&lt;10}\")\n                    else:\n                        parent_values.append(f\"{pval}\")\n                parent_str = \" \".join(parent_values)\n                row_data = [val, parent_str, f\"{prob:.4f}\"]\n                data_rows.append(row_data)\n\n    # Update column widths based on data\n    for row_data in data_rows:\n        for i, cell in enumerate(row_data):\n            col_widths[i] = max(col_widths[i], len(str(cell)))\n\n    # Build formatted output\n    lines = []\n\n    # Header row\n    header_parts = [f\"{name:&lt;{col_widths[i]}}\" for i, name in enumerate(col_names)]\n    header = \" | \".join(header_parts)\n    lines.append(header)\n\n    # Separator line\n    separator_parts = [\"-\" * col_widths[i] for i in range(len(col_names))]\n    separator = \"-+-\".join(separator_parts)\n    lines.append(separator)\n\n    # Data rows\n    for row_data in data_rows:\n        row_parts = [\n            f\"{str(cell):&lt;{col_widths[i]}}\" for i, cell in enumerate(row_data)\n        ]\n        row = \" | \".join(row_parts)\n        lines.append(row)\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/commands/#bayescalc.commands.CommandHandler.get_parents","title":"<code>get_parents(variable_name)</code>","text":"<p>Returns the parents of a variable.</p> Source code in <code>src/bayescalc/commands.py</code> <pre><code>def get_parents(self, variable_name: str) -&gt; Set[str]:\n    \"\"\"Returns the parents of a variable.\"\"\"\n    return self.network.get_parents(variable_name)\n</code></pre>"},{"location":"api/commands/#bayescalc.commands.CommandHandler.get_children","title":"<code>get_children(variable_name)</code>","text":"<p>Returns the children of a variable.</p> Source code in <code>src/bayescalc/commands.py</code> <pre><code>def get_children(self, variable_name: str) -&gt; Set[str]:\n    \"\"\"Returns the children of a variable.\"\"\"\n    return self.network.get_children(variable_name)\n</code></pre>"},{"location":"api/commands/#bayescalc.commands.CommandHandler.show_graph","title":"<code>show_graph()</code>","text":"<p>Returns an ASCII representation of the network graph.</p> Source code in <code>src/bayescalc/commands.py</code> <pre><code>def show_graph(self) -&gt; str:\n    \"\"\"Returns an ASCII representation of the network graph.\"\"\"\n    lines = [\"Bayesian Network Graph:\"]\n    for var, children in self.network.adj.items():\n        if children:\n            lines.append(f\"  {var} -&gt; {{{', '.join(children)}}}\")\n    if not any(self.network.adj.values()):\n        lines.append(\"  (No connections in the graph)\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/commands/#bayescalc.commands.CommandHandler.is_independent","title":"<code>is_independent(var1_name, var2_name)</code>","text":"<p>Checks if two variables are independent.</p> Source code in <code>src/bayescalc/commands.py</code> <pre><code>def is_independent(self, var1_name: str, var2_name: str) -&gt; bool:\n    \"\"\"Checks if two variables are independent.\"\"\"\n    # P(A, B) == P(A) * P(B)\n    p_a = self.inference.variable_elimination({var1_name: None}, {})\n    p_b = self.inference.variable_elimination({var2_name: None}, {})\n    p_ab = self.inference.variable_elimination(\n        {var1_name: None, var2_name: None}, {}\n    )\n\n    var1 = self.network.variables[var1_name]\n    var2 = self.network.variables[var2_name]\n\n    for val1 in var1.domain:\n        for val2 in var2.domain:\n            prob_a = p_a.probabilities.get((val1,), 0.0)\n            prob_b = p_b.probabilities.get((val2,), 0.0)\n\n            # Find correct assignment order in joint probability factor\n            if p_ab.variables[0].name == var1_name:\n                prob_ab = p_ab.probabilities.get((val1, val2), 0.0)\n            else:\n                prob_ab = p_ab.probabilities.get((val2, val1), 0.0)\n\n            if not np.isclose(prob_ab, prob_a * prob_b):\n                return False\n    return True\n</code></pre>"},{"location":"api/commands/#bayescalc.commands.CommandHandler.is_cond_independent","title":"<code>is_cond_independent(var1_name, var2_name, cond_vars)</code>","text":"<p>Checks if two variables are conditionally independent given other variables.</p> Source code in <code>src/bayescalc/commands.py</code> <pre><code>def is_cond_independent(\n    self, var1_name: str, var2_name: str, cond_vars: List[str]\n) -&gt; bool:\n    \"\"\"Checks if two variables are conditionally independent given other variables.\"\"\"\n    # P(A, B | C) == P(A | C) * P(B | C)\n    cond_evidence_domains = [self.network.variables[v].domain for v in cond_vars]\n    from itertools import product\n\n    for cond_values in product(*cond_evidence_domains):\n        evidence = dict(zip(cond_vars, cond_values))\n\n        p_a_given_c = self.inference.variable_elimination(\n            {var1_name: None}, evidence\n        )\n        p_b_given_c = self.inference.variable_elimination(\n            {var2_name: None}, evidence\n        )\n        p_ab_given_c = self.inference.variable_elimination(\n            {var1_name: None, var2_name: None}, evidence\n        )\n\n        var1 = self.network.variables[var1_name]\n        var2 = self.network.variables[var2_name]\n\n        for val1 in var1.domain:\n            for val2 in var2.domain:\n                prob_a = p_a_given_c.probabilities.get((val1,), 0.0)\n                prob_b = p_b_given_c.probabilities.get((val2,), 0.0)\n\n                if p_ab_given_c.variables[0].name == var1_name:\n                    prob_ab = p_ab_given_c.probabilities.get((val1, val2), 0.0)\n                else:\n                    prob_ab = p_ab_given_c.probabilities.get((val2, val1), 0.0)\n\n                if not np.isclose(prob_ab, prob_a * prob_b):\n                    return False\n    return True\n</code></pre>"},{"location":"api/commands/#bayescalc.commands.CommandHandler.entropy","title":"<code>entropy(var_name)</code>","text":"<p>Computes the entropy of a variable.</p> Source code in <code>src/bayescalc/commands.py</code> <pre><code>def entropy(self, var_name: str) -&gt; float:\n    \"\"\"Computes the entropy of a variable.\"\"\"\n    p_x = self.inference.variable_elimination({var_name: None}, {})\n    probs = np.array(list(p_x.probabilities.values()))\n    return -np.sum(probs * np.log2(probs))\n</code></pre>"},{"location":"api/commands/#bayescalc.commands.CommandHandler.conditional_entropy","title":"<code>conditional_entropy(var_x_name, var_y_name)</code>","text":"<p>Computes the conditional entropy H(X|Y).</p> Source code in <code>src/bayescalc/commands.py</code> <pre><code>def conditional_entropy(self, var_x_name: str, var_y_name: str) -&gt; float:\n    \"\"\"Computes the conditional entropy H(X|Y).\"\"\"\n    p_xy = self.inference.variable_elimination(\n        {var_x_name: None, var_y_name: None}, {}\n    )\n    p_y = self.inference.variable_elimination({var_y_name: None}, {})\n\n    var_x = self.network.variables[var_x_name]\n    var_y = self.network.variables[var_y_name]\n\n    h_x_given_y = 0.0\n    for val_y in var_y.domain:\n        prob_y = p_y.probabilities.get((val_y,), 0.0)\n        if prob_y &gt; 1e-9:\n            h_x_given_y_val = 0.0\n            for val_x in var_x.domain:\n                if p_xy.variables[0].name == var_x_name:\n                    prob_xy = p_xy.probabilities.get((val_x, val_y), 0.0)\n                else:\n                    prob_xy = p_xy.probabilities.get((val_y, val_x), 0.0)\n\n                prob_x_given_y = prob_xy / prob_y\n                if prob_x_given_y &gt; 1e-9:\n                    h_x_given_y_val -= prob_x_given_y * math.log2(prob_x_given_y)\n            h_x_given_y += prob_y * h_x_given_y_val\n    return h_x_given_y\n</code></pre>"},{"location":"api/commands/#bayescalc.commands.CommandHandler.mutual_information","title":"<code>mutual_information(var1_name, var2_name)</code>","text":"<p>Computes the mutual information between two variables.</p> Source code in <code>src/bayescalc/commands.py</code> <pre><code>def mutual_information(self, var1_name: str, var2_name: str) -&gt; float:\n    \"\"\"Computes the mutual information between two variables.\"\"\"\n    # I(X;Y) = H(X) - H(X|Y)\n    h_x = self.entropy(var1_name)\n    h_x_given_y = self.conditional_entropy(var1_name, var2_name)\n    return h_x - h_x_given_y\n</code></pre>"},{"location":"api/commands/#bayescalc.commands.CommandHandler.print_jpt","title":"<code>print_jpt()</code>","text":"<p>Computes and prints the full Joint Probability Table with proper column alignment.</p> Source code in <code>src/bayescalc/commands.py</code> <pre><code>def print_jpt(self) -&gt; str:\n    \"\"\"Computes and prints the full Joint Probability Table with proper column alignment.\"\"\"\n    all_vars = list(self.network.variables.keys())\n    jpt = self.inference.variable_elimination({var: None for var in all_vars}, {})\n\n    # Get variables in their original declaration order\n    ordered_vars = [\n        self.network.variables[var_name] for var_name in self.network.variable_order\n    ]\n\n    # Calculate column widths\n    col_names = [var.name for var in ordered_vars] + [\"P\"]\n    col_widths = [len(name) for name in col_names]\n\n    # Collect all data rows to determine maximum widths\n    data_rows = []\n\n    from itertools import product\n\n    # Generate all possible assignments in the declaration order\n    all_assignments = product(*(var.domain for var in ordered_vars))\n\n    for assignment in all_assignments:\n        # The JPT factor's variables might be in a different order.\n        # We need to map our ordered assignment to the JPT's order.\n        jpt_var_names = [v.name for v in jpt.variables]\n\n        # Create a dictionary for the current assignment based on ordered_vars\n        assignment_dict = {\n            ordered_vars[i].name: assignment[i] for i in range(len(ordered_vars))\n        }\n\n        # Reorder the assignment tuple to match the JPT factor's variable order\n        jpt_assignment_tuple = tuple(\n            assignment_dict[var_name] for var_name in jpt_var_names\n        )\n\n        prob = jpt.probabilities.get(jpt_assignment_tuple, 0.0)\n\n        row_data = list(assignment) + [f\"{prob:.6f}\"]\n        data_rows.append(row_data)\n\n    # Update column widths based on data\n    for row_data in data_rows:\n        for i, cell in enumerate(row_data):\n            col_widths[i] = max(col_widths[i], len(str(cell)))\n\n    # Build formatted output\n    lines = []\n\n    # Header row\n    header_parts = [f\"{name:&lt;{col_widths[i]}}\" for i, name in enumerate(col_names)]\n    header = \" | \".join(header_parts)\n    lines.append(header)\n\n    # Separator line\n    separator_parts = [\"-\" * col_widths[i] for i in range(len(col_names))]\n    separator = \"-+-\".join(separator_parts)\n    lines.append(separator)\n\n    # Data rows\n    for row_data in data_rows:\n        row_parts = [\n            f\"{str(cell):&lt;{col_widths[i]}}\" for i, cell in enumerate(row_data)\n        ]\n        row = \" | \".join(row_parts)\n        lines.append(row)\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/commands/#bayescalc.commands.CommandHandler.list_variables","title":"<code>list_variables()</code>","text":"<p>Lists all variables and their domains.</p> Source code in <code>src/bayescalc/commands.py</code> <pre><code>def list_variables(self) -&gt; str:\n    \"\"\"Lists all variables and their domains.\"\"\"\n    if not self.network.variables:\n        return \"No variables defined in the network.\"\n\n    # Determine column widths\n    var_width = max(len(var) for var in self.network.variables.keys()) + 2\n    type_width = max(len(\"Boolean\"), len(\"Multival\")) + 2  # Width for Type column\n    states_width = (\n        max(len(\", \".join(var.domain)) for var in self.network.variables.values())\n        + 2\n    )\n\n    header = f\"{'Variable':&lt;{var_width}} | {'Type':&lt;{type_width}} | {'States':&lt;{states_width}}\"\n    separator = \"-\" * (var_width + 3 + type_width + 3 + states_width)\n\n    lines = [header, separator]\n\n    # Add each variable, its type, and its states\n    for var_name, var_obj in sorted(self.network.variables.items()):\n        states = \", \".join(var_obj.domain)\n        var_type = var_obj.var_type\n        lines.append(\n            f\"{var_name:&lt;{var_width}} | {var_type:&lt;{type_width}} | {states:&lt;{states_width}}\"\n        )\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/commands/#bayescalc.commands.CommandHandler.load_network","title":"<code>load_network(filename)</code>","text":"<p>Load a new Bayesian network from a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the network file (.net)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message with network details</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> <code>ValueError</code> <p>If the file cannot be parsed</p> Source code in <code>src/bayescalc/commands.py</code> <pre><code>def load_network(self, filename: str) -&gt; str:\n    \"\"\"\n    Load a new Bayesian network from a file.\n\n    Args:\n        filename: Path to the network file (.net)\n\n    Returns:\n        Success message with network details\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        ValueError: If the file cannot be parsed\n    \"\"\"\n    filename = filename.strip()\n\n    # Expand user home directory if needed\n    filename = os.path.expanduser(filename)\n\n    # Check if file exists\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"Network file not found: {filename}\")\n\n    try:\n        # Read the file\n        with open(filename, \"r\") as f:\n            network_str = f.read()\n\n        # Parse the network\n        lexer = Lexer(network_str)\n        tokens = lexer.tokenize()\n        parser = Parser(tokens)\n        new_network = parser.parse()\n\n        # Update the network and inference engine\n        self.network = new_network\n        self.inference = Inference(new_network)\n\n        # Notify the REPL to update its references if callback is provided\n        if self.reload_callback:\n            self.reload_callback(new_network)\n\n        # Generate success message\n        num_vars = len(new_network.variables)\n        var_names = \", \".join(sorted(new_network.variables.keys()))\n\n        return (\n            f\"Successfully loaded network from: {filename}\\n\"\n            f\"Variables ({num_vars}): {var_names}\"\n        )\n\n    except (SyntaxError, ValueError) as e:\n        raise ValueError(f\"Error parsing network file '{filename}': {e}\")\n    except Exception as e:\n        raise ValueError(f\"Error loading network file '{filename}': {e}\")\n</code></pre>"},{"location":"api/completer/","title":"Completer","text":""},{"location":"api/completer/#bayescalc.completer","title":"<code>bayescalc.completer</code>","text":"<p>This module implements the autocompletion logic for the REPL, using the prompt_toolkit library.</p>"},{"location":"api/completer/#bayescalc.completer-classes","title":"Classes","text":""},{"location":"api/expression_parser/","title":"Expression Parser","text":""},{"location":"api/expression_parser/#bayescalc.expression_parser","title":"<code>bayescalc.expression_parser</code>","text":"<p>This module handles parsing and evaluating arithmetic expressions of probability queries.</p>"},{"location":"api/expression_parser/#bayescalc.expression_parser-classes","title":"Classes","text":""},{"location":"api/expression_parser/#bayescalc.expression_parser.ExpressionParser","title":"<code>ExpressionParser</code>","text":"Source code in <code>src/bayescalc/expression_parser.py</code> <pre><code>class ExpressionParser:\n    def __init__(self, query_parser: QueryParser):\n        self.query_parser = query_parser\n\n    def can_evaluate(self, expr_str: str) -&gt; bool:\n        \"\"\"\n        Checks if the given string could potentially be evaluated as a mathematical expression.\n\n        This method returns True if the expression contains:\n        - Probability queries (P(...))\n        - Mathematical operators (+, -, *, /, parentheses)\n        - Mathematical function names (log10, sqrt, exp, sin, cos, tan, log, abs, pow)\n        - Numbers\n\n        Returns:\n            bool: True if the expression could be evaluated, False otherwise\n        \"\"\"\n        expr_str = expr_str.strip()\n\n        # Check for probability queries\n        if \"P(\" in expr_str:\n            return True\n\n        # Check for mathematical operators (but ignore standalone parentheses which are for commands)\n        if any(op in expr_str for op in [\"+\", \"-\", \"*\", \"/\"]):\n            return True\n\n        # Check for mathematical functions\n        math_functions = [\n            \"log10\",\n            \"log\",\n            \"sqrt\",\n            \"exp\",\n            \"sin\",\n            \"cos\",\n            \"tan\",\n            \"abs\",\n            \"pow\",\n        ]\n        for func in math_functions:\n            if func + \"(\" in expr_str:\n                return True\n\n        # Check if it looks like a pure numeric expression (numbers and parentheses)\n        # This handles cases like \"(1 + 2)\" or \"3.14\"\n        if re.match(r\"^[\\d\\s+\\-*/().]+$\", expr_str):\n            return True\n\n        return False\n\n    def evaluate(self, expr_str: str):\n        \"\"\"\n        Evaluates a mathematical expression containing probability queries.\n        e.g., \"P(Rain=True | GrassWet=Yes) / P(Rain=True)\" or \"P(Rain) / P(~Rain)\"\n        Also handles pure mathematical expressions like \"log10(0.5)\" or \"sqrt(2)\"\n        \"\"\"\n        # If it's a single probability query with no operations, just return it directly\n        if (\n            expr_str.startswith(\"P(\")\n            and expr_str.endswith(\")\")\n            and not any(op in expr_str[2:-1] for op in [\"+\", \"-\", \"*\", \"/\", \"(\", \")\"])\n        ):\n            return self.query_parser.parse_and_execute(expr_str)\n\n        # Regex to find all P(...) queries\n        prob_query_pattern = re.compile(r\"P\\([^)]+\\)\")\n\n        # Find all probability queries in the expression\n        prob_queries = prob_query_pattern.findall(expr_str)\n\n        # If there are no probability queries, treat it as a pure mathematical expression\n        if not prob_queries:\n            try:\n                return self._safe_eval(expr_str)\n            except Exception as e:\n                raise ValueError(\n                    f\"Error evaluating mathematical expression '{expr_str}': {str(e)}\"\n                )\n\n        # Create a map of query strings to placeholders to avoid collisions\n        placeholders = {}\n        expr_with_placeholders = expr_str\n\n        # Evaluate each probability query and get its scalar value\n        for i, query in enumerate(prob_queries):\n            placeholder = f\"__PROB_{i}__\"\n            placeholders[placeholder] = query\n            expr_with_placeholders = expr_with_placeholders.replace(query, placeholder)\n\n        # Now evaluate each probability query\n        values = {}\n        for placeholder, query in placeholders.items():\n            try:\n                result = self.query_parser.parse_and_execute(query)\n\n                # Check if we got a single value result\n                if not result.variables and len(result.probabilities) == 1:\n                    # Single value, use it directly\n                    values[placeholder] = list(result.probabilities.values())[0]\n                elif \"=\" in query or \"~\" in query:\n                    # This should have been a single value query like P(Rain=True) or P(~Rain)\n                    # If it wasn't caught by the query parser, something's wrong\n                    raise ValueError(\n                        f\"Expected a scalar value for '{query}', but got a distribution.\"\n                    )\n                else:\n                    # Check if this is a boolean variable with shorthand notation\n                    var_name = query[\n                        2:-1\n                    ].strip()  # Extract just the variable name from P(...)\n                    if (\n                        var_name in self.query_parser.network.variables\n                        and self.query_parser.network.variables[var_name].is_boolean\n                    ):\n                        # For boolean variables, we can convert P(X) to P(X=True) automatically\n                        modified_query = f\"P({var_name}=True)\"\n                        result = self.query_parser.parse_and_execute(modified_query)\n                        if not result.variables and len(result.probabilities) == 1:\n                            values[placeholder] = list(result.probabilities.values())[0]\n                            continue\n\n                    # If we get here, it's a genuinely unresolvable distribution\n                    raise ValueError(\n                        f\"The query '{query}' returns a probability distribution, not a single value. \"\n                        f\"Please specify a value for each variable.\"\n                    )\n\n            except Exception as e:\n                raise ValueError(\n                    f\"Error evaluating probability expression '{query}': {str(e)}\"\n                )\n\n        # Replace the placeholders with the actual numeric values\n        final_expr = expr_with_placeholders\n        for placeholder, value in values.items():\n            final_expr = final_expr.replace(placeholder, str(value))\n\n        # Evaluate the final arithmetic expression in a safe environment\n        try:\n            result = self._safe_eval(final_expr)\n            return result\n        except Exception as e:\n            raise ValueError(f\"Error evaluating expression '{expr_str}': {str(e)}\")\n\n    def _safe_eval(self, expr: str):\n        \"\"\"\n        Safely evaluates a mathematical expression string.\n        \"\"\"\n        # Allowed names in the evaluation context\n        allowed_names: Dict[str, Any] = {\n            \"math\": math,\n            \"abs\": abs,\n            \"pow\": pow,\n            \"sqrt\": math.sqrt,\n            \"log\": math.log,\n            \"log10\": math.log10,\n            \"exp\": math.exp,\n            \"sin\": math.sin,\n            \"cos\": math.cos,\n            \"tan\": math.tan,\n        }\n\n        # Check for any suspicious characters\n        if re.search(r\"[^0-9a-zA-Z_+\\-*/().,\\s]\", expr.replace(\"math.\", \"\")):\n            raise ValueError(f\"Expression contains invalid characters: {expr}\")\n\n        try:\n            # eval is used here, but the expression is sanitized to only contain\n            # numbers, operators, and functions from the allowed_names.\n            return eval(expr, {\"__builtins__\": {}}, allowed_names)\n        except (SyntaxError, NameError, TypeError, ZeroDivisionError) as e:\n            raise ValueError(f\"Invalid mathematical expression: {expr}. Error: {e}\")\n</code></pre>"},{"location":"api/expression_parser/#bayescalc.expression_parser.ExpressionParser-functions","title":"Functions","text":""},{"location":"api/expression_parser/#bayescalc.expression_parser.ExpressionParser.can_evaluate","title":"<code>can_evaluate(expr_str)</code>","text":"<p>Checks if the given string could potentially be evaluated as a mathematical expression.</p> <p>This method returns True if the expression contains: - Probability queries (P(...)) - Mathematical operators (+, -, *, /, parentheses) - Mathematical function names (log10, sqrt, exp, sin, cos, tan, log, abs, pow) - Numbers</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the expression could be evaluated, False otherwise</p> Source code in <code>src/bayescalc/expression_parser.py</code> <pre><code>def can_evaluate(self, expr_str: str) -&gt; bool:\n    \"\"\"\n    Checks if the given string could potentially be evaluated as a mathematical expression.\n\n    This method returns True if the expression contains:\n    - Probability queries (P(...))\n    - Mathematical operators (+, -, *, /, parentheses)\n    - Mathematical function names (log10, sqrt, exp, sin, cos, tan, log, abs, pow)\n    - Numbers\n\n    Returns:\n        bool: True if the expression could be evaluated, False otherwise\n    \"\"\"\n    expr_str = expr_str.strip()\n\n    # Check for probability queries\n    if \"P(\" in expr_str:\n        return True\n\n    # Check for mathematical operators (but ignore standalone parentheses which are for commands)\n    if any(op in expr_str for op in [\"+\", \"-\", \"*\", \"/\"]):\n        return True\n\n    # Check for mathematical functions\n    math_functions = [\n        \"log10\",\n        \"log\",\n        \"sqrt\",\n        \"exp\",\n        \"sin\",\n        \"cos\",\n        \"tan\",\n        \"abs\",\n        \"pow\",\n    ]\n    for func in math_functions:\n        if func + \"(\" in expr_str:\n            return True\n\n    # Check if it looks like a pure numeric expression (numbers and parentheses)\n    # This handles cases like \"(1 + 2)\" or \"3.14\"\n    if re.match(r\"^[\\d\\s+\\-*/().]+$\", expr_str):\n        return True\n\n    return False\n</code></pre>"},{"location":"api/expression_parser/#bayescalc.expression_parser.ExpressionParser.evaluate","title":"<code>evaluate(expr_str)</code>","text":"<p>Evaluates a mathematical expression containing probability queries. e.g., \"P(Rain=True | GrassWet=Yes) / P(Rain=True)\" or \"P(Rain) / P(~Rain)\" Also handles pure mathematical expressions like \"log10(0.5)\" or \"sqrt(2)\"</p> Source code in <code>src/bayescalc/expression_parser.py</code> <pre><code>def evaluate(self, expr_str: str):\n    \"\"\"\n    Evaluates a mathematical expression containing probability queries.\n    e.g., \"P(Rain=True | GrassWet=Yes) / P(Rain=True)\" or \"P(Rain) / P(~Rain)\"\n    Also handles pure mathematical expressions like \"log10(0.5)\" or \"sqrt(2)\"\n    \"\"\"\n    # If it's a single probability query with no operations, just return it directly\n    if (\n        expr_str.startswith(\"P(\")\n        and expr_str.endswith(\")\")\n        and not any(op in expr_str[2:-1] for op in [\"+\", \"-\", \"*\", \"/\", \"(\", \")\"])\n    ):\n        return self.query_parser.parse_and_execute(expr_str)\n\n    # Regex to find all P(...) queries\n    prob_query_pattern = re.compile(r\"P\\([^)]+\\)\")\n\n    # Find all probability queries in the expression\n    prob_queries = prob_query_pattern.findall(expr_str)\n\n    # If there are no probability queries, treat it as a pure mathematical expression\n    if not prob_queries:\n        try:\n            return self._safe_eval(expr_str)\n        except Exception as e:\n            raise ValueError(\n                f\"Error evaluating mathematical expression '{expr_str}': {str(e)}\"\n            )\n\n    # Create a map of query strings to placeholders to avoid collisions\n    placeholders = {}\n    expr_with_placeholders = expr_str\n\n    # Evaluate each probability query and get its scalar value\n    for i, query in enumerate(prob_queries):\n        placeholder = f\"__PROB_{i}__\"\n        placeholders[placeholder] = query\n        expr_with_placeholders = expr_with_placeholders.replace(query, placeholder)\n\n    # Now evaluate each probability query\n    values = {}\n    for placeholder, query in placeholders.items():\n        try:\n            result = self.query_parser.parse_and_execute(query)\n\n            # Check if we got a single value result\n            if not result.variables and len(result.probabilities) == 1:\n                # Single value, use it directly\n                values[placeholder] = list(result.probabilities.values())[0]\n            elif \"=\" in query or \"~\" in query:\n                # This should have been a single value query like P(Rain=True) or P(~Rain)\n                # If it wasn't caught by the query parser, something's wrong\n                raise ValueError(\n                    f\"Expected a scalar value for '{query}', but got a distribution.\"\n                )\n            else:\n                # Check if this is a boolean variable with shorthand notation\n                var_name = query[\n                    2:-1\n                ].strip()  # Extract just the variable name from P(...)\n                if (\n                    var_name in self.query_parser.network.variables\n                    and self.query_parser.network.variables[var_name].is_boolean\n                ):\n                    # For boolean variables, we can convert P(X) to P(X=True) automatically\n                    modified_query = f\"P({var_name}=True)\"\n                    result = self.query_parser.parse_and_execute(modified_query)\n                    if not result.variables and len(result.probabilities) == 1:\n                        values[placeholder] = list(result.probabilities.values())[0]\n                        continue\n\n                # If we get here, it's a genuinely unresolvable distribution\n                raise ValueError(\n                    f\"The query '{query}' returns a probability distribution, not a single value. \"\n                    f\"Please specify a value for each variable.\"\n                )\n\n        except Exception as e:\n            raise ValueError(\n                f\"Error evaluating probability expression '{query}': {str(e)}\"\n            )\n\n    # Replace the placeholders with the actual numeric values\n    final_expr = expr_with_placeholders\n    for placeholder, value in values.items():\n        final_expr = final_expr.replace(placeholder, str(value))\n\n    # Evaluate the final arithmetic expression in a safe environment\n    try:\n        result = self._safe_eval(final_expr)\n        return result\n    except Exception as e:\n        raise ValueError(f\"Error evaluating expression '{expr_str}': {str(e)}\")\n</code></pre>"},{"location":"api/inference/","title":"Inference Engine","text":""},{"location":"api/inference/#bayescalc.inference","title":"<code>bayescalc.inference</code>","text":"<p>Inference algorithms for Bayesian Networks.</p> <p>This module provides implementation of exact inference algorithms for Bayesian networks, specifically the variable elimination algorithm. It allows for computing marginal and conditional probabilities in Bayesian networks by manipulating factors (conditional probability tables) through operations like joining (multiplication) and marginalization (summing out).</p> <p>The main class is Inference, which takes a BayesianNetwork object and provides methods for performing probabilistic inference on that network.</p>"},{"location":"api/inference/#bayescalc.inference--key-components","title":"Key Components:","text":"<ul> <li>Inference: Main class for performing probabilistic inference</li> <li>Factor operations: Joining factors and summing out variables</li> <li>Variable elimination: Algorithm for computing conditional probabilities</li> </ul>"},{"location":"api/inference/#bayescalc.inference--example-usage","title":"Example Usage:","text":"<p>from bayescalc.lexer import Lexer from bayescalc.parser import Parser from bayescalc.inference import Inference</p>"},{"location":"api/inference/#bayescalc.inference--define-and-parse-a-simple-bayesian-network","title":"Define and parse a simple Bayesian network","text":"<p>network_text = ''' ... variable Rain {True, False} ... variable Sprinkler {True, False} ... variable GrassWet {True, False} ... ... Rain { P(True) = 0.2 } ... ... Sprinkler | Rain { ...     P(True | True) = 0.01 ...     P(True | False) = 0.4 ... } ... ... GrassWet | Rain, Sprinkler { ...     P(True | True, True) = 0.99 ...     P(True | True, False) = 0.8 ...     P(True | False, True) = 0.9 ...     P(True | False, False) = 0.0 ... } ... ''' network = Parser(Lexer(network_text).tokenize()).parse()</p>"},{"location":"api/inference/#bayescalc.inference--create-inference-engine-and-perform-a-query","title":"Create inference engine and perform a query","text":"<p>inference = Inference(network) result = inference.variable_elimination({\"Rain\": None}, {\"GrassWet\": \"True\"})</p>"},{"location":"api/inference/#bayescalc.inference--print-the-result-prain-grasswettrue","title":"Print the result: P(Rain | GrassWet=True)","text":"<p>for assignment, prob in result.probabilities.items(): ...     print(f\"P(Rain={assignment[0]} | GrassWet=True) = {prob:.4f}\")</p>"},{"location":"api/inference/#bayescalc.inference-classes","title":"Classes","text":""},{"location":"api/inference/#bayescalc.inference.Inference","title":"<code>Inference</code>","text":"<p>The central class for performing probabilistic inference on Bayesian networks.</p> <p>This class implements algorithms for exact inference in Bayesian networks, particularly the variable elimination algorithm. It provides methods to compute marginal and conditional probabilities by manipulating factors (conditional probability tables) through operations like joining (multiplication) and marginalization (summing out variables).</p> <p>The main workflow with this class is: 1. Create an Inference object with a BayesianNetwork 2. Use variable_elimination() to perform queries on the network</p>"},{"location":"api/inference/#bayescalc.inference.Inference--attributes","title":"Attributes:","text":"<p>network : BayesianNetwork     The Bayesian network on which inference will be performed.</p>"},{"location":"api/inference/#bayescalc.inference.Inference--methods","title":"Methods:","text":"<p>variable_elimination(query_vars, evidence):     Performs inference to compute P(query_vars | evidence) _join_factors(factor1, factor2):     Helper method to multiply two factors _sum_out(factor, var_to_sum_out):     Helper method to marginalize (sum out) a variable from a factor</p>"},{"location":"api/inference/#bayescalc.inference.Inference--examples","title":"Examples:","text":"<p>from bayescalc.lexer import Lexer from bayescalc.parser import Parser from bayescalc.inference import Inference</p> Source code in <code>src/bayescalc/inference.py</code> <pre><code>class Inference:\n    \"\"\"\n    The central class for performing probabilistic inference on Bayesian networks.\n\n    This class implements algorithms for exact inference in Bayesian networks,\n    particularly the variable elimination algorithm. It provides methods to compute\n    marginal and conditional probabilities by manipulating factors (conditional\n    probability tables) through operations like joining (multiplication) and\n    marginalization (summing out variables).\n\n    The main workflow with this class is:\n    1. Create an Inference object with a BayesianNetwork\n    2. Use variable_elimination() to perform queries on the network\n\n    Attributes:\n    -----------\n    network : BayesianNetwork\n        The Bayesian network on which inference will be performed.\n\n    Methods:\n    --------\n    variable_elimination(query_vars, evidence):\n        Performs inference to compute P(query_vars | evidence)\n    _join_factors(factor1, factor2):\n        Helper method to multiply two factors\n    _sum_out(factor, var_to_sum_out):\n        Helper method to marginalize (sum out) a variable from a factor\n\n    Examples:\n    ---------\n    &gt;&gt;&gt; from bayescalc.lexer import Lexer\n    &gt;&gt;&gt; from bayescalc.parser import Parser\n    &gt;&gt;&gt; from bayescalc.inference import Inference\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Parse a Bayesian network\n    &gt;&gt;&gt; network = Parser(Lexer(network_text).tokenize()).parse()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Create inference engine\n    &gt;&gt;&gt; inference = Inference(network)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Compute P(Rain | GrassWet=True)\n    &gt;&gt;&gt; result = inference.variable_elimination({\"Rain\": None}, {\"GrassWet\": \"True\"})\n    &gt;&gt;&gt; print(result.probabilities)\n    \"\"\"\n\n    def __init__(self, network: BayesianNetwork):\n        \"\"\"\n        Initialize an inference engine with a Bayesian network.\n\n        Parameters:\n        -----------\n        network : BayesianNetwork\n            The Bayesian network model on which inference will be performed.\n        \"\"\"\n        self.network = network\n\n    def _join_factors(self, factor1: Factor, factor2: Factor) -&gt; Factor:\n        \"\"\"\n        Joins (multiplies) two factors to create a new combined factor.\n\n        This is a key operation in variable elimination, where factors containing\n        the variable to be eliminated are multiplied together. The result is a factor\n        defined over the union of the variables in the input factors, with probabilities\n        calculated as the product of the corresponding probabilities from the input factors.\n\n        Mathematical definition:\n        For factors f(X) and g(Y), the joined factor h(X,Y) is defined as:\n        h(x,y) = f(x) \u00d7 g(y) for all assignments x to X and y to Y\n\n        Parameters:\n        -----------\n        factor1 : Factor\n            The first factor to join\n        factor2 : Factor\n            The second factor to join\n\n        Returns:\n        --------\n        Factor\n            A new factor representing the product of the input factors\n\n        Example:\n        --------\n        For factor1 representing P(A) and factor2 representing P(B|A):\n        - factor1 might have variables [A] and probabilities {('True',): 0.2, ('False',): 0.8}\n        - factor2 might have variables [B, A] and probabilities\n          {('True', 'True'): 0.7, ('True', 'False'): 0.1, ('False', 'True'): 0.3, ('False', 'False'): 0.9}\n\n        Joining these would create a factor with variables [A, B] and probabilities:\n        {\n            ('True', 'True'): 0.2 * 0.7 = 0.14,\n            ('True', 'False'): 0.2 * 0.3 = 0.06,\n            ('False', 'True'): 0.8 * 0.1 = 0.08,\n            ('False', 'False'): 0.8 * 0.9 = 0.72\n        }\n\n        Note that the resulting factor contains the joint probability distribution P(A,B).\n        \"\"\"\n        # New variables are the union of the variables in the two factors\n        vars1 = set(factor1.variables)\n        vars2 = set(factor2.variables)\n        new_vars_tuple = tuple(vars1.union(vars2))\n\n        new_factor = Factor(new_vars_tuple)\n\n        # Create a mapping from the new variable order to the old orders\n        map1 = [new_vars_tuple.index(v) for v in factor1.variables]\n        map2 = [new_vars_tuple.index(v) for v in factor2.variables]\n\n        # Get the domains for the new set of variables\n        new_domains = [v.domain for v in new_vars_tuple]\n\n        for assignment in product(*new_domains):\n            # Extract the parts of the assignment corresponding to each original factor\n            ass1 = tuple(assignment[i] for i in map1)\n            ass2 = tuple(assignment[i] for i in map2)\n\n            # Multiply the probabilities\n            prob1 = factor1.probabilities.get(ass1, 1.0)\n            prob2 = factor2.probabilities.get(ass2, 1.0)\n            new_factor.probabilities[assignment] = prob1 * prob2\n\n        return new_factor\n\n    def _sum_out(self, factor: Factor, var_to_sum_out: Variable) -&gt; Factor:\n        \"\"\"\n        Sums out (marginalizes) a variable from a factor.\n\n        This operation removes a variable from a factor by summing over all its possible values.\n        It is a fundamental operation in variable elimination, where variables are successively\n        eliminated from the network by summing them out from factors.\n\n        Mathematical definition:\n        For a factor f(X,Y) where X is the variable to sum out, the resulting factor g(Y) is:\n        g(y) = \u2211\u2093 f(x,y) for all assignments y to Y\n\n        Parameters:\n        -----------\n        factor : Factor\n            The factor from which to sum out the variable\n        var_to_sum_out : Variable\n            The variable to be summed out (marginalized)\n\n        Returns:\n        --------\n        Factor\n            A new factor with var_to_sum_out removed, representing the marginal over remaining variables\n\n        Example:\n        --------\n        For a factor representing P(A,B) with variables [A, B] and probabilities:\n        {\n            ('True', 'True'): 0.14,\n            ('True', 'False'): 0.06,\n            ('False', 'True'): 0.08,\n            ('False', 'False'): 0.72\n        }\n\n        Summing out variable A would create a factor with variables [B] and probabilities:\n        {\n            ('True',): 0.14 + 0.08 = 0.22,\n            ('False',): 0.06 + 0.72 = 0.78\n        }\n\n        This represents the marginal probability P(B).\n\n        Note:\n        -----\n        If the variable to sum out is not in the factor, the original factor is returned unchanged.\n        \"\"\"\n        if var_to_sum_out not in factor.variables:\n            return factor\n\n        # New variables are the old variables minus the one to sum out\n        new_vars_list = list(factor.variables)\n        var_index = new_vars_list.index(var_to_sum_out)\n        new_vars_list.remove(var_to_sum_out)\n        new_vars_tuple = tuple(new_vars_list)\n\n        new_factor = Factor(new_vars_tuple)\n\n        # Sum over the values of the variable to be eliminated\n        for old_assignment, prob in factor.probabilities.items():\n            new_assignment = tuple(\n                old_assignment[i] for i in range(len(old_assignment)) if i != var_index\n            )\n            new_factor.probabilities[new_assignment] = (\n                new_factor.probabilities.get(new_assignment, 0.0) + prob\n            )\n\n        return new_factor\n\n    def variable_elimination(\n        self, query_vars: Dict[str, str | None], evidence: Dict[str, str]\n    ) -&gt; Factor:\n        \"\"\"\n        Performs Variable Elimination to compute P(query_vars | evidence).\n\n        Variable elimination is an exact inference algorithm for Bayesian networks that\n        efficiently computes marginal and conditional probabilities. It works by successively\n        eliminating variables from the network through a process of factor operations.\n\n        The algorithm follows these steps:\n        1. Start with all factors (CPTs) in the network\n        2. Reduce factors by incorporating observed evidence\n        3. Determine elimination order using a heuristic\n        4. For each non-query, non-evidence variable:\n           a. Collect all factors containing the variable\n           b. Join (multiply) these factors together\n           c. Sum out the variable from the joined factor\n           d. Replace the original factors with the new factor\n        5. Join all remaining factors\n        6. Normalize the result to get conditional probabilities\n\n        Parameters:\n        -----------\n        query_vars : Dict[str, str]\n            Variables to query. Keys are variable names and values are either specific\n            values to query (if not None) or None to query all values for that variable.\n\n        evidence : Dict[str, str]\n            Observed evidence. Keys are variable names and values are their observed states.\n\n        Returns:\n        --------\n        Factor\n            A Factor object containing the probability distribution P(query_vars | evidence).\n\n        Examples:\n        ---------\n        &gt;&gt;&gt; # Query: P(Rain | GrassWet=True)\n        &gt;&gt;&gt; inference.variable_elimination({\"Rain\": None}, {\"GrassWet\": \"True\"})\n\n        &gt;&gt;&gt; # Query: P(Sprinkler=True | Rain=False, GrassWet=True)\n        &gt;&gt;&gt; inference.variable_elimination({\"Sprinkler\": \"True\"}, {\"Rain\": \"False\", \"GrassWet\": \"True\"})\n\n        Elimination Process Example:\n        ---------------------------\n        For a simple Rain-Sprinkler-GrassWet network to compute P(Rain | GrassWet=True):\n\n        1. Start with factors: P(Rain), P(Sprinkler|Rain), P(GrassWet|Rain,Sprinkler)\n        2. Reduce P(GrassWet|Rain,Sprinkler) by evidence GrassWet=True to get P'(Rain,Sprinkler)\n        3. Choose to eliminate Sprinkler next (non-query, non-evidence)\n        4. Multiply P(Sprinkler|Rain) \u00d7 P'(Rain,Sprinkler) to get joint factor P''(Rain,Sprinkler)\n        5. Sum out Sprinkler: \u2211\u209b P''(Rain,s) to get P'''(Rain)\n        6. Multiply with P(Rain) to get unnormalized P(Rain|GrassWet=True)\n        7. Normalize to get final P(Rain|GrassWet=True)\n\n        Notes:\n        ------\n        - The algorithm handles both standard notation (\"True\"/\"False\") and shorthand (\"T\"/\"F\")\n        - Performance depends heavily on the elimination order, which is determined by a heuristic\n        - Time complexity is exponential in the worst case, but practical for most networks\n        \"\"\"\n        # 1. Start with all factors\n        factors = list(self.network.factors.values())\n\n        # 2. Reduce factors by evidence\n        reduced_factors = []\n        for f in factors:\n            if any(v.name in evidence for v in f.variables):\n                # Initialize variables outside the loop to avoid UnboundLocalError\n                new_vars_temp: list[Variable] = []\n                new_probs = {}\n\n                var_map = {v.name: i for i, v in enumerate(f.variables)}\n\n                # Filter assignments that are consistent with evidence\n                for assignment, prob in f.probabilities.items():\n                    consistent = True\n                    for var_name, value in evidence.items():\n                        if var_name in var_map:\n                            # Handle both \"T\"/\"F\" and \"True\"/\"False\" by normalizing both sides\n                            assignment_value = assignment[var_map[var_name]]\n                            # Normalize assignment and evidence values\n                            if assignment_value == \"T\" or assignment_value == \"True\":\n                                normalized_assignment = \"True\"\n                            elif assignment_value == \"F\" or assignment_value == \"False\":\n                                normalized_assignment = \"False\"\n                            else:\n                                normalized_assignment = assignment_value\n\n                            if value == \"T\" or value == \"True\":\n                                normalized_evidence = \"True\"\n                            elif value == \"F\" or value == \"False\":\n                                normalized_evidence = \"False\"\n                            else:\n                                normalized_evidence = value\n\n                            if normalized_assignment != normalized_evidence:\n                                consistent = False\n                                break\n                    if consistent:\n                        new_assignment = []\n                        new_vars_temp = (\n                            []\n                        )  # Reinitialize for each consistent assignment\n                        for i, v in enumerate(f.variables):\n                            if v.name not in evidence:\n                                new_assignment.append(assignment[i])\n                                if v not in new_vars_temp:\n                                    new_vars_temp.append(v)\n                        new_probs[tuple(new_assignment)] = prob\n\n                if new_vars_temp:  # Only create a factor if we have variables left\n                    reduced_factors.append(Factor(tuple(new_vars_temp), new_probs))\n            else:\n                reduced_factors.append(f)\n\n        factors = reduced_factors\n\n        # 3. Determine elimination order (simple heuristic: least complex first)\n        all_vars = set(v.name for v in self.network.variables.values())\n        vars_to_eliminate = all_vars - set(query_vars) - set(evidence.keys())\n\n        # A simple heuristic for ordering: eliminate variables that appear in fewest factors\n        elimination_order = sorted(\n            vars_to_eliminate,\n            key=lambda var: sum(\n                1 for f in factors if self.network.variables[var] in f.variables\n            ),\n        )\n\n        # 4. Eliminate variables\n        for var_name in elimination_order:\n            var_to_eliminate = self.network.variables[var_name]\n\n            # Find all factors containing the variable\n            factors_with_var = [f for f in factors if var_to_eliminate in f.variables]\n            factors_without_var = [\n                f for f in factors if var_to_eliminate not in f.variables\n            ]\n\n            if not factors_with_var:\n                continue\n\n            # Join all factors with the variable\n            joined_factor = factors_with_var[0]\n            for i in range(1, len(factors_with_var)):\n                joined_factor = self._join_factors(joined_factor, factors_with_var[i])\n\n            # Sum out the variable\n            new_factor = self._sum_out(joined_factor, var_to_eliminate)\n\n            # Update the list of factors\n            factors = factors_without_var + [new_factor]\n\n        # 5. Join remaining factors\n        result_factor = factors[0]\n        for i in range(1, len(factors)):\n            result_factor = self._join_factors(result_factor, factors[i])\n\n        # 6. Normalize the result\n        total_prob = sum(result_factor.probabilities.values())\n        if total_prob &gt; 1e-9:  # Avoid division by zero\n            for assignment, prob in result_factor.probabilities.items():\n                result_factor.probabilities[assignment] = prob / total_prob\n\n        return result_factor\n</code></pre>"},{"location":"api/inference/#bayescalc.inference.Inference--parse-a-bayesian-network","title":"Parse a Bayesian network","text":"<p>network = Parser(Lexer(network_text).tokenize()).parse()</p>"},{"location":"api/inference/#bayescalc.inference.Inference--create-inference-engine","title":"Create inference engine","text":"<p>inference = Inference(network)</p>"},{"location":"api/inference/#bayescalc.inference.Inference--compute-prain-grasswettrue","title":"Compute P(Rain | GrassWet=True)","text":"<p>result = inference.variable_elimination({\"Rain\": None}, {\"GrassWet\": \"True\"}) print(result.probabilities)</p>"},{"location":"api/inference/#bayescalc.inference.Inference-functions","title":"Functions","text":""},{"location":"api/inference/#bayescalc.inference.Inference.__init__","title":"<code>__init__(network)</code>","text":"<p>Initialize an inference engine with a Bayesian network.</p>"},{"location":"api/inference/#bayescalc.inference.Inference.__init__--parameters","title":"Parameters:","text":"<p>network : BayesianNetwork     The Bayesian network model on which inference will be performed.</p> Source code in <code>src/bayescalc/inference.py</code> <pre><code>def __init__(self, network: BayesianNetwork):\n    \"\"\"\n    Initialize an inference engine with a Bayesian network.\n\n    Parameters:\n    -----------\n    network : BayesianNetwork\n        The Bayesian network model on which inference will be performed.\n    \"\"\"\n    self.network = network\n</code></pre>"},{"location":"api/inference/#bayescalc.inference.Inference.variable_elimination","title":"<code>variable_elimination(query_vars, evidence)</code>","text":"<p>Performs Variable Elimination to compute P(query_vars | evidence).</p> <p>Variable elimination is an exact inference algorithm for Bayesian networks that efficiently computes marginal and conditional probabilities. It works by successively eliminating variables from the network through a process of factor operations.</p> <p>The algorithm follows these steps: 1. Start with all factors (CPTs) in the network 2. Reduce factors by incorporating observed evidence 3. Determine elimination order using a heuristic 4. For each non-query, non-evidence variable:    a. Collect all factors containing the variable    b. Join (multiply) these factors together    c. Sum out the variable from the joined factor    d. Replace the original factors with the new factor 5. Join all remaining factors 6. Normalize the result to get conditional probabilities</p>"},{"location":"api/inference/#bayescalc.inference.Inference.variable_elimination--parameters","title":"Parameters:","text":"<p>query_vars : Dict[str, str]     Variables to query. Keys are variable names and values are either specific     values to query (if not None) or None to query all values for that variable.</p> Dict[str, str] <p>Observed evidence. Keys are variable names and values are their observed states.</p>"},{"location":"api/inference/#bayescalc.inference.Inference.variable_elimination--returns","title":"Returns:","text":"<p>Factor     A Factor object containing the probability distribution P(query_vars | evidence).</p>"},{"location":"api/inference/#bayescalc.inference.Inference.variable_elimination--examples","title":"Examples:","text":""},{"location":"api/inference/#bayescalc.inference.Inference.variable_elimination--query-prain-grasswettrue","title":"Query: P(Rain | GrassWet=True)","text":"<p>inference.variable_elimination({\"Rain\": None}, {\"GrassWet\": \"True\"})</p>"},{"location":"api/inference/#bayescalc.inference.Inference.variable_elimination--query-psprinklertrue-rainfalse-grasswettrue","title":"Query: P(Sprinkler=True | Rain=False, GrassWet=True)","text":"<p>inference.variable_elimination({\"Sprinkler\": \"True\"}, {\"Rain\": \"False\", \"GrassWet\": \"True\"})</p>"},{"location":"api/inference/#bayescalc.inference.Inference.variable_elimination--elimination-process-example","title":"Elimination Process Example:","text":"<p>For a simple Rain-Sprinkler-GrassWet network to compute P(Rain | GrassWet=True):</p> <ol> <li>Start with factors: P(Rain), P(Sprinkler|Rain), P(GrassWet|Rain,Sprinkler)</li> <li>Reduce P(GrassWet|Rain,Sprinkler) by evidence GrassWet=True to get P'(Rain,Sprinkler)</li> <li>Choose to eliminate Sprinkler next (non-query, non-evidence)</li> <li>Multiply P(Sprinkler|Rain) \u00d7 P'(Rain,Sprinkler) to get joint factor P''(Rain,Sprinkler)</li> <li>Sum out Sprinkler: \u2211\u209b P''(Rain,s) to get P'''(Rain)</li> <li>Multiply with P(Rain) to get unnormalized P(Rain|GrassWet=True)</li> <li>Normalize to get final P(Rain|GrassWet=True)</li> </ol>"},{"location":"api/inference/#bayescalc.inference.Inference.variable_elimination--notes","title":"Notes:","text":"<ul> <li>The algorithm handles both standard notation (\"True\"/\"False\") and shorthand (\"T\"/\"F\")</li> <li>Performance depends heavily on the elimination order, which is determined by a heuristic</li> <li>Time complexity is exponential in the worst case, but practical for most networks</li> </ul> Source code in <code>src/bayescalc/inference.py</code> <pre><code>def variable_elimination(\n    self, query_vars: Dict[str, str | None], evidence: Dict[str, str]\n) -&gt; Factor:\n    \"\"\"\n    Performs Variable Elimination to compute P(query_vars | evidence).\n\n    Variable elimination is an exact inference algorithm for Bayesian networks that\n    efficiently computes marginal and conditional probabilities. It works by successively\n    eliminating variables from the network through a process of factor operations.\n\n    The algorithm follows these steps:\n    1. Start with all factors (CPTs) in the network\n    2. Reduce factors by incorporating observed evidence\n    3. Determine elimination order using a heuristic\n    4. For each non-query, non-evidence variable:\n       a. Collect all factors containing the variable\n       b. Join (multiply) these factors together\n       c. Sum out the variable from the joined factor\n       d. Replace the original factors with the new factor\n    5. Join all remaining factors\n    6. Normalize the result to get conditional probabilities\n\n    Parameters:\n    -----------\n    query_vars : Dict[str, str]\n        Variables to query. Keys are variable names and values are either specific\n        values to query (if not None) or None to query all values for that variable.\n\n    evidence : Dict[str, str]\n        Observed evidence. Keys are variable names and values are their observed states.\n\n    Returns:\n    --------\n    Factor\n        A Factor object containing the probability distribution P(query_vars | evidence).\n\n    Examples:\n    ---------\n    &gt;&gt;&gt; # Query: P(Rain | GrassWet=True)\n    &gt;&gt;&gt; inference.variable_elimination({\"Rain\": None}, {\"GrassWet\": \"True\"})\n\n    &gt;&gt;&gt; # Query: P(Sprinkler=True | Rain=False, GrassWet=True)\n    &gt;&gt;&gt; inference.variable_elimination({\"Sprinkler\": \"True\"}, {\"Rain\": \"False\", \"GrassWet\": \"True\"})\n\n    Elimination Process Example:\n    ---------------------------\n    For a simple Rain-Sprinkler-GrassWet network to compute P(Rain | GrassWet=True):\n\n    1. Start with factors: P(Rain), P(Sprinkler|Rain), P(GrassWet|Rain,Sprinkler)\n    2. Reduce P(GrassWet|Rain,Sprinkler) by evidence GrassWet=True to get P'(Rain,Sprinkler)\n    3. Choose to eliminate Sprinkler next (non-query, non-evidence)\n    4. Multiply P(Sprinkler|Rain) \u00d7 P'(Rain,Sprinkler) to get joint factor P''(Rain,Sprinkler)\n    5. Sum out Sprinkler: \u2211\u209b P''(Rain,s) to get P'''(Rain)\n    6. Multiply with P(Rain) to get unnormalized P(Rain|GrassWet=True)\n    7. Normalize to get final P(Rain|GrassWet=True)\n\n    Notes:\n    ------\n    - The algorithm handles both standard notation (\"True\"/\"False\") and shorthand (\"T\"/\"F\")\n    - Performance depends heavily on the elimination order, which is determined by a heuristic\n    - Time complexity is exponential in the worst case, but practical for most networks\n    \"\"\"\n    # 1. Start with all factors\n    factors = list(self.network.factors.values())\n\n    # 2. Reduce factors by evidence\n    reduced_factors = []\n    for f in factors:\n        if any(v.name in evidence for v in f.variables):\n            # Initialize variables outside the loop to avoid UnboundLocalError\n            new_vars_temp: list[Variable] = []\n            new_probs = {}\n\n            var_map = {v.name: i for i, v in enumerate(f.variables)}\n\n            # Filter assignments that are consistent with evidence\n            for assignment, prob in f.probabilities.items():\n                consistent = True\n                for var_name, value in evidence.items():\n                    if var_name in var_map:\n                        # Handle both \"T\"/\"F\" and \"True\"/\"False\" by normalizing both sides\n                        assignment_value = assignment[var_map[var_name]]\n                        # Normalize assignment and evidence values\n                        if assignment_value == \"T\" or assignment_value == \"True\":\n                            normalized_assignment = \"True\"\n                        elif assignment_value == \"F\" or assignment_value == \"False\":\n                            normalized_assignment = \"False\"\n                        else:\n                            normalized_assignment = assignment_value\n\n                        if value == \"T\" or value == \"True\":\n                            normalized_evidence = \"True\"\n                        elif value == \"F\" or value == \"False\":\n                            normalized_evidence = \"False\"\n                        else:\n                            normalized_evidence = value\n\n                        if normalized_assignment != normalized_evidence:\n                            consistent = False\n                            break\n                if consistent:\n                    new_assignment = []\n                    new_vars_temp = (\n                        []\n                    )  # Reinitialize for each consistent assignment\n                    for i, v in enumerate(f.variables):\n                        if v.name not in evidence:\n                            new_assignment.append(assignment[i])\n                            if v not in new_vars_temp:\n                                new_vars_temp.append(v)\n                    new_probs[tuple(new_assignment)] = prob\n\n            if new_vars_temp:  # Only create a factor if we have variables left\n                reduced_factors.append(Factor(tuple(new_vars_temp), new_probs))\n        else:\n            reduced_factors.append(f)\n\n    factors = reduced_factors\n\n    # 3. Determine elimination order (simple heuristic: least complex first)\n    all_vars = set(v.name for v in self.network.variables.values())\n    vars_to_eliminate = all_vars - set(query_vars) - set(evidence.keys())\n\n    # A simple heuristic for ordering: eliminate variables that appear in fewest factors\n    elimination_order = sorted(\n        vars_to_eliminate,\n        key=lambda var: sum(\n            1 for f in factors if self.network.variables[var] in f.variables\n        ),\n    )\n\n    # 4. Eliminate variables\n    for var_name in elimination_order:\n        var_to_eliminate = self.network.variables[var_name]\n\n        # Find all factors containing the variable\n        factors_with_var = [f for f in factors if var_to_eliminate in f.variables]\n        factors_without_var = [\n            f for f in factors if var_to_eliminate not in f.variables\n        ]\n\n        if not factors_with_var:\n            continue\n\n        # Join all factors with the variable\n        joined_factor = factors_with_var[0]\n        for i in range(1, len(factors_with_var)):\n            joined_factor = self._join_factors(joined_factor, factors_with_var[i])\n\n        # Sum out the variable\n        new_factor = self._sum_out(joined_factor, var_to_eliminate)\n\n        # Update the list of factors\n        factors = factors_without_var + [new_factor]\n\n    # 5. Join remaining factors\n    result_factor = factors[0]\n    for i in range(1, len(factors)):\n        result_factor = self._join_factors(result_factor, factors[i])\n\n    # 6. Normalize the result\n    total_prob = sum(result_factor.probabilities.values())\n    if total_prob &gt; 1e-9:  # Avoid division by zero\n        for assignment, prob in result_factor.probabilities.items():\n            result_factor.probabilities[assignment] = prob / total_prob\n\n    return result_factor\n</code></pre>"},{"location":"api/lexer/","title":"Lexer","text":""},{"location":"api/lexer/#bayescalc.lexer","title":"<code>bayescalc.lexer</code>","text":"<p>This module implements the lexer for the Bayesian Network input format.</p>"},{"location":"api/network_model/","title":"Network Model","text":""},{"location":"api/network_model/#bayescalc.network_model","title":"<code>bayescalc.network_model</code>","text":"<p>This module defines the core data structures for the Bayesian Network.</p>"},{"location":"api/network_model/#bayescalc.network_model-classes","title":"Classes","text":""},{"location":"api/network_model/#bayescalc.network_model.Variable","title":"<code>Variable</code>  <code>dataclass</code>","text":"<p>Represents a random variable.</p> Source code in <code>src/bayescalc/network_model.py</code> <pre><code>@dataclass(frozen=True)\nclass Variable:\n    \"\"\"Represents a random variable.\"\"\"\n\n    name: str\n    domain: Tuple[str, ...]\n\n    def __repr__(self):\n        return f\"Variable({self.name}, {self.domain})\"\n\n    @property\n    def is_boolean(self) -&gt; bool:\n        \"\"\"Returns True if this is a boolean variable (domain includes True/False or T/F).\"\"\"\n        if len(self.domain) != 2:\n            return False\n\n        # Check for various boolean representations\n        true_values = {\"True\", \"T\"}\n        false_values = {\"False\", \"F\"}\n\n        has_true = any(val in true_values for val in self.domain)\n        has_false = any(val in false_values for val in self.domain)\n\n        return has_true and has_false\n\n    @property\n    def var_type(self) -&gt; str:\n        \"\"\"Returns the type of the variable as a string: 'Boolean' or 'Multival'.\"\"\"\n        return \"Boolean\" if self.is_boolean else \"Multival\"\n</code></pre>"},{"location":"api/network_model/#bayescalc.network_model.Variable-attributes","title":"Attributes","text":""},{"location":"api/network_model/#bayescalc.network_model.Variable.is_boolean","title":"<code>is_boolean</code>  <code>property</code>","text":"<p>Returns True if this is a boolean variable (domain includes True/False or T/F).</p>"},{"location":"api/network_model/#bayescalc.network_model.Variable.var_type","title":"<code>var_type</code>  <code>property</code>","text":"<p>Returns the type of the variable as a string: 'Boolean' or 'Multival'.</p>"},{"location":"api/network_model/#bayescalc.network_model.Factor","title":"<code>Factor</code>  <code>dataclass</code>","text":"<p>Represents a factor (e.g., a CPT) in the network.</p> Source code in <code>src/bayescalc/network_model.py</code> <pre><code>@dataclass\nclass Factor:\n    \"\"\"Represents a factor (e.g., a CPT) in the network.\"\"\"\n\n    variables: Tuple[Variable, ...]\n    probabilities: Dict[Tuple[str, ...], float] = field(default_factory=dict)\n    name: str | None = None\n\n    def __repr__(self):\n        if self.name:\n            # For single probability results, we want a clean output\n            if not self.variables and len(self.probabilities) == 1:\n                prob = list(self.probabilities.values())[0]\n                return f\"{self.name} = {prob:.4f}\"\n            return self.name\n        return f\"Factor({[v.name for v in self.variables]})\"\n</code></pre>"},{"location":"api/network_model/#bayescalc.network_model.BayesianNetwork","title":"<code>BayesianNetwork</code>","text":"<p>Represents a Bayesian Network.</p> Source code in <code>src/bayescalc/network_model.py</code> <pre><code>class BayesianNetwork:\n    \"\"\"Represents a Bayesian Network.\"\"\"\n\n    def __init__(self):\n        self.variables: Dict[str, Variable] = {}\n        self.variable_order: List[str] = []\n        self.factors: Dict[str, Factor] = {}\n        self.adj: Dict[str, Set[str]] = {}\n        self.rev_adj: Dict[str, Set[str]] = {}\n\n    def add_variable(self, name: str, domain: Tuple[str, ...]):\n        \"\"\"Adds a variable to the network.\"\"\"\n        if name in self.variables:\n            raise ValueError(f\"Variable '{name}' already exists.\")\n        self.variables[name] = Variable(name, domain)\n        self.variable_order.append(name)\n        self.adj[name] = set()\n        self.rev_adj[name] = set()\n\n    def add_factor(\n        self,\n        variable_name: str,\n        parent_names: List[str],\n        cpt_entries: Dict[Tuple[str, ...], float],\n    ):\n        \"\"\"Adds a factor (CPT) to the network.\"\"\"\n        if variable_name not in self.variables:\n            raise ValueError(f\"Variable '{variable_name}' not found.\")\n\n        variable = self.variables[variable_name]\n        parents = [self.variables[p] for p in parent_names]\n\n        factor_variables = (variable,) + tuple(parents)\n        factor = Factor(factor_variables)\n\n        # Validate and auto-complete CPT\n        self._validate_and_complete_cpt(factor, cpt_entries, variable, parents)\n\n        self.factors[variable_name] = factor\n\n        for p in parent_names:\n            self.adj[p].add(variable_name)\n            self.rev_adj[variable_name].add(p)\n\n    def _validate_and_complete_cpt(\n        self,\n        factor: Factor,\n        cpt_entries: Dict[Tuple[str, ...], float],\n        variable: Variable,\n        parents: List[Variable],\n    ):\n        \"\"\"Validates and auto-completes the CPT entries.\"\"\"\n        if not parents:\n            # Prior probability\n            total_prob = 0.0\n            for val in variable.domain:\n                if (val,) in cpt_entries:\n                    total_prob += cpt_entries[(val,)]\n                    factor.probabilities[(val,)] = cpt_entries[(val,)]\n\n            if len(cpt_entries) &lt; len(variable.domain):\n                # Auto-complete\n                if len(variable.domain) - len(cpt_entries) == 1:\n                    missing_val = [\n                        v for v in variable.domain if (v,) not in cpt_entries\n                    ][0]\n                    factor.probabilities[(missing_val,)] = 1.0 - total_prob\n                else:\n                    raise ValueError(\n                        f\"Ambiguous auto-completion for '{variable.name}'. Please specify more entries.\"\n                    )\n\n            if abs(sum(factor.probabilities.values()) - 1.0) &gt; 1e-6:\n                raise ValueError(\n                    f\"Probabilities for '{variable.name}' do not sum to 1.\"\n                )\n        else:\n            # Conditional probability\n            parent_domains = [p.domain for p in parents]\n            from itertools import product\n\n            parent_combinations = list(product(*parent_domains))\n\n            for p_comb in parent_combinations:\n                total_prob = 0.0\n\n                for val in variable.domain:\n                    key = (val,) + p_comb\n                    if key in cpt_entries:\n                        total_prob += cpt_entries[key]\n                        factor.probabilities[key] = cpt_entries[key]\n\n                if len([k for k in cpt_entries if k[1:] == p_comb]) &lt; len(\n                    variable.domain\n                ):\n                    # Auto-complete\n                    if (\n                        len(variable.domain)\n                        - len([k for k in cpt_entries if k[1:] == p_comb])\n                        == 1\n                    ):\n                        missing_val = [\n                            v\n                            for v in variable.domain\n                            if (v,) + p_comb not in cpt_entries\n                        ][0]\n                        factor.probabilities[(missing_val,) + p_comb] = 1.0 - total_prob\n                    else:\n                        raise ValueError(\n                            f\"Ambiguous auto-completion for '{variable.name}' given {p_comb}. Please specify more entries.\"\n                        )\n\n                if (\n                    abs(\n                        sum(\n                            factor.probabilities[(v,) + p_comb] for v in variable.domain\n                        )\n                        - 1.0\n                    )\n                    &gt; 1e-6\n                ):\n                    raise ValueError(\n                        f\"Probabilities for '{variable.name}' given {p_comb} do not sum to 1.\"\n                    )\n\n    def get_parents(self, variable_name: str) -&gt; Set[str]:\n        \"\"\"Returns the parents of a variable.\"\"\"\n        return self.rev_adj.get(variable_name, set())\n\n    def get_children(self, variable_name: str) -&gt; Set[str]:\n        \"\"\"Returns the children of a variable.\"\"\"\n        return self.adj.get(variable_name, set())\n\n    def __repr__(self):\n        return f\"BayesianNetwork(variables={list(self.variables.keys())})\"\n</code></pre>"},{"location":"api/network_model/#bayescalc.network_model.BayesianNetwork-functions","title":"Functions","text":""},{"location":"api/network_model/#bayescalc.network_model.BayesianNetwork.add_variable","title":"<code>add_variable(name, domain)</code>","text":"<p>Adds a variable to the network.</p> Source code in <code>src/bayescalc/network_model.py</code> <pre><code>def add_variable(self, name: str, domain: Tuple[str, ...]):\n    \"\"\"Adds a variable to the network.\"\"\"\n    if name in self.variables:\n        raise ValueError(f\"Variable '{name}' already exists.\")\n    self.variables[name] = Variable(name, domain)\n    self.variable_order.append(name)\n    self.adj[name] = set()\n    self.rev_adj[name] = set()\n</code></pre>"},{"location":"api/network_model/#bayescalc.network_model.BayesianNetwork.add_factor","title":"<code>add_factor(variable_name, parent_names, cpt_entries)</code>","text":"<p>Adds a factor (CPT) to the network.</p> Source code in <code>src/bayescalc/network_model.py</code> <pre><code>def add_factor(\n    self,\n    variable_name: str,\n    parent_names: List[str],\n    cpt_entries: Dict[Tuple[str, ...], float],\n):\n    \"\"\"Adds a factor (CPT) to the network.\"\"\"\n    if variable_name not in self.variables:\n        raise ValueError(f\"Variable '{variable_name}' not found.\")\n\n    variable = self.variables[variable_name]\n    parents = [self.variables[p] for p in parent_names]\n\n    factor_variables = (variable,) + tuple(parents)\n    factor = Factor(factor_variables)\n\n    # Validate and auto-complete CPT\n    self._validate_and_complete_cpt(factor, cpt_entries, variable, parents)\n\n    self.factors[variable_name] = factor\n\n    for p in parent_names:\n        self.adj[p].add(variable_name)\n        self.rev_adj[variable_name].add(p)\n</code></pre>"},{"location":"api/network_model/#bayescalc.network_model.BayesianNetwork.get_parents","title":"<code>get_parents(variable_name)</code>","text":"<p>Returns the parents of a variable.</p> Source code in <code>src/bayescalc/network_model.py</code> <pre><code>def get_parents(self, variable_name: str) -&gt; Set[str]:\n    \"\"\"Returns the parents of a variable.\"\"\"\n    return self.rev_adj.get(variable_name, set())\n</code></pre>"},{"location":"api/network_model/#bayescalc.network_model.BayesianNetwork.get_children","title":"<code>get_children(variable_name)</code>","text":"<p>Returns the children of a variable.</p> Source code in <code>src/bayescalc/network_model.py</code> <pre><code>def get_children(self, variable_name: str) -&gt; Set[str]:\n    \"\"\"Returns the children of a variable.\"\"\"\n    return self.adj.get(variable_name, set())\n</code></pre>"},{"location":"api/parser/","title":"Parser","text":""},{"location":"api/parser/#bayescalc.parser","title":"<code>bayescalc.parser</code>","text":"<p>This module implements the parser for the Bayesian Network input format. It takes a list of tokens from the lexer and builds a BayesianNetwork object.</p>"},{"location":"api/parser/#bayescalc.parser-classes","title":"Classes","text":""},{"location":"api/parser/#bayescalc.parser.Parser","title":"<code>Parser</code>","text":"Source code in <code>src/bayescalc/parser.py</code> <pre><code>class Parser:\n    def __init__(self, tokens: List[Token]):\n        self.tokens = [t for t in tokens if t.type != TokenType.NEWLINE]\n        self.pos = 0\n        self.network = BayesianNetwork()\n\n    def _peek(self) -&gt; Token:\n        if self.pos &lt; len(self.tokens):\n            return self.tokens[self.pos]\n        return self.tokens[-1]  # EOF\n\n    def _advance(self) -&gt; Token:\n        token = self.tokens[self.pos]\n        self.pos += 1\n        return token\n\n    def _consume(self, expected_type: TokenType) -&gt; Token:\n        token = self._peek()\n        if token.type == expected_type:\n            return self._advance()\n        raise SyntaxError(\n            f\"Expected {expected_type.name} but found {token.type.name} at line {token.line}, column {token.column}\"\n        )\n\n    def parse(self) -&gt; BayesianNetwork:\n        while self._peek().type != TokenType.EOF:\n            if self._peek().type == TokenType.VARIABLE:\n                self._parse_variable_declaration()\n            elif self._peek().type == TokenType.BOOLEAN:\n                self._parse_boolean_declaration()\n            elif self._peek().type == TokenType.IDENTIFIER:\n                self._parse_cpt_block()\n            else:\n                token = self._peek()\n                raise SyntaxError(\n                    f\"Unexpected token {token.type.name} at line {token.line}, column {token.column}\"\n                )\n        return self.network\n\n    def _parse_variable_declaration(self):\n        \"\"\"Parses a variable declaration.\"\"\"\n        self._consume(TokenType.VARIABLE)\n        name_token = self._consume(TokenType.IDENTIFIER)\n        name = name_token.value\n\n        # Check if domain is explicitly specified\n        if self._peek().type == TokenType.LBRACE:\n            self._consume(TokenType.LBRACE)  # Consume the left brace\n\n            # Parse domain values\n            domain = []\n            while self._peek().type != TokenType.RBRACE:\n                value = self._consume(TokenType.IDENTIFIER).value\n                domain.append(value)\n\n                if self._peek().type == TokenType.COMMA:\n                    self._consume(TokenType.COMMA)\n                else:  # We only accept comment or spaces after variable declaration\n                    break\n\n            self._consume(TokenType.RBRACE)\n\n            # Check if this is an explicit {True, False} domain and warn\n            if set(domain) == {\"True\", \"False\"}:\n                warnings.warn(\n                    f\"Variable '{name}' at line {name_token.line} uses explicit {{True, False}} domain. \"\n                    f\"Consider using 'boolean {name}' instead for clearer boolean variable declaration.\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n        else:\n            # If domain is not specified, default to Boolean\n            domain = [\"True\", \"False\"]\n\n        # Add variable to the network\n        self.network.add_variable(name, tuple(domain))\n\n    def _parse_boolean_declaration(self):\n        \"\"\"Parses a boolean variable declaration.\"\"\"\n        self._consume(TokenType.BOOLEAN)\n        name = self._consume(TokenType.IDENTIFIER).value\n\n        # Boolean variables always have {True, False} domain\n        domain = (\"True\", \"False\")\n\n        # Add variable to the network\n        self.network.add_variable(name, domain)\n\n    def _parse_cpt_block(self):\n        variable_name = self._consume(TokenType.IDENTIFIER).value\n\n        parent_names = []\n        if self._peek().type == TokenType.PIPE:\n            self._consume(TokenType.PIPE)\n            while self._peek().type != TokenType.LBRACE:\n                parent_names.append(self._consume(TokenType.IDENTIFIER).value)\n                if self._peek().type == TokenType.COMMA:\n                    self._consume(TokenType.COMMA)\n\n        self._consume(TokenType.LBRACE)\n\n        cpt_entries = {}\n        while self._peek().type != TokenType.RBRACE:\n            key, prob = self._parse_cpt_entry()\n            cpt_entries[key] = prob\n\n        self._consume(TokenType.RBRACE)\n        self.network.add_factor(variable_name, parent_names, cpt_entries)\n\n    def _parse_cpt_entry(self) -&gt; Tuple[Tuple[str, ...], float]:\n        self._consume(TokenType.PROBABILITY)\n        self._consume(TokenType.LPAREN)\n\n        value = self._consume(TokenType.IDENTIFIER).value\n        # Convert T/F to True/False for boolean variables\n        if value == \"T\":\n            value = \"True\"\n        elif value == \"F\":\n            value = \"False\"\n\n        conditions = []\n        if self._peek().type == TokenType.PIPE:\n            self._consume(TokenType.PIPE)\n            while self._peek().type != TokenType.RPAREN:\n                condition = self._consume(TokenType.IDENTIFIER).value\n                # Convert T/F to True/False for boolean variables in conditions\n                if condition == \"T\":\n                    condition = \"True\"\n                elif condition == \"F\":\n                    condition = \"False\"\n                conditions.append(condition)\n                if self._peek().type == TokenType.COMMA:\n                    self._consume(TokenType.COMMA)\n\n        self._consume(TokenType.RPAREN)\n        self._consume(TokenType.EQUALS)\n\n        prob_token = self._consume(TokenType.FLOAT)\n        prob = float(prob_token.value)\n\n        key = (value,) + tuple(conditions)\n        return key, prob\n</code></pre>"},{"location":"api/queries/","title":"Query Parser","text":""},{"location":"api/queries/#bayescalc.queries","title":"<code>bayescalc.queries</code>","text":"<p>This module handles parsing and executing probability queries.</p>"},{"location":"api/queries/#bayescalc.queries-classes","title":"Classes","text":""},{"location":"api/queries/#bayescalc.queries.QueryParser","title":"<code>QueryParser</code>","text":"Source code in <code>src/bayescalc/queries.py</code> <pre><code>class QueryParser:\n    def __init__(self, network: BayesianNetwork):\n        self.network = network\n        self.inference = Inference(network)\n\n    def _parse_query_string(self, query_str: str) -&gt; Tuple[str, str]:\n        \"\"\"\n        Parses the query string using regex to extract query and evidence parts.\n\n        Parameters:\n        -----------\n        query_str : str\n            The probability query string in format P(A, B=b | C=c, D=d)\n\n        Returns:\n        --------\n        Tuple[str, str]\n            A tuple containing (query_part, evidence_part)\n\n        Raises:\n        -------\n        ValueError\n            If the query string format is invalid\n        \"\"\"\n        # Simple regex for P(A, B=b | C=c, D=d)\n        match = re.match(r\"P\\(([^|]+)\\|?([^)]*)\\)\", query_str.replace(\" \", \"\"))\n        if not match:\n            raise ValueError(f\"Invalid query format: {query_str}\")\n\n        query_part = match.group(1)\n        evidence_part = match.group(2)\n\n        return query_part, evidence_part\n\n    def _validate_and_normalize_values(\n        self,\n        query_vars_names: List[str],\n        evidence: Dict[str, str],\n        query_evidence: Dict[str, str],\n    ) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\n        \"\"\"\n        Validates all variables and values in the query and evidence.\n        Normalizes boolean shorthand (T/F) to full form (True/False).\n\n        Parameters:\n        -----------\n        query_vars_names : List[str]\n            List of variable names in the query part\n        evidence : Dict[str, str]\n            Dictionary of evidence variable assignments\n        query_evidence : Dict[str, str]\n            Dictionary of query variable assignments\n\n        Returns:\n        --------\n        Tuple[Dict[str, str], Dict[str, str]]\n            Tuple containing normalized (evidence, query_evidence)\n\n        Raises:\n        -------\n        ValueError\n            If a variable is not in the network or a value is not in the domain of its variable\n        \"\"\"\n        # Validate that all variables exist in the network\n        all_vars_in_query = query_vars_names + list(evidence.keys())\n        for var in all_vars_in_query:\n            if var not in self.network.variables:\n                raise ValueError(f\"Variable '{var}' not in network\")\n\n        # Normalize and validate values\n        for var, val in {**evidence, **query_evidence}.items():\n            # If value is a boolean shorthand (T/F), convert it to full form (True/False)\n            if self.network.variables[var].is_boolean:\n                if val == \"T\":\n                    val = \"True\"\n                elif val == \"F\":\n                    val = \"False\"\n                # Update the evidence with the full form\n                if var in evidence and evidence[var] in [\"T\", \"F\"]:\n                    evidence[var] = val\n                if var in query_evidence and query_evidence[var] in [\"T\", \"F\"]:\n                    query_evidence[var] = val\n\n            # Validate that values are in the domain of their variables\n            if val not in self.network.variables[var].domain:\n                # Special handling for boolean values to accept T/F as True/False\n                if self.network.variables[var].is_boolean:\n                    if (\n                        val == \"T\" and \"True\" in self.network.variables[var].domain\n                    ) or (val == \"F\" and \"False\" in self.network.variables[var].domain):\n                        continue\n                raise ValueError(f\"Value '{val}' not in domain of variable '{var}'\")\n\n        return evidence, query_evidence\n\n    def _parse_evidence_variables(self, evidence_part: str) -&gt; Dict[str, str]:\n        \"\"\"\n        Parses the evidence part of a probability query to extract variable assignments.\n\n        Parameters:\n        -----------\n        evidence_part : str\n            The evidence part of a probability query (e.g., \"C=c, D=d\" from P(... | C=c, D=d))\n\n        Returns:\n        --------\n        Dict[str, str]\n            Dictionary mapping evidence variable names to their values\n\n        Raises:\n        -------\n        ValueError\n            If a variable doesn't exist in the network, negation is used with non-boolean variables,\n            or a non-boolean variable is missing a value\n        \"\"\"\n        evidence: Dict[str, str] = {}\n\n        if not evidence_part:\n            return evidence\n\n        for item in evidence_part.split(\",\"):\n            item = item.strip()\n\n            # Handle negation in evidence\n            if item.startswith(\"~\"):\n                var_name = item[1:].strip()\n                if var_name not in self.network.variables:\n                    raise ValueError(f\"Variable '{var_name}' not in network\")\n\n                if not self.network.variables[var_name].is_boolean:\n                    raise ValueError(\n                        f\"Negation (~) can only be used with boolean variables, but '{var_name}' is not boolean\"\n                    )\n\n                evidence[var_name] = \"False\"\n                continue\n\n            # Standard evidence format\n            if \"=\" in item:\n                var, val = item.split(\"=\")\n                var, val = var.strip(), val.strip()\n                evidence[var] = val\n            else:\n                # For boolean variables without value, assume True\n                var_name = item.strip()\n                if (\n                    var_name in self.network.variables\n                    and self.network.variables[var_name].is_boolean\n                ):\n                    evidence[var_name] = \"True\"\n                else:\n                    raise ValueError(\n                        f\"Non-boolean variable '{var_name}' must specify a value in evidence\"\n                    )\n\n        return evidence\n\n    def _parse_query_variables(\n        self, query_part: str\n    ) -&gt; Tuple[List[str], Dict[str, str]]:\n        \"\"\"\n        Parses the query part of a probability query to extract variable names and values.\n\n        Parameters:\n        -----------\n        query_part : str\n            The query part of a probability query (e.g., \"A, B=b\" from P(A, B=b | ...))\n\n        Returns:\n        --------\n        Tuple[List[str], Dict[str, str]]\n            A tuple containing:\n            - List of query variable names\n            - Dictionary mapping variable names to their values (if specified)\n\n        Raises:\n        -------\n        ValueError\n            If a variable doesn't exist in the network or negation is used with non-boolean variables\n        \"\"\"\n        query_vars_names: List[str] = []\n        query_evidence: Dict[str, str] = {}\n\n        if not query_part:\n            return query_vars_names, query_evidence\n\n        for item in query_part.split(\",\"):\n            item = item.strip()\n\n            # Handle negation for boolean variables (~Var means Var=False)\n            if item.startswith(\"~\"):\n                var_name = item[1:].strip()  # Remove the ~ prefix\n                if var_name not in self.network.variables:\n                    raise ValueError(f\"Variable '{var_name}' not in network\")\n\n                if not self.network.variables[var_name].is_boolean:\n                    raise ValueError(\n                        f\"Negation (~) can only be used with boolean variables, but '{var_name}' is not boolean\"\n                    )\n\n                query_vars_names.append(var_name)\n                query_evidence[var_name] = \"False\"\n                continue\n\n            # Handle standard variable=value format\n            if \"=\" in item:\n                var, val = item.split(\"=\")\n                var, val = var.strip(), val.strip()\n                query_vars_names.append(var)\n                query_evidence[var] = val\n            else:\n                # For boolean variables without value, assume True\n                var_name = item.strip()\n                query_vars_names.append(var_name)\n\n                # If it's a boolean variable with no value specified, assume True\n                if (\n                    var_name in self.network.variables\n                    and self.network.variables[var_name].is_boolean\n                ):\n                    query_evidence[var_name] = \"True\"\n\n        return query_vars_names, query_evidence\n\n    def _execute_inference(\n        self,\n        query_vars_names: List[str],\n        evidence: Dict[str, str],\n        query_evidence: Dict[str, str],\n    ):\n        \"\"\"\n        Executes inference using variable elimination and processes the results.\n\n        Parameters:\n        -----------\n        query_vars_names : List[str]\n            List of variable names to query\n        evidence : Dict[str, str]\n            Dictionary of evidence variable assignments\n        query_evidence : Dict[str, str]\n            Dictionary of query variable assignments\n\n        Returns:\n        --------\n        Factor\n            A Factor object representing the query result\n\n        Raises:\n        -------\n        ValueError\n            If the specified assignment cannot be found in the result\n        \"\"\"\n\n        query_vars_dict: Dict[str, str | None] = {}\n        for var_name in query_vars_names:\n            if var_name in query_evidence:\n                # If we have a specific value for this variable, use it\n                query_vars_dict[var_name] = query_evidence[var_name]\n            else:\n                # If no specific value, query all values (marginal query)\n                query_vars_dict[var_name] = None\n\n        result_factor = self.inference.variable_elimination(query_vars_dict, evidence)\n\n        # Perform inference using variable elimination\n        # result_factor = self.inference.variable_elimination(query_vars_names, evidence)\n\n        # If the original query had specific values (e.g., P(Rain=True|...)),\n        # we need to filter the final result to get that single probability.\n        if query_evidence:\n            # The result_factor contains the distribution, e.g., P(Rain|GrassWet=Yes).\n            # We need to find the assignment that matches our query_evidence.\n\n            # The factor's variables define the order in the assignment tuples.\n            # e.g., if factor.variables is (Var1, Var2), an assignment is (val1, val2)\n            try:\n                assignment_tuple = tuple(\n                    query_evidence[var.name] for var in result_factor.variables\n                )\n                prob = result_factor.probabilities[assignment_tuple]\n\n                from .network_model import Factor\n\n                final_assignment_str = \", \".join(\n                    [f\"{k}={v}\" for k, v in query_evidence.items()]\n                )\n                if evidence:\n                    final_assignment_str += \" | \" + \", \".join(\n                        [f\"{k}={v}\" for k, v in evidence.items()]\n                    )\n\n                return Factor(\n                    variables=tuple(),\n                    probabilities={tuple(): prob},\n                    name=f\"P({final_assignment_str})\",\n                )\n\n            except (KeyError, StopIteration):\n                raise ValueError(\n                    \"Could not find the specified assignment in the result.\"\n                )\n\n        return result_factor\n\n    def parse_and_execute(self, query_str: str):\n        \"\"\"\n        Parses a probability query string and executes inference on the Bayesian network.\n\n        This method coordinates the parsing, validation, and inference process by calling\n        the specialized helper methods that handle specific parts of the query.\n\n        Parameters:\n        -----------\n        query_str : str\n            The probability query string in format P(A, B=b | C=c, D=d)\n\n        Returns:\n        --------\n        Factor\n            A Factor object representing the query result\n\n        Raises:\n        -------\n        ValueError\n            If the query string format is invalid, variables don't exist in the network,\n            values are not in the domain of their variables, or other validation errors occur\n        \"\"\"\n        # Parse the query string to get query part and evidence part\n        query_part, evidence_part = self._parse_query_string(query_str)\n\n        # Parse the query variables\n        query_vars_names, query_evidence = self._parse_query_variables(query_part)\n\n        # Parse the evidence variables\n        evidence = self._parse_evidence_variables(evidence_part)\n\n        # Validate variables and values, normalizing T/F to True/False if needed\n        evidence, query_evidence = self._validate_and_normalize_values(\n            query_vars_names, evidence, query_evidence\n        )\n\n        # Execute the inference and process the results\n        return self._execute_inference(query_vars_names, evidence, query_evidence)\n</code></pre>"},{"location":"api/queries/#bayescalc.queries.QueryParser-functions","title":"Functions","text":""},{"location":"api/queries/#bayescalc.queries.QueryParser.parse_and_execute","title":"<code>parse_and_execute(query_str)</code>","text":"<p>Parses a probability query string and executes inference on the Bayesian network.</p> <p>This method coordinates the parsing, validation, and inference process by calling the specialized helper methods that handle specific parts of the query.</p>"},{"location":"api/queries/#bayescalc.queries.QueryParser.parse_and_execute--parameters","title":"Parameters:","text":"<p>query_str : str     The probability query string in format P(A, B=b | C=c, D=d)</p>"},{"location":"api/queries/#bayescalc.queries.QueryParser.parse_and_execute--returns","title":"Returns:","text":"<p>Factor     A Factor object representing the query result</p>"},{"location":"api/queries/#bayescalc.queries.QueryParser.parse_and_execute--raises","title":"Raises:","text":"<p>ValueError     If the query string format is invalid, variables don't exist in the network,     values are not in the domain of their variables, or other validation errors occur</p> Source code in <code>src/bayescalc/queries.py</code> <pre><code>def parse_and_execute(self, query_str: str):\n    \"\"\"\n    Parses a probability query string and executes inference on the Bayesian network.\n\n    This method coordinates the parsing, validation, and inference process by calling\n    the specialized helper methods that handle specific parts of the query.\n\n    Parameters:\n    -----------\n    query_str : str\n        The probability query string in format P(A, B=b | C=c, D=d)\n\n    Returns:\n    --------\n    Factor\n        A Factor object representing the query result\n\n    Raises:\n    -------\n    ValueError\n        If the query string format is invalid, variables don't exist in the network,\n        values are not in the domain of their variables, or other validation errors occur\n    \"\"\"\n    # Parse the query string to get query part and evidence part\n    query_part, evidence_part = self._parse_query_string(query_str)\n\n    # Parse the query variables\n    query_vars_names, query_evidence = self._parse_query_variables(query_part)\n\n    # Parse the evidence variables\n    evidence = self._parse_evidence_variables(evidence_part)\n\n    # Validate variables and values, normalizing T/F to True/False if needed\n    evidence, query_evidence = self._validate_and_normalize_values(\n        query_vars_names, evidence, query_evidence\n    )\n\n    # Execute the inference and process the results\n    return self._execute_inference(query_vars_names, evidence, query_evidence)\n</code></pre>"},{"location":"api/repl/","title":"REPL","text":""},{"location":"api/repl/#bayescalc.repl","title":"<code>bayescalc.repl</code>","text":"<p>This module implements the interactive REPL for the Bayesian Network calculator.</p>"},{"location":"api/repl/#bayescalc.repl-classes","title":"Classes","text":""},{"location":"api/repl/#bayescalc.repl.REPL","title":"<code>REPL</code>","text":"Source code in <code>src/bayescalc/repl.py</code> <pre><code>class REPL:\n    def __init__(self, network: BayesianNetwork):\n        self.network = network\n        self.query_parser = QueryParser(network)\n        self.command_handler = CommandHandler(\n            network, reload_callback=self._reload_network\n        )\n        self.expression_parser = ExpressionParser(self.query_parser)\n\n        # Type annotation to allow both PromptToolkitCompleter and None\n        self.completer: Optional[object] = None\n        if PROMPT_TOOLKIT_AVAILABLE:\n            self.completer = PromptToolkitCompleter(network)\n        else:\n            self.completer = None\n        self.history_file = \".bayescalc_history\"\n\n        # Type annotation to allow both PromptSession and None\n        self.session: Optional[Any] = None\n        if PROMPT_TOOLKIT_AVAILABLE:\n            self.session = PromptSession(\n                history=FileHistory(self.history_file),\n                auto_suggest=AutoSuggestFromHistory(),\n                completer=self.completer,\n                complete_while_typing=True,  # Enable tab completion while typing\n            )\n        else:\n            self.session = None\n\n    def _reload_network(self, new_network: BayesianNetwork):\n        \"\"\"Callback to update all internal references when network is reloaded.\"\"\"\n        self.network = new_network\n        self.query_parser = QueryParser(new_network)\n        self.expression_parser = ExpressionParser(self.query_parser)\n\n        # Update completer with new network\n        if PROMPT_TOOLKIT_AVAILABLE and self.completer:\n            self.completer = PromptToolkitCompleter(new_network)\n            # Update the session's completer\n            if self.session:\n                self.session.completer = self.completer\n\n    def run(self):\n        \"\"\"Starts the REPL loop.\"\"\"\n        if not PROMPT_TOOLKIT_AVAILABLE:\n            raise RuntimeError(\"REPL requires prompt_toolkit to be available\")\n\n        print(\"Bayesian Network Calculator\")\n        print(\"Type 'help' for a list of commands, 'exit' to quit.\")\n\n        while True:\n            try:\n                line = self.session.prompt(\"&gt;&gt; \").strip()\n                if not line:\n                    continue\n\n                if line.lower() == \"exit\":\n                    break\n                elif line.lower() == \"help\":\n                    self.print_help()\n                    continue\n\n                # Check if it's a known command first (before trying expression evaluation)\n                # This prevents commands like load(...) from being treated as mathematical expressions\n                if self.command_handler.is_command(line):\n                    try:\n                        result = self.command_handler.execute(line)\n                        print(result)\n                    except (ValueError, SyntaxError, KeyError) as e:\n                        print(f\"Error: {e}\", file=sys.stderr)\n                    continue\n\n                # Check if it can be evaluated as an expression (mathematical or probability)\n                if self.expression_parser.can_evaluate(line):\n                    try:\n                        result = self.expression_parser.evaluate(line)\n                        if hasattr(result, \"probabilities\"):  # It's a Factor object\n                            # Print the result as a distribution\n                            for assignment, prob in result.probabilities.items():\n                                print(\n                                    f\"  P({', '.join(assignment) if assignment else ''}) = {prob:.6f}\"\n                                )\n                        else:  # It's a scalar value\n                            print(f\"  = {result:.6f}\")\n                    except ValueError as e:\n                        print(f\"Error: {e}\", file=sys.stderr)\n                    continue\n\n                # If we reach here, it's neither a command nor an expression\n                # This should rarely happen, but provide a helpful error message\n                print(\n                    f\"Error: Unknown command or invalid expression: {line}\",\n                    file=sys.stderr,\n                )\n                print(\"Type 'help' for a list of available commands.\", file=sys.stderr)\n\n            except (ValueError, SyntaxError, KeyError) as e:\n                print(f\"Error: {e}\", file=sys.stderr)\n            except (KeyboardInterrupt, EOFError):\n                print(\"\\nExiting.\")\n                break\n\n    def print_help(self):\n        \"\"\"Prints the help message.\"\"\"\n        help_text = \"\"\"\nAvailable commands:\n  P(A, B | C=c, D=d)   - Compute conditional probability.\n  Arithmetic Expressions - Compute with probabilities:\n    P(A=a)/P(B=b)      - Divide probabilities\n    P(A=a)+P(A=b)      - Sum of probabilities\n    P(A|B=b)*2-0.5     - Operations with constants\n  Mathematical Functions - Pure math or with probabilities:\n    log10(0.5)         - Base-10 logarithm\n    sqrt(2)            - Square root\n    exp(1)             - Exponential\n    sin(0), cos(0)     - Trigonometric functions\n    log10(P(A=a))      - Apply math functions to probabilities\n    sqrt(P(A=a)) * 2   - Combine math and probability operations\n  printCPT(X)          - Print the Conditional Probability Table for variable X.\n  printJPT()           - Print the full Joint Probability Table.\n  parents(X)           - Show the parents of variable X.\n  children(X)          - Show the children of variable X.\n  showGraph()          - Display an ASCII graph of the network.\n  isindependent(A, B)  - Check if variables A and B are independent.\n  iscondindependent(A, B | C) - Check for conditional independence.\n  entropy(X)           - Compute the entropy of variable X.\n  conditional_entropy(X|Y) - Compute conditional entropy H(X|Y).\n  mutual_information(X, Y) - Compute mutual information between X and Y.\n  visualize(file, format=pdf, show_cpt=True) - Generate network visualization.\n  load(filename)       - Load a new Bayesian network from a file.\n  help()               - Show detailed help for all commands.\n  help(command)        - Show detailed help for a specific command.\n  exit                 - Exit the calculator.\n  ls / vars            - List all defined variables and their states.\n\nNote: Use 'help()' with parentheses for detailed command documentation.\n\"\"\"\n        print(help_text)\n</code></pre>"},{"location":"api/repl/#bayescalc.repl.REPL-functions","title":"Functions","text":""},{"location":"api/repl/#bayescalc.repl.REPL.run","title":"<code>run()</code>","text":"<p>Starts the REPL loop.</p> Source code in <code>src/bayescalc/repl.py</code> <pre><code>def run(self):\n    \"\"\"Starts the REPL loop.\"\"\"\n    if not PROMPT_TOOLKIT_AVAILABLE:\n        raise RuntimeError(\"REPL requires prompt_toolkit to be available\")\n\n    print(\"Bayesian Network Calculator\")\n    print(\"Type 'help' for a list of commands, 'exit' to quit.\")\n\n    while True:\n        try:\n            line = self.session.prompt(\"&gt;&gt; \").strip()\n            if not line:\n                continue\n\n            if line.lower() == \"exit\":\n                break\n            elif line.lower() == \"help\":\n                self.print_help()\n                continue\n\n            # Check if it's a known command first (before trying expression evaluation)\n            # This prevents commands like load(...) from being treated as mathematical expressions\n            if self.command_handler.is_command(line):\n                try:\n                    result = self.command_handler.execute(line)\n                    print(result)\n                except (ValueError, SyntaxError, KeyError) as e:\n                    print(f\"Error: {e}\", file=sys.stderr)\n                continue\n\n            # Check if it can be evaluated as an expression (mathematical or probability)\n            if self.expression_parser.can_evaluate(line):\n                try:\n                    result = self.expression_parser.evaluate(line)\n                    if hasattr(result, \"probabilities\"):  # It's a Factor object\n                        # Print the result as a distribution\n                        for assignment, prob in result.probabilities.items():\n                            print(\n                                f\"  P({', '.join(assignment) if assignment else ''}) = {prob:.6f}\"\n                            )\n                    else:  # It's a scalar value\n                        print(f\"  = {result:.6f}\")\n                except ValueError as e:\n                    print(f\"Error: {e}\", file=sys.stderr)\n                continue\n\n            # If we reach here, it's neither a command nor an expression\n            # This should rarely happen, but provide a helpful error message\n            print(\n                f\"Error: Unknown command or invalid expression: {line}\",\n                file=sys.stderr,\n            )\n            print(\"Type 'help' for a list of available commands.\", file=sys.stderr)\n\n        except (ValueError, SyntaxError, KeyError) as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n        except (KeyboardInterrupt, EOFError):\n            print(\"\\nExiting.\")\n            break\n</code></pre>"},{"location":"api/repl/#bayescalc.repl.REPL.print_help","title":"<code>print_help()</code>","text":"<p>Prints the help message.</p> Source code in <code>src/bayescalc/repl.py</code> <pre><code>    def print_help(self):\n        \"\"\"Prints the help message.\"\"\"\n        help_text = \"\"\"\nAvailable commands:\n  P(A, B | C=c, D=d)   - Compute conditional probability.\n  Arithmetic Expressions - Compute with probabilities:\n    P(A=a)/P(B=b)      - Divide probabilities\n    P(A=a)+P(A=b)      - Sum of probabilities\n    P(A|B=b)*2-0.5     - Operations with constants\n  Mathematical Functions - Pure math or with probabilities:\n    log10(0.5)         - Base-10 logarithm\n    sqrt(2)            - Square root\n    exp(1)             - Exponential\n    sin(0), cos(0)     - Trigonometric functions\n    log10(P(A=a))      - Apply math functions to probabilities\n    sqrt(P(A=a)) * 2   - Combine math and probability operations\n  printCPT(X)          - Print the Conditional Probability Table for variable X.\n  printJPT()           - Print the full Joint Probability Table.\n  parents(X)           - Show the parents of variable X.\n  children(X)          - Show the children of variable X.\n  showGraph()          - Display an ASCII graph of the network.\n  isindependent(A, B)  - Check if variables A and B are independent.\n  iscondindependent(A, B | C) - Check for conditional independence.\n  entropy(X)           - Compute the entropy of variable X.\n  conditional_entropy(X|Y) - Compute conditional entropy H(X|Y).\n  mutual_information(X, Y) - Compute mutual information between X and Y.\n  visualize(file, format=pdf, show_cpt=True) - Generate network visualization.\n  load(filename)       - Load a new Bayesian network from a file.\n  help()               - Show detailed help for all commands.\n  help(command)        - Show detailed help for a specific command.\n  exit                 - Exit the calculator.\n  ls / vars            - List all defined variables and their states.\n\nNote: Use 'help()' with parentheses for detailed command documentation.\n\"\"\"\n        print(help_text)\n</code></pre>"}]}